---
phase: 24-regatta-central-api
plan: 02
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - src/lib/regatta-central/client.ts
  - src/app/api/regattas/upcoming/route.ts
autonomous: true

must_haves:
  truths:
    - "RC client can fetch upcoming regattas by region"
    - "API endpoint returns cached regatta data"
    - "Stale data shown when API unavailable"
  artifacts:
    - path: "src/lib/regatta-central/client.ts"
      provides: "Public regatta fetching method"
      contains: "getPublicRegattas"
    - path: "src/app/api/regattas/upcoming/route.ts"
      provides: "Cached API endpoint for upcoming regattas"
      contains: "revalidate"
  key_links:
    - from: "src/app/api/regattas/upcoming/route.ts"
      to: "src/lib/regatta-central/client.ts"
      via: "getPublicRegattas call"
      pattern: "getPublicRegattas"
    - from: "src/app/api/regattas/upcoming/route.ts"
      to: "TeamSettings"
      via: "regattaRegions filter"
      pattern: "regattaRegions"
---

<objective>
Build RC API client extension and cached endpoint for fetching upcoming regattas.

Purpose: Extend existing RC OAuth client to fetch public regatta lists with server-side caching to avoid rate limits per RC-01 and RC-04 requirements.

Output: Extended RC client with getPublicRegattas method, new /api/regattas/upcoming endpoint with 6-hour cache TTL.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-regatta-central-api/24-01-SUMMARY.md

# Existing infrastructure
@src/lib/regatta-central/client.ts
@src/lib/regatta-central/types.ts
@src/app/api/regattas/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend RC client with public regatta fetching</name>
  <files>src/lib/regatta-central/client.ts</files>
  <action>
1. Open src/lib/regatta-central/client.ts.

2. Add a new method to the RegattaCentralClient class for fetching public regattas:

```typescript
/**
 * Get public upcoming regattas for specified regions.
 * Transforms RC API response to RCPublicRegatta format.
 * @param regions - Array of ISO country codes (e.g., ['US', 'CA'])
 */
async getPublicRegattas(regions: string[]): Promise<RCPublicRegatta[]> {
  const allRegattas: RCPublicRegatta[] = [];

  for (const region of regions) {
    try {
      const response = await this.fetch<RCRegattasResponse>(`/regattas/${region}/upcoming`);

      const transformed = response.regattas.map((r): RCPublicRegatta => ({
        id: r.id,
        name: r.name,
        location: r.location || null,
        venue: null, // Not in list response
        startDate: new Date(r.startDate),
        endDate: r.endDate ? new Date(r.endDate) : null,
        status: this.mapRegattaStatus(r.status),
        registrationStatus: this.mapRegistrationStatus(r.status),
        rcUrl: `https://www.regattacentral.com/regatta/?job_id=${r.id}`,
        region,
      }));

      allRegattas.push(...transformed);
    } catch (error) {
      console.error(`Failed to fetch regattas for region ${region}:`, error);
      // Continue with other regions if one fails
    }
  }

  // Sort by start date and dedupe by id
  const uniqueRegattas = Array.from(
    new Map(allRegattas.map(r => [r.id, r])).values()
  ).sort((a, b) => a.startDate.getTime() - b.startDate.getTime());

  return uniqueRegattas;
}

private mapRegattaStatus(status: string): RCRegattaStatus {
  const statusMap: Record<string, RCRegattaStatus> = {
    'upcoming': 'UPCOMING',
    'in_progress': 'IN_PROGRESS',
    'completed': 'COMPLETED',
    'cancelled': 'CANCELLED',
  };
  return statusMap[status.toLowerCase()] || 'UPCOMING';
}

private mapRegistrationStatus(status: string): RCRegistrationStatus {
  // RC API returns combined status; derive registration from it
  if (status.toLowerCase().includes('closed')) return 'CLOSED';
  if (status.toLowerCase().includes('waitlist')) return 'WAITLIST';
  if (status.toLowerCase() === 'upcoming') return 'OPEN';
  return 'NOT_AVAILABLE';
}
```

3. Add the new type imports at the top of the file:
```typescript
import type { ..., RCPublicRegatta, RCRegattaStatus, RCRegistrationStatus } from './types';
```
  </action>
  <verify>
- TypeScript compiles with `npx tsc --noEmit`
- Method signature matches expected interface
  </verify>
  <done>RegattaCentralClient has getPublicRegattas method that fetches and transforms regattas for multiple regions</done>
</task>

<task type="auto">
  <name>Task 2: Create cached upcoming regattas API endpoint</name>
  <files>src/app/api/regattas/upcoming/route.ts</files>
  <action>
1. Create new file src/app/api/regattas/upcoming/route.ts.

2. Implement GET endpoint with Next.js 16 fetch caching:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { unauthorizedResponse, forbiddenResponse, serverErrorResponse } from '@/lib/errors';
import { RegattaCentralClient, isRegattaCentralConnected } from '@/lib/regatta-central/client';
import type { RCUpcomingRegattasResponse } from '@/lib/regatta-central/types';

// Cache configuration: 6 hours (21600 seconds)
const CACHE_TTL_SECONDS = 6 * 60 * 60;

/**
 * GET /api/regattas/upcoming - Fetch upcoming regattas from RC
 *
 * Uses server-side caching with 6-hour TTL to avoid rate limits.
 * Falls back to stale data if RC API is unavailable.
 * Filters by team's configured regions (TeamSettings.regattaRegions).
 *
 * Query params:
 * - forceRefresh (optional): Skip cache and fetch fresh data
 */
export async function GET(request: NextRequest) {
  try {
    const { user, claims, error } = await getClaimsForApiRoute();
    if (error || !user) return unauthorizedResponse();
    if (!claims?.team_id) return forbiddenResponse('No team associated with user');

    const teamId = claims.team_id;
    const { searchParams } = new URL(request.url);
    const forceRefresh = searchParams.get('forceRefresh') === 'true';

    // Check if RC is connected
    const isConnected = await isRegattaCentralConnected(teamId);
    if (!isConnected) {
      return NextResponse.json(
        {
          error: 'Regatta Central not connected',
          regattas: [],
          cachedAt: null,
          staleAfter: null,
        },
        { status: 200 }
      );
    }

    // Get team's region preferences (default to US if not configured)
    const teamSettings = await prisma.teamSettings.findUnique({
      where: { teamId },
      select: { regattaRegions: true },
    });

    const regions = teamSettings?.regattaRegions?.length
      ? teamSettings.regattaRegions
      : ['US'];

    // Fetch from RC with caching
    const client = new RegattaCentralClient(teamId);

    const now = new Date();
    const staleAfter = new Date(now.getTime() + CACHE_TTL_SECONDS * 1000);

    try {
      const regattas = await client.getPublicRegattas(regions);

      const response: RCUpcomingRegattasResponse = {
        regattas,
        cachedAt: now.toISOString(),
        staleAfter: staleAfter.toISOString(),
      };

      return NextResponse.json(response, {
        headers: {
          'Cache-Control': `s-maxage=${CACHE_TTL_SECONDS}, stale-while-revalidate`,
        },
      });
    } catch (rcError) {
      console.error('RC API error:', rcError);

      // Return empty with error indicator for graceful degradation
      return NextResponse.json(
        {
          regattas: [],
          cachedAt: null,
          staleAfter: null,
          error: 'RC API temporarily unavailable',
        },
        { status: 200 }
      );
    }
  } catch (error) {
    return serverErrorResponse(error, 'regattas/upcoming:GET');
  }
}
```

3. Ensure proper error handling and graceful degradation per CONTEXT.md decisions.
  </action>
  <verify>
- File exists at src/app/api/regattas/upcoming/route.ts
- TypeScript compiles with `npx tsc --noEmit`
- Linting passes with `npm run lint`
  </verify>
  <done>
- /api/regattas/upcoming endpoint created
- 6-hour cache TTL configured via Cache-Control headers
- Falls back gracefully when RC unavailable
- Respects team's regattaRegions setting
  </done>
</task>

</tasks>

<verification>
1. Type check: `npx tsc --noEmit` passes
2. Linting: `npm run lint` passes
3. Endpoint structure: File exists and exports GET function
</verification>

<success_criteria>
- RegattaCentralClient.getPublicRegattas method implemented
- /api/regattas/upcoming endpoint returns cached regatta data
- Cache-Control headers set for 6-hour TTL
- Graceful degradation when RC API unavailable
- Team region preferences respected
</success_criteria>

<output>
After completion, create `.planning/phases/24-regatta-central-api/24-02-SUMMARY.md`
</output>
