---
phase: 10-security-foundation-rbac
plan: 10
type: execute
wave: 4
depends_on: ["10-05", "10-07"]
files_modified:
  - src/app/api/audit-logs/route.ts
  - src/app/api/audit-logs/export/route.ts
  - src/app/api/cron/audit-cleanup/route.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Audit logs viewable by authorized users (facility admin sees all, club admin sees club)"
    - "Logs filterable by action type, date range, user"
    - "CSV export available for compliance"
    - "365-day retention enforced via cron job"
  artifacts:
    - path: "src/app/api/audit-logs/route.ts"
      provides: "Audit log listing endpoint"
      exports: ["GET"]
    - path: "src/app/api/audit-logs/export/route.ts"
      provides: "Audit log CSV export"
      exports: ["GET"]
    - path: "src/app/api/cron/audit-cleanup/route.ts"
      provides: "Scheduled cleanup for 365-day retention"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/audit-logs/route.ts"
      to: "prisma.auditLog"
      via: "findMany"
      pattern: "auditLog\\.findMany"
---

<objective>
Create audit log viewing and export endpoints with 365-day retention.

Purpose: Compliance requires admins to view and export audit logs. Facility admins see all clubs' logs, club admins see their club's logs, coaches see only their own actions. A cron job enforces 365-day retention.

Output: Audit log API endpoints ready for admin UI, plus cleanup cron.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-security-foundation-rbac/10-CONTEXT.md
@.planning/phases/10-security-foundation-rbac/10-RESEARCH.md
@.planning/phases/10-security-foundation-rbac/10-05-SUMMARY.md
@.planning/phases/10-security-foundation-rbac/10-07-SUMMARY.md
@src/lib/audit/logger.ts
@src/lib/audit/actions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audit log listing endpoint</name>
  <files>src/app/api/audit-logs/route.ts</files>
  <action>
Create `src/app/api/audit-logs/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getAuthContext } from '@/lib/auth/get-auth-context';
import { accessibleBy } from '@casl/prisma';
import { ForbiddenError } from '@casl/ability';
import { unauthorizedResponse, forbiddenResponse, serverErrorResponse } from '@/lib/errors';
import { AUDITABLE_ACTIONS, AUDIT_ACTION_DESCRIPTIONS } from '@/lib/audit/actions';

/**
 * GET /api/audit-logs
 * List audit logs with filtering.
 *
 * Query params:
 * - action: Filter by action type
 * - userId: Filter by acting user
 * - startDate: Filter by date range start
 * - endDate: Filter by date range end
 * - limit: Max results (default 50, max 200)
 * - offset: Pagination offset
 *
 * Access:
 * - FACILITY_ADMIN: All logs
 * - CLUB_ADMIN: Their club's logs
 * - COACH: Only their own actions
 */
export async function GET(request: NextRequest) {
  try {
    const result = await getAuthContext(request);
    if (!result.success) {
      return result.status === 401
        ? unauthorizedResponse()
        : forbiddenResponse(result.error);
    }

    const { context } = result;

    // Check permission
    if (!context.ability.can('view-audit-log', 'AuditLog')) {
      return forbiddenResponse('You do not have permission to view audit logs');
    }

    const { searchParams } = new URL(request.url);
    const action = searchParams.get('action');
    const userId = searchParams.get('userId');
    const startDate = searchParams.get('startDate');
    const endDate = searchParams.get('endDate');
    const limit = Math.min(parseInt(searchParams.get('limit') ?? '50'), 200);
    const offset = parseInt(searchParams.get('offset') ?? '0');

    // Build where clause based on user's access level
    const where: Record<string, unknown> = {};

    // Access control via CASL
    try {
      const accessibleWhere = accessibleBy(context.ability).AuditLog;
      Object.assign(where, accessibleWhere);
    } catch (e) {
      if (e instanceof ForbiddenError) {
        return NextResponse.json({ logs: [], total: 0 });
      }
      throw e;
    }

    // Apply filters
    if (action && action in AUDITABLE_ACTIONS) {
      where.action = action;
    }

    if (userId) {
      where.userId = userId;
    }

    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        (where.createdAt as Record<string, Date>).gte = new Date(startDate);
      }
      if (endDate) {
        (where.createdAt as Record<string, Date>).lte = new Date(endDate);
      }
    }

    // Query with pagination
    const [logs, total] = await Promise.all([
      prisma.auditLog.findMany({
        where,
        orderBy: { createdAt: 'desc' },
        take: limit,
        skip: offset,
      }),
      prisma.auditLog.count({ where }),
    ]);

    // Enrich with action descriptions
    const enrichedLogs = logs.map((log) => ({
      ...log,
      actionDescription: AUDIT_ACTION_DESCRIPTIONS[log.action as keyof typeof AUDIT_ACTION_DESCRIPTIONS] ?? log.action,
    }));

    return NextResponse.json({
      logs: enrichedLogs,
      total,
      limit,
      offset,
      hasMore: offset + logs.length < total,
    });
  } catch (error) {
    return serverErrorResponse(error, 'audit-logs:GET');
  }
}
```

Create the directory if needed: `src/app/api/audit-logs/`
  </action>
  <verify>TypeScript compilation passes: `npx tsc --noEmit src/app/api/audit-logs/route.ts`</verify>
  <done>Audit log listing endpoint created with filtering and CASL-based access control</done>
</task>

<task type="auto">
  <name>Task 2: Create audit log CSV export endpoint</name>
  <files>src/app/api/audit-logs/export/route.ts</files>
  <action>
Create `src/app/api/audit-logs/export/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getAuthContext } from '@/lib/auth/get-auth-context';
import { accessibleBy } from '@casl/prisma';
import { ForbiddenError } from '@casl/ability';
import { createAuditLogger } from '@/lib/audit/logger';
import { unauthorizedResponse, forbiddenResponse, serverErrorResponse } from '@/lib/errors';
import { AUDIT_ACTION_DESCRIPTIONS } from '@/lib/audit/actions';

/**
 * GET /api/audit-logs/export
 * Export audit logs as CSV.
 *
 * Query params (same as list):
 * - action, userId, startDate, endDate
 *
 * This action is itself audited (DATA_EXPORTED).
 */
export async function GET(request: NextRequest) {
  try {
    const result = await getAuthContext(request);
    if (!result.success) {
      return result.status === 401
        ? unauthorizedResponse()
        : forbiddenResponse(result.error);
    }

    const { context } = result;

    // Check permission - need both view-audit-log and export-data
    if (!context.ability.can('view-audit-log', 'AuditLog') ||
        !context.ability.can('export-data', 'Team')) {
      return forbiddenResponse('You do not have permission to export audit logs');
    }

    const { searchParams } = new URL(request.url);
    const action = searchParams.get('action');
    const userId = searchParams.get('userId');
    const startDate = searchParams.get('startDate');
    const endDate = searchParams.get('endDate');

    // Build where clause
    const where: Record<string, unknown> = {};

    try {
      const accessibleWhere = accessibleBy(context.ability).AuditLog;
      Object.assign(where, accessibleWhere);
    } catch (e) {
      if (e instanceof ForbiddenError) {
        return NextResponse.json({ error: 'No access to audit logs' }, { status: 403 });
      }
      throw e;
    }

    if (action) where.action = action;
    if (userId) where.userId = userId;
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) (where.createdAt as Record<string, Date>).gte = new Date(startDate);
      if (endDate) (where.createdAt as Record<string, Date>).lte = new Date(endDate);
    }

    // Query all matching logs (no pagination for export)
    const logs = await prisma.auditLog.findMany({
      where,
      orderBy: { createdAt: 'desc' },
    });

    // Audit the export
    const audit = createAuditLogger(request, {
      clubId: context.clubId,
      userId: context.userId,
    });

    await audit.log({
      action: 'DATA_EXPORTED',
      targetType: 'AuditLog',
      metadata: {
        filters: { action, userId, startDate, endDate },
        recordCount: logs.length,
      },
    });

    // Generate CSV
    const headers = [
      'ID',
      'Timestamp',
      'Action',
      'Action Description',
      'User ID',
      'Target Type',
      'Target ID',
      'Club ID',
      'IP Address',
      'User Agent',
      'Metadata',
    ];

    const rows = logs.map((log) => [
      log.id,
      log.createdAt.toISOString(),
      log.action,
      AUDIT_ACTION_DESCRIPTIONS[log.action as keyof typeof AUDIT_ACTION_DESCRIPTIONS] ?? log.action,
      log.userId,
      log.targetType,
      log.targetId ?? '',
      log.clubId,
      log.ipAddress ?? '',
      log.userAgent ?? '',
      JSON.stringify(log.metadata),
    ]);

    const csv = [
      headers.map(escapeCSV).join(','),
      ...rows.map((row) => row.map(escapeCSV).join(',')),
    ].join('\n');

    // Return as downloadable CSV
    const filename = `audit-logs-${new Date().toISOString().split('T')[0]}.csv`;

    return new NextResponse(csv, {
      headers: {
        'Content-Type': 'text/csv; charset=utf-8',
        'Content-Disposition': `attachment; filename="${filename}"`,
      },
    });
  } catch (error) {
    return serverErrorResponse(error, 'audit-logs/export:GET');
  }
}

/**
 * Escape a value for CSV output.
 */
function escapeCSV(value: unknown): string {
  const str = String(value ?? '');
  if (str.includes(',') || str.includes('"') || str.includes('\n')) {
    return `"${str.replace(/"/g, '""')}"`;
  }
  return str;
}
```

Create the directory if needed: `src/app/api/audit-logs/export/`
  </action>
  <verify>TypeScript compilation passes: `npx tsc --noEmit src/app/api/audit-logs/export/route.ts`</verify>
  <done>Audit log CSV export endpoint created with proper escaping and self-auditing</done>
</task>

<task type="auto">
  <name>Task 3: Create audit cleanup cron endpoint</name>
  <files>src/app/api/cron/audit-cleanup/route.ts</files>
  <action>
Create `src/app/api/cron/audit-cleanup/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

/**
 * GET /api/cron/audit-cleanup
 * Deletes audit log entries older than 365 days.
 *
 * This endpoint should be called by a scheduled job (e.g., Vercel Cron).
 * Protected by CRON_SECRET environment variable.
 *
 * Vercel Cron config (vercel.json):
 * {
 *   "crons": [{
 *     "path": "/api/cron/audit-cleanup",
 *     "schedule": "0 3 * * *"  // Daily at 3am UTC
 *   }]
 * }
 */
export async function GET(request: NextRequest) {
  try {
    // Verify cron secret
    const authHeader = request.headers.get('authorization');
    const cronSecret = process.env.CRON_SECRET;

    if (!cronSecret) {
      console.error('CRON_SECRET not configured');
      return NextResponse.json(
        { error: 'Cron not configured' },
        { status: 500 }
      );
    }

    if (authHeader !== `Bearer ${cronSecret}`) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Calculate cutoff date (365 days ago)
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - 365);

    // Delete old records
    const result = await prisma.auditLog.deleteMany({
      where: {
        createdAt: { lt: cutoffDate },
      },
    });

    console.log(`Audit cleanup: deleted ${result.count} records older than ${cutoffDate.toISOString()}`);

    return NextResponse.json({
      success: true,
      deleted: result.count,
      cutoffDate: cutoffDate.toISOString(),
    });
  } catch (error) {
    console.error('Audit cleanup failed:', error);
    return NextResponse.json(
      { error: 'Cleanup failed' },
      { status: 500 }
    );
  }
}
```

Create the directory if needed: `src/app/api/cron/audit-cleanup/`

Note: CRON_SECRET should be added to environment variables. For Vercel, crons are automatically authenticated when called by the Vercel scheduler, but we add our own check for security.
  </action>
  <verify>TypeScript compilation passes: `npx tsc --noEmit src/app/api/cron/audit-cleanup/route.ts`</verify>
  <done>Audit cleanup cron endpoint created with 365-day retention enforcement</done>
</task>

</tasks>

<verification>
1. TypeScript compiles all new files
2. GET /api/audit-logs returns paginated, filtered logs
3. Logs filtered by CASL ability (facility admin sees all, club admin sees club, coach sees own)
4. GET /api/audit-logs/export returns CSV with proper escaping
5. Export action is itself audited
6. GET /api/cron/audit-cleanup deletes records older than 365 days
7. Cron endpoint requires CRON_SECRET authorization
</verification>

<success_criteria>
- GET /api/audit-logs returns logs with pagination (limit, offset)
- Logs filterable by action, userId, startDate, endDate
- Access control: FACILITY_ADMIN all, CLUB_ADMIN their club, COACH their actions
- GET /api/audit-logs/export returns downloadable CSV
- Export properly escapes commas, quotes, newlines
- Export is audited as DATA_EXPORTED
- Cron endpoint protected by CRON_SECRET
- Records older than 365 days deleted by cron
</success_criteria>

<output>
After completion, create `.planning/phases/10-security-foundation-rbac/10-10-SUMMARY.md`
</output>
