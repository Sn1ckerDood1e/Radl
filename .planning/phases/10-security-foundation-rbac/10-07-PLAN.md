---
phase: 10-security-foundation-rbac
plan: 07
type: execute
wave: 3
depends_on: ["10-02", "10-03"]
files_modified:
  - src/lib/auth/get-auth-context.ts
  - src/app/api/practices/route.ts
  - src/app/api/equipment/route.ts
  - src/app/api/lineups/route.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "API routes use CASL ability for permission checks"
    - "accessibleBy() filters queries to authorized data"
    - "ForbiddenError handled gracefully (returns empty or 403)"
    - "Permission checks are server-side (client checks for UX only)"
  artifacts:
    - path: "src/lib/auth/get-auth-context.ts"
      provides: "Combined auth context with CASL ability"
      exports: ["getAuthContext", "AuthContext"]
  key_links:
    - from: "src/lib/auth/get-auth-context.ts"
      to: "src/lib/permissions/ability.ts"
      via: "defineAbilityFor"
      pattern: "defineAbilityFor"
    - from: "src/app/api/practices/route.ts"
      to: "@casl/prisma"
      via: "accessibleBy"
      pattern: "accessibleBy"
---

<objective>
Integrate CASL permissions into API routes for server-side authorization.

Purpose: Replace simple role === checks with CASL ability checks. This provides consistent permission enforcement and enables field-level/condition-based access control. accessibleBy() automatically filters queries to data the user can access.

Output: Helper function for getting auth context with ability, and updated API routes using CASL.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-security-foundation-rbac/10-CONTEXT.md
@.planning/phases/10-security-foundation-rbac/10-RESEARCH.md
@.planning/phases/10-security-foundation-rbac/10-02-SUMMARY.md
@.planning/phases/10-security-foundation-rbac/10-03-SUMMARY.md
@src/lib/permissions/ability.ts
@src/lib/auth/claims.ts
@src/app/api/practices/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unified auth context helper</name>
  <files>src/lib/auth/get-auth-context.ts</files>
  <action>
Create `src/lib/auth/get-auth-context.ts` that combines auth, club context, and CASL ability:

```typescript
import { NextRequest } from 'next/server';
import { getClaimsForApiRoute } from './claims';
import { defineAbilityFor, createEmptyAbility, type AppAbility, type UserContext } from '@/lib/permissions/ability';
import { prisma } from '@/lib/prisma';

/**
 * Combined auth context for API routes.
 * Includes user, club, roles, and CASL ability.
 */
export interface AuthContext {
  userId: string;
  clubId: string;
  roles: string[];
  ability: AppAbility;
  linkedAthleteIds?: string[];  // For PARENT role
}

/**
 * Result of getAuthContext.
 */
export type AuthContextResult =
  | { success: true; context: AuthContext }
  | { success: false; error: string; status: 401 | 403 };

/**
 * Gets complete auth context for an API route.
 *
 * Handles:
 * 1. Session auth (getClaimsForApiRoute)
 * 2. API key auth (from middleware headers)
 * 3. Club context (from cookie or API key)
 * 4. CASL ability creation
 *
 * @param request - Next.js request (optional, for API key header detection)
 */
export async function getAuthContext(request?: NextRequest): Promise<AuthContextResult> {
  // Check for API key auth (set by middleware)
  if (request) {
    const apiKeyClubId = request.headers.get('x-api-key-club-id');
    const apiKeyUserId = request.headers.get('x-api-key-user-id');

    if (apiKeyClubId && apiKeyUserId) {
      // Get the creator's membership for permissions
      const membership = await prisma.clubMembership.findFirst({
        where: {
          clubId: apiKeyClubId,
          userId: apiKeyUserId,
          isActive: true,
        },
      });

      if (!membership) {
        return {
          success: false,
          error: 'API key creator no longer has access to this club',
          status: 403,
        };
      }

      const userContext: UserContext = {
        userId: apiKeyUserId,
        clubId: apiKeyClubId,
        roles: membership.roles as UserContext['roles'],
      };

      return {
        success: true,
        context: {
          userId: apiKeyUserId,
          clubId: apiKeyClubId,
          roles: membership.roles,
          ability: defineAbilityFor(userContext),
        },
      };
    }
  }

  // Session-based auth
  const { user, clubId, roles, error } = await getClaimsForApiRoute();

  if (error || !user) {
    return { success: false, error: 'Unauthorized', status: 401 };
  }

  if (!clubId) {
    return { success: false, error: 'No club selected', status: 403 };
  }

  // For PARENT role, get linked athlete IDs
  let linkedAthleteIds: string[] | undefined;
  if (roles.includes('PARENT')) {
    // TODO: Query ParentAthleteLink table when it exists
    // For now, parents can see all athletes in their club (to be refined)
    linkedAthleteIds = [];
  }

  const userContext: UserContext = {
    userId: user.id,
    clubId,
    roles: roles as UserContext['roles'],
    linkedAthleteIds,
  };

  return {
    success: true,
    context: {
      userId: user.id,
      clubId,
      roles,
      ability: defineAbilityFor(userContext),
      linkedAthleteIds,
    },
  };
}
```
  </action>
  <verify>TypeScript compilation passes: `npx tsc --noEmit src/lib/auth/get-auth-context.ts`</verify>
  <done>Unified auth context helper created with session and API key support</done>
</task>

<task type="auto">
  <name>Task 2: Update practices route to use CASL</name>
  <files>src/app/api/practices/route.ts</files>
  <action>
Update `src/app/api/practices/route.ts` to use CASL for authorization:

Replace the existing role checks with CASL ability checks:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getAuthContext } from '@/lib/auth/get-auth-context';
import { accessibleBy } from '@casl/prisma';
import { ForbiddenError, subject } from '@casl/ability';
import { unauthorizedResponse, forbiddenResponse, serverErrorResponse } from '@/lib/errors';
import { createPracticeSchema } from '@/lib/validations/practice';

// GET: List practices for current club
export async function GET(request: NextRequest) {
  try {
    const result = await getAuthContext(request);
    if (!result.success) {
      return result.status === 401
        ? unauthorizedResponse()
        : forbiddenResponse(result.error);
    }

    const { context } = result;
    const { searchParams } = new URL(request.url);
    const seasonId = searchParams.get('seasonId');
    const startDate = searchParams.get('startDate');
    const endDate = searchParams.get('endDate');

    // Build base where clause
    const where: Record<string, unknown> = {
      teamId: context.clubId,
    };

    if (seasonId) {
      where.seasonId = seasonId;
    }

    // Date range filter
    if (startDate || endDate) {
      where.date = {};
      if (startDate) (where.date as Record<string, Date>).gte = new Date(startDate);
      if (endDate) (where.date as Record<string, Date>).lte = new Date(endDate);
    }

    try {
      // Use accessibleBy to filter to authorized practices
      const practices = await prisma.practice.findMany({
        where: {
          AND: [
            accessibleBy(context.ability).Practice,
            where,
          ],
        },
        include: {
          blocks: {
            orderBy: { position: 'asc' },
          },
        },
        orderBy: [
          { date: 'asc' },
          { startTime: 'asc' },
        ],
      });

      // For non-coaches, filter to PUBLISHED only
      // (CASL handles read permission, but status filter is business logic)
      const filteredPractices = context.ability.can('manage', 'Practice')
        ? practices
        : practices.filter(p => p.status === 'PUBLISHED');

      return NextResponse.json({ practices: filteredPractices });
    } catch (e) {
      if (e instanceof ForbiddenError) {
        return NextResponse.json({ practices: [] });
      }
      throw e;
    }
  } catch (error) {
    return serverErrorResponse(error, 'practices:GET');
  }
}

// POST: Create new practice (requires manage permission)
export async function POST(request: NextRequest) {
  try {
    const result = await getAuthContext(request);
    if (!result.success) {
      return result.status === 401
        ? unauthorizedResponse()
        : forbiddenResponse(result.error);
    }

    const { context } = result;

    // Check create permission
    if (!context.ability.can('create', 'Practice')) {
      return forbiddenResponse('You do not have permission to create practices');
    }

    const body = await request.json();
    const validationResult = createPracticeSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: validationResult.error.flatten() },
        { status: 400 }
      );
    }

    const { seasonId, name, date, startTime, endTime, notes, blocks } = validationResult.data;

    // Verify season belongs to club
    const season = await prisma.season.findFirst({
      where: { id: seasonId, teamId: context.clubId },
    });

    if (!season) {
      return NextResponse.json(
        { error: 'Season not found or does not belong to your club' },
        { status: 404 }
      );
    }

    // Create practice with nested blocks
    const practice = await prisma.practice.create({
      data: {
        teamId: context.clubId,
        seasonId,
        name,
        date: new Date(date),
        startTime: new Date(startTime),
        endTime: new Date(endTime),
        notes: notes || null,
        status: 'DRAFT',
        blocks: {
          create: blocks.map((block, index) => ({
            position: index,
            type: block.type,
            durationMinutes: block.durationMinutes || null,
            category: block.category || null,
            notes: block.notes || null,
          })),
        },
      },
      include: {
        blocks: {
          orderBy: { position: 'asc' },
        },
      },
    });

    return NextResponse.json({ practice }, { status: 201 });
  } catch (error) {
    return serverErrorResponse(error, 'practices:POST');
  }
}
```
  </action>
  <verify>
TypeScript compilation passes: `npx tsc --noEmit src/app/api/practices/route.ts`
  </verify>
  <done>Practices route updated to use CASL ability checks and accessibleBy</done>
</task>

<task type="auto">
  <name>Task 3: Update equipment and lineups routes to use CASL</name>
  <files>src/app/api/equipment/route.ts, src/app/api/lineups/route.ts</files>
  <action>
Update `src/app/api/equipment/route.ts` and `src/app/api/lineups/route.ts` with the same pattern:

For `src/app/api/equipment/route.ts`:
- Import getAuthContext and accessibleBy
- Replace getClaimsForApiRoute with getAuthContext
- Use context.ability.can('create', 'Equipment') for POST
- Use accessibleBy(context.ability).Equipment for GET queries
- Handle ForbiddenError by returning empty array

For `src/app/api/lineups/route.ts`:
- Import getAuthContext and accessibleBy
- Replace getClaimsForApiRoute with getAuthContext
- Use context.ability.can('create', 'Lineup') for POST
- Use accessibleBy(context.ability).Lineup for GET queries
- Handle ForbiddenError by returning empty array

Pattern for both:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getAuthContext } from '@/lib/auth/get-auth-context';
import { accessibleBy } from '@casl/prisma';
import { ForbiddenError } from '@casl/ability';
import { unauthorizedResponse, forbiddenResponse, serverErrorResponse } from '@/lib/errors';

// GET handler pattern:
export async function GET(request: NextRequest) {
  try {
    const result = await getAuthContext(request);
    if (!result.success) {
      return result.status === 401
        ? unauthorizedResponse()
        : forbiddenResponse(result.error);
    }

    const { context } = result;

    try {
      const items = await prisma.MODEL.findMany({
        where: accessibleBy(context.ability).MODEL,
        // ... include, orderBy
      });
      return NextResponse.json({ items });
    } catch (e) {
      if (e instanceof ForbiddenError) {
        return NextResponse.json({ items: [] });
      }
      throw e;
    }
  } catch (error) {
    return serverErrorResponse(error, 'MODEL:GET');
  }
}

// POST handler pattern:
export async function POST(request: NextRequest) {
  try {
    const result = await getAuthContext(request);
    if (!result.success) {
      return result.status === 401
        ? unauthorizedResponse()
        : forbiddenResponse(result.error);
    }

    const { context } = result;

    if (!context.ability.can('create', 'MODEL')) {
      return forbiddenResponse('You do not have permission to create MODEL');
    }

    // ... validation and creation
  } catch (error) {
    return serverErrorResponse(error, 'MODEL:POST');
  }
}
```

Apply this pattern to both routes, keeping the existing business logic intact.
  </action>
  <verify>
TypeScript compilation passes for both files:
- `npx tsc --noEmit src/app/api/equipment/route.ts`
- `npx tsc --noEmit src/app/api/lineups/route.ts`
  </verify>
  <done>Equipment and lineups routes updated to use CASL permissions</done>
</task>

</tasks>

<verification>
1. TypeScript compiles all modified files
2. getAuthContext handles both session and API key auth
3. API routes use ability.can() for create/update/delete checks
4. API routes use accessibleBy() for query filtering
5. ForbiddenError handled gracefully (returns empty array or 403)
6. Existing functionality preserved (same response shapes)
</verification>

<success_criteria>
- src/lib/auth/get-auth-context.ts exports getAuthContext and AuthContext type
- getAuthContext returns ability instance with user's permissions
- Practices route uses accessibleBy for query filtering
- Practices route uses ability.can for create permission
- Equipment and lineups routes follow same pattern
- ForbiddenError returns empty array, not 500 error
- API key auth works (via x-api-key-* headers from middleware)
</success_criteria>

<output>
After completion, create `.planning/phases/10-security-foundation-rbac/10-07-SUMMARY.md`
</output>
