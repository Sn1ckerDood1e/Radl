---
phase: 10-security-foundation-rbac
plan: 06
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/lib/auth/api-key.ts
  - src/middleware.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "API keys use sk_ prefix pattern (Stripe-like)"
    - "Only key hash is stored in database (never raw key)"
    - "Key validation uses timing-safe comparison"
    - "Middleware validates API key for /api/* routes"
    - "Raw key only returned once at creation"
  artifacts:
    - path: "src/lib/auth/api-key.ts"
      provides: "API key creation and validation"
      exports: ["createApiKey", "validateApiKey", "revokeApiKey"]
  key_links:
    - from: "src/lib/auth/api-key.ts"
      to: "prisma.apiKey"
      via: "create/findUnique"
      pattern: "apiKey\\.(create|findUnique)"
    - from: "src/middleware.ts"
      to: "src/lib/auth/api-key.ts"
      via: "validateApiKey"
      pattern: "validateApiKey"
---

<objective>
Implement API key authentication for external integrations.

Purpose: External systems (mobile apps, automation tools) need to authenticate without browser sessions. API keys follow the Stripe pattern: sk_ prefix, SHA-256 hashed storage, timing-safe validation. Keys inherit permissions from the user who created them.

Output: API key creation/validation utilities and middleware integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-security-foundation-rbac/10-CONTEXT.md
@.planning/phases/10-security-foundation-rbac/10-RESEARCH.md
@.planning/phases/10-security-foundation-rbac/10-01-SUMMARY.md
@src/middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API key utilities</name>
  <files>src/lib/auth/api-key.ts</files>
  <action>
Create `src/lib/auth/api-key.ts`:

```typescript
import crypto from 'crypto';
import { nanoid } from 'nanoid';
import { prisma } from '@/lib/prisma';

const KEY_PREFIX = 'sk_';      // Secret key prefix (Stripe pattern)
const KEY_LENGTH = 32;          // Random part length
const PREFIX_DISPLAY_LENGTH = 8; // Chars to show for identification

/**
 * Result of API key creation.
 * key is only returned once - store it securely!
 */
export interface CreateApiKeyResult {
  id: string;
  key: string;        // Full key - only returned at creation
  keyPrefix: string;  // For display/identification
  expiresAt: Date | null;
}

/**
 * Creates a new API key for a club.
 *
 * The raw key is returned ONLY at creation time.
 * Store it securely - we only keep the hash.
 *
 * @param clubId - Club the key belongs to
 * @param name - User-friendly name for the key
 * @param createdBy - userId who is creating the key
 * @param expiresAt - Optional expiration date
 */
export async function createApiKey(
  clubId: string,
  name: string,
  createdBy: string,
  expiresAt?: Date
): Promise<CreateApiKeyResult> {
  // Generate secure random key
  const randomPart = nanoid(KEY_LENGTH);
  const fullKey = `${KEY_PREFIX}${randomPart}`;
  const keyPrefix = fullKey.substring(0, PREFIX_DISPLAY_LENGTH);

  // Hash for storage (never store raw key)
  const keyHash = crypto
    .createHash('sha256')
    .update(fullKey)
    .digest('hex');

  const apiKey = await prisma.apiKey.create({
    data: {
      clubId,
      name,
      keyPrefix,
      keyHash,
      createdBy,
      permissions: {}, // Full access per CONTEXT.md decision
      expiresAt: expiresAt ?? null,
    },
  });

  return {
    id: apiKey.id,
    key: fullKey, // Only returned once!
    keyPrefix,
    expiresAt: apiKey.expiresAt,
  };
}

/**
 * Result of API key validation.
 */
export interface ValidateApiKeyResult {
  valid: boolean;
  clubId?: string;
  userId?: string;  // Creator's userId for permission inheritance
}

/**
 * Validates an API key.
 *
 * Checks:
 * 1. Key has correct prefix
 * 2. Hash exists in database
 * 3. Key is not revoked
 * 4. Key is not expired
 *
 * Updates lastUsedAt timestamp on successful validation.
 *
 * @param key - Full API key to validate
 */
export async function validateApiKey(key: string): Promise<ValidateApiKeyResult> {
  // Check prefix
  if (!key.startsWith(KEY_PREFIX)) {
    return { valid: false };
  }

  // Hash the provided key
  const keyHash = crypto
    .createHash('sha256')
    .update(key)
    .digest('hex');

  // Look up by hash
  const apiKey = await prisma.apiKey.findUnique({
    where: { keyHash },
    select: {
      id: true,
      clubId: true,
      createdBy: true,
      expiresAt: true,
      revokedAt: true,
    },
  });

  if (!apiKey) {
    return { valid: false };
  }

  // Check if revoked
  if (apiKey.revokedAt) {
    return { valid: false };
  }

  // Check if expired
  if (apiKey.expiresAt && apiKey.expiresAt < new Date()) {
    return { valid: false };
  }

  // Update last used timestamp (fire and forget)
  prisma.apiKey
    .update({
      where: { id: apiKey.id },
      data: { lastUsedAt: new Date() },
    })
    .catch(() => {
      // Non-blocking - don't fail validation if update fails
    });

  return {
    valid: true,
    clubId: apiKey.clubId,
    userId: apiKey.createdBy,
  };
}

/**
 * Revokes an API key (soft delete).
 *
 * @param keyId - ID of the key to revoke
 * @param revokedBy - userId performing the revocation (for audit)
 */
export async function revokeApiKey(keyId: string): Promise<void> {
  await prisma.apiKey.update({
    where: { id: keyId },
    data: { revokedAt: new Date() },
  });
}

/**
 * Lists API keys for a club (for admin view).
 * Does NOT return key hashes.
 */
export async function listApiKeys(clubId: string) {
  return prisma.apiKey.findMany({
    where: {
      clubId,
      revokedAt: null, // Only active keys
    },
    select: {
      id: true,
      name: true,
      keyPrefix: true,
      createdBy: true,
      lastUsedAt: true,
      expiresAt: true,
      createdAt: true,
    },
    orderBy: { createdAt: 'desc' },
  });
}
```
  </action>
  <verify>TypeScript compilation passes: `npx tsc --noEmit src/lib/auth/api-key.ts`</verify>
  <done>API key utilities created with secure hash storage and validation</done>
</task>

<task type="auto">
  <name>Task 2: Add API key validation to middleware</name>
  <files>src/middleware.ts</files>
  <action>
Update `src/middleware.ts` to handle API key authentication for /api/* routes:

Add import at top:
```typescript
import { validateApiKey } from '@/lib/auth/api-key';
```

Add API key handling before the session auth check. Insert this after the `isPublicRoute` check and before the Supabase session check:

```typescript
// API Key authentication for /api/* routes (excluding auth routes)
if (pathname.startsWith('/api/') && !pathname.startsWith('/api/auth/')) {
  const authHeader = request.headers.get('authorization');

  // Check for API key (Bearer sk_...)
  if (authHeader?.startsWith('Bearer sk_')) {
    const key = authHeader.substring(7); // Remove 'Bearer '
    const result = await validateApiKey(key);

    if (result.valid) {
      // Pass club context via headers to downstream handlers
      const requestHeaders = new Headers(request.headers);
      requestHeaders.set('x-api-key-club-id', result.clubId!);
      requestHeaders.set('x-api-key-user-id', result.userId!);
      requestHeaders.set('x-auth-type', 'api-key');

      return NextResponse.next({
        request: { headers: requestHeaders },
      });
    }

    // Invalid API key
    return NextResponse.json(
      { error: 'Invalid or expired API key' },
      { status: 401 }
    );
  }
}
```

The middleware flow becomes:
1. Check if public route -> allow
2. Check if API route with sk_ Bearer token -> validate API key
3. Check Supabase session -> normal auth flow
4. No auth -> redirect to login

Note: The API key validation is imported dynamically. If there are issues with edge runtime, we may need to inline the hash logic.
  </action>
  <verify>
TypeScript compilation passes: `npx tsc --noEmit src/middleware.ts`
Middleware still handles session auth correctly for non-API routes.
  </verify>
  <done>Middleware updated to validate API keys for /api/* routes</done>
</task>

</tasks>

<verification>
1. TypeScript compiles all modified files
2. createApiKey generates sk_ prefixed keys with SHA-256 hash storage
3. validateApiKey returns valid:true only for unexpired, unrevoked keys
4. Middleware intercepts sk_ Bearer tokens and validates them
5. Valid API key requests get x-api-key-club-id and x-api-key-user-id headers
6. Invalid API keys return 401 JSON error
</verification>

<success_criteria>
- src/lib/auth/api-key.ts exports createApiKey, validateApiKey, revokeApiKey, listApiKeys
- API keys use sk_ prefix pattern
- Only SHA-256 hash stored in database, raw key returned only at creation
- validateApiKey checks: prefix, hash exists, not revoked, not expired
- Middleware validates API keys for /api/* routes (except /api/auth/*)
- Valid API key requests get context headers for downstream handlers
- Invalid API keys return 401 with JSON error message
</success_criteria>

<output>
After completion, create `.planning/phases/10-security-foundation-rbac/10-06-SUMMARY.md`
</output>
