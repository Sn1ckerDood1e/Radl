---
phase: 10-security-foundation-rbac
plan: 04
type: execute
wave: 2
depends_on: ["10-02"]
files_modified:
  - src/components/permissions/ability-provider.tsx
  - src/components/permissions/can.tsx
  - src/hooks/use-ability.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "AbilityProvider makes CASL ability available to all child components"
    - "Can component conditionally renders based on permissions"
    - "useAbility hook provides ability for custom permission checks"
    - "Ability updates when user context changes (club switch)"
  artifacts:
    - path: "src/components/permissions/ability-provider.tsx"
      provides: "React context provider for CASL ability"
      exports: ["AbilityProvider"]
    - path: "src/components/permissions/can.tsx"
      provides: "Bound Can component for permission checks"
      exports: ["Can"]
    - path: "src/hooks/use-ability.ts"
      provides: "React hook for ability access"
      exports: ["useAbility"]
  key_links:
    - from: "src/components/permissions/ability-provider.tsx"
      to: "src/lib/permissions/ability.ts"
      via: "defineAbilityFor"
      pattern: "defineAbilityFor"
    - from: "src/components/permissions/can.tsx"
      to: "@casl/react"
      via: "createContextualCan"
      pattern: "createContextualCan"
---

<objective>
Create React context and components for client-side permission checking.

Purpose: Components need to conditionally render based on user permissions (e.g., show "Create Practice" button only if user can create practices). The AbilityProvider wraps the app, Can component does conditional rendering, useAbility hook allows custom checks.

Output: React permission system ready for use in dashboard components.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-security-foundation-rbac/10-CONTEXT.md
@.planning/phases/10-security-foundation-rbac/10-RESEARCH.md
@.planning/phases/10-security-foundation-rbac/10-02-SUMMARY.md
@src/lib/permissions/ability.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AbilityProvider context</name>
  <files>src/components/permissions/ability-provider.tsx</files>
  <action>
Create `src/components/permissions/ability-provider.tsx`:

```typescript
'use client';

import { createContext, useMemo, type ReactNode } from 'react';
import { defineAbilityFor, createEmptyAbility, type AppAbility, type UserContext } from '@/lib/permissions/ability';

/**
 * Context for CASL ability instance.
 * Provides ability to all child components via useAbility hook and Can component.
 */
export const AbilityContext = createContext<AppAbility | null>(null);

/**
 * Props for AbilityProvider.
 * User context comes from server (passed from layout or page).
 */
export interface AbilityProviderProps {
  children: ReactNode;
  user: UserContext | null;
}

/**
 * Provides CASL ability to all child components.
 *
 * Usage in layout:
 * ```tsx
 * <AbilityProvider user={{ userId, clubId, roles }}>
 *   {children}
 * </AbilityProvider>
 * ```
 *
 * User context should come from server-side auth.
 * When user is null, an empty ability (no permissions) is created.
 */
export function AbilityProvider({ children, user }: AbilityProviderProps) {
  // Memoize ability to avoid recreating on every render
  const ability = useMemo(() => {
    if (!user) {
      return createEmptyAbility();
    }
    return defineAbilityFor(user);
  }, [user]);

  return (
    <AbilityContext.Provider value={ability}>
      {children}
    </AbilityContext.Provider>
  );
}
```

Create the directory if needed: `src/components/permissions/`
  </action>
  <verify>TypeScript compilation passes: `npx tsc --noEmit src/components/permissions/ability-provider.tsx`</verify>
  <done>AbilityProvider created with memoized ability and null user handling</done>
</task>

<task type="auto">
  <name>Task 2: Create bound Can component</name>
  <files>src/components/permissions/can.tsx</files>
  <action>
Create `src/components/permissions/can.tsx`:

```typescript
'use client';

import { createContextualCan } from '@casl/react';
import { AbilityContext } from './ability-provider';

/**
 * Bound Can component for permission-based rendering.
 *
 * Uses AbilityContext to get the current ability instance.
 * Renders children only if user has the specified permission.
 *
 * Usage:
 * ```tsx
 * // Hide element if no permission
 * <Can I="create" a="Practice">
 *   <Button>Create Practice</Button>
 * </Can>
 *
 * // Render function for more control (e.g., disabled state)
 * <Can I="create" a="Practice" passThrough>
 *   {(allowed) => (
 *     <Button disabled={!allowed}>Create Practice</Button>
 *   )}
 * </Can>
 *
 * // With specific subject instance for field-level checks
 * <Can I="update" this={practice}>
 *   <EditButton />
 * </Can>
 * ```
 */
export const Can = createContextualCan(AbilityContext.Consumer);
```
  </action>
  <verify>TypeScript compilation passes: `npx tsc --noEmit src/components/permissions/can.tsx`</verify>
  <done>Can component created with bound context</done>
</task>

<task type="auto">
  <name>Task 3: Create useAbility hook</name>
  <files>src/hooks/use-ability.ts</files>
  <action>
Create `src/hooks/use-ability.ts`:

```typescript
'use client';

import { useContext } from 'react';
import { AbilityContext } from '@/components/permissions/ability-provider';
import { createEmptyAbility, type AppAbility } from '@/lib/permissions/ability';

/**
 * Hook to access CASL ability instance.
 *
 * Returns empty ability if used outside AbilityProvider (safe default).
 *
 * Usage:
 * ```tsx
 * function PracticeActions() {
 *   const ability = useAbility();
 *
 *   if (ability.can('create', 'Practice')) {
 *     return <CreateButton />;
 *   }
 *
 *   return null;
 * }
 * ```
 *
 * For conditional rendering, prefer Can component for clarity.
 * Use useAbility when you need:
 * - Complex permission logic
 * - Multiple permission checks in one component
 * - Permission-dependent data fetching
 */
export function useAbility(): AppAbility {
  const ability = useContext(AbilityContext);

  // Return empty ability if context not available
  // This prevents crashes when component is outside provider
  if (!ability) {
    return createEmptyAbility();
  }

  return ability;
}
```
  </action>
  <verify>TypeScript compilation passes: `npx tsc --noEmit src/hooks/use-ability.ts`</verify>
  <done>useAbility hook created with safe fallback</done>
</task>

</tasks>

<verification>
1. TypeScript compiles all new files
2. AbilityProvider properly memoizes ability based on user context
3. Can component is properly bound to AbilityContext
4. useAbility returns empty ability when outside provider (no crash)
</verification>

<success_criteria>
- src/components/permissions/ability-provider.tsx exports AbilityProvider and AbilityContext
- src/components/permissions/can.tsx exports Can component
- src/hooks/use-ability.ts exports useAbility hook
- AbilityProvider creates ability from user context, handles null user
- Can component shows/hides children based on permission
- useAbility returns ability or empty ability (safe fallback)
- All components marked 'use client' (required for hooks/context)
</success_criteria>

<output>
After completion, create `.planning/phases/10-security-foundation-rbac/10-04-SUMMARY.md`
</output>
