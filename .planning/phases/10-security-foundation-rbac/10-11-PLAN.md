---
phase: 10-security-foundation-rbac
plan: 11
type: execute
wave: 5
depends_on: ["10-07", "10-08", "10-09", "10-10"]
files_modified:
  - src/app/api/invitations/route.ts
  - src/app/api/members/[id]/roles/route.ts
  - src/app/(dashboard)/[slug]/settings/api-keys/page.tsx
autonomous: false

must_haves:
  truths:
    - "Role changes are audited"
    - "Member removal is audited"
    - "Invitations work with new ClubMembership model"
    - "API key management UI accessible to admins"
  artifacts:
    - path: "src/app/api/members/[id]/roles/route.ts"
      provides: "Role update endpoint with audit logging"
      exports: ["PATCH"]
    - path: "src/app/(dashboard)/[slug]/settings/api-keys/page.tsx"
      provides: "API key management admin page"
  key_links:
    - from: "src/app/api/members/[id]/roles/route.ts"
      to: "src/lib/audit/logger.ts"
      via: "createAuditLogger"
      pattern: "ROLE_CHANGED"
---

<objective>
Wire auditing into existing routes and add API key admin UI, then verify complete phase.

Purpose: Security-critical operations must be audited. This plan instruments role changes and member management with audit logging, adds the API key management UI, and verifies the complete RBAC system works end-to-end.

Output: Complete security foundation ready for production use.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-security-foundation-rbac/10-CONTEXT.md
@.planning/phases/10-security-foundation-rbac/10-RESEARCH.md
@.planning/phases/10-security-foundation-rbac/10-07-SUMMARY.md
@.planning/phases/10-security-foundation-rbac/10-08-SUMMARY.md
@.planning/phases/10-security-foundation-rbac/10-09-SUMMARY.md
@.planning/phases/10-security-foundation-rbac/10-10-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create role update endpoint with audit logging</name>
  <files>src/app/api/members/[id]/roles/route.ts</files>
  <action>
Create `src/app/api/members/[id]/roles/route.ts` for updating member roles:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { prisma } from '@/lib/prisma';
import { getAuthContext } from '@/lib/auth/get-auth-context';
import { createAuditLogger } from '@/lib/audit/logger';
import { unauthorizedResponse, forbiddenResponse, serverErrorResponse } from '@/lib/errors';

const updateRolesSchema = z.object({
  roles: z.array(z.enum(['FACILITY_ADMIN', 'CLUB_ADMIN', 'COACH', 'ATHLETE', 'PARENT'])).min(1),
});

interface RouteParams {
  params: Promise<{ id: string }>;
}

/**
 * PATCH /api/members/[id]/roles
 * Update a member's roles. Audited operation.
 */
export async function PATCH(request: NextRequest, { params }: RouteParams) {
  try {
    const { id: membershipId } = await params;

    const result = await getAuthContext(request);
    if (!result.success) {
      return result.status === 401
        ? unauthorizedResponse()
        : forbiddenResponse(result.error);
    }

    const { context } = result;

    // Check permission
    if (!context.ability.can('assign-role', 'ClubMembership')) {
      return forbiddenResponse('You do not have permission to assign roles');
    }

    const body = await request.json();
    const validationResult = updateRolesSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: validationResult.error.flatten() },
        { status: 400 }
      );
    }

    const { roles } = validationResult.data;

    // Get current membership
    const membership = await prisma.clubMembership.findFirst({
      where: {
        id: membershipId,
        clubId: context.clubId,
      },
    });

    if (!membership) {
      return NextResponse.json(
        { error: 'Member not found' },
        { status: 404 }
      );
    }

    // Prevent self-demotion from admin roles
    if (membership.userId === context.userId) {
      const wasAdmin = membership.roles.some(r =>
        ['FACILITY_ADMIN', 'CLUB_ADMIN'].includes(r)
      );
      const stillAdmin = roles.some(r =>
        ['FACILITY_ADMIN', 'CLUB_ADMIN'].includes(r)
      );

      if (wasAdmin && !stillAdmin) {
        return NextResponse.json(
          { error: 'Cannot remove your own admin role' },
          { status: 400 }
        );
      }
    }

    // Update roles
    const updated = await prisma.clubMembership.update({
      where: { id: membershipId },
      data: { roles },
    });

    // Audit the role change
    const audit = createAuditLogger(request, {
      clubId: context.clubId,
      userId: context.userId,
    });

    await audit.log({
      action: 'ROLE_CHANGED',
      targetType: 'ClubMembership',
      targetId: membershipId,
      metadata: {
        targetUserId: membership.userId,
        oldRoles: membership.roles,
        newRoles: roles,
      },
    });

    return NextResponse.json({ membership: updated });
  } catch (error) {
    return serverErrorResponse(error, 'members/roles:PATCH');
  }
}
```

Create the directory if needed: `src/app/api/members/[id]/roles/`
  </action>
  <verify>TypeScript compilation passes: `npx tsc --noEmit src/app/api/members/[id]/roles/route.ts`</verify>
  <done>Role update endpoint created with audit logging and self-demotion protection</done>
</task>

<task type="auto">
  <name>Task 2: Update invitations to use ClubMembership</name>
  <files>src/app/api/invitations/route.ts</files>
  <action>
Update `src/app/api/invitations/route.ts` to create ClubMembership when invitation is accepted:

The key changes:
1. Add import for createAuditLogger
2. When creating a new member from accepted invitation, create ClubMembership instead of (or in addition to) TeamMember
3. Audit the MEMBER_JOINED event

Find the section where invitation is accepted and a team member is created. Add:

```typescript
// Create ClubMembership for the new member
await prisma.clubMembership.create({
  data: {
    clubId: invitation.teamId,
    userId: userId,
    roles: [invitation.role],  // Start with invited role
    isActive: true,
  },
});

// Audit the join
const audit = createAuditLogger(request, {
  clubId: invitation.teamId,
  userId: userId,  // The joining user
});

await audit.log({
  action: 'MEMBER_JOINED',
  targetType: 'ClubMembership',
  metadata: {
    invitationId: invitation.id,
    invitedBy: invitation.invitedBy,
    role: invitation.role,
  },
});
```

Also update invitation creation to audit MEMBER_INVITED:

```typescript
// After creating invitation
await audit.log({
  action: 'MEMBER_INVITED',
  targetType: 'Invitation',
  targetId: invitation.id,
  metadata: {
    email: email,
    role: role,
  },
});
```

Keep TeamMember creation for backward compatibility during transition period.
  </action>
  <verify>TypeScript compilation passes: `npx tsc --noEmit src/app/api/invitations/route.ts`</verify>
  <done>Invitations route updated to create ClubMembership and audit join events</done>
</task>

<task type="auto">
  <name>Task 3: Create API key management admin page</name>
  <files>src/app/(dashboard)/[slug]/settings/api-keys/page.tsx</files>
  <action>
Create `src/app/(dashboard)/[slug]/settings/api-keys/page.tsx`:

```typescript
import { Suspense } from 'react';
import { requireTeam } from '@/lib/auth/authorize';
import { prisma } from '@/lib/prisma';
import { getCurrentClubId } from '@/lib/auth/club-context';
import { redirect } from 'next/navigation';
import { ApiKeyList } from './api-key-list';

export const metadata = {
  title: 'API Keys - Settings',
};

export default async function ApiKeysPage() {
  const { user, claims } = await requireTeam();

  const clubId = await getCurrentClubId() || claims.team_id;
  if (!clubId) redirect('/');

  // Check user has admin access
  const membership = await prisma.clubMembership.findFirst({
    where: {
      clubId,
      userId: user.id,
      isActive: true,
    },
  });

  const isAdmin = membership?.roles.some(r =>
    ['FACILITY_ADMIN', 'CLUB_ADMIN'].includes(r)
  );

  if (!isAdmin) {
    redirect('/unauthorized');
  }

  // Get existing API keys
  const apiKeys = await prisma.apiKey.findMany({
    where: {
      clubId,
      revokedAt: null,
    },
    select: {
      id: true,
      name: true,
      keyPrefix: true,
      createdBy: true,
      lastUsedAt: true,
      expiresAt: true,
      createdAt: true,
    },
    orderBy: { createdAt: 'desc' },
  });

  return (
    <div className="container mx-auto px-4 py-8 max-w-4xl">
      <div className="mb-8">
        <h1 className="text-2xl font-bold text-[var(--text-primary)]">
          API Keys
        </h1>
        <p className="text-[var(--text-muted)] mt-1">
          Manage API keys for external integrations. Keys provide the same access as the user who created them.
        </p>
      </div>

      <Suspense fallback={<div className="animate-pulse h-48 bg-[var(--surface-2)] rounded-lg" />}>
        <ApiKeyList initialKeys={apiKeys} />
      </Suspense>
    </div>
  );
}
```

Also create `src/app/(dashboard)/[slug]/settings/api-keys/api-key-list.tsx`:

```typescript
'use client';

import { useState } from 'react';

interface ApiKey {
  id: string;
  name: string;
  keyPrefix: string;
  createdBy: string;
  lastUsedAt: string | null;
  expiresAt: string | null;
  createdAt: string;
}

interface ApiKeyListProps {
  initialKeys: ApiKey[];
}

export function ApiKeyList({ initialKeys }: ApiKeyListProps) {
  const [keys, setKeys] = useState(initialKeys);
  const [isCreating, setIsCreating] = useState(false);
  const [newKeyName, setNewKeyName] = useState('');
  const [newKeyValue, setNewKeyValue] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);

  async function handleCreate() {
    if (!newKeyName.trim()) return;

    setIsCreating(true);
    setError(null);

    try {
      const response = await fetch('/api/api-keys', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: newKeyName }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to create API key');
      }

      const data = await response.json();
      setNewKeyValue(data.key);
      setKeys([data, ...keys]);
      setNewKeyName('');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create API key');
    } finally {
      setIsCreating(false);
    }
  }

  async function handleRevoke(id: string) {
    if (!confirm('Are you sure you want to revoke this API key? This cannot be undone.')) {
      return;
    }

    try {
      const response = await fetch(`/api/api-keys/${id}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        throw new Error('Failed to revoke API key');
      }

      setKeys(keys.filter(k => k.id !== id));
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to revoke API key');
    }
  }

  return (
    <div className="space-y-6">
      {/* Create new key */}
      <div className="bg-[var(--surface-2)] rounded-lg p-4">
        <h2 className="font-medium text-[var(--text-primary)] mb-3">
          Create New API Key
        </h2>
        <div className="flex gap-3">
          <input
            type="text"
            value={newKeyName}
            onChange={(e) => setNewKeyName(e.target.value)}
            placeholder="Key name (e.g., Mobile App)"
            className="flex-1 px-3 py-2 bg-[var(--surface-1)] border border-[var(--border)] rounded-lg text-[var(--text-primary)]"
          />
          <button
            onClick={handleCreate}
            disabled={isCreating || !newKeyName.trim()}
            className="px-4 py-2 bg-[var(--accent)] text-white rounded-lg disabled:opacity-50"
          >
            {isCreating ? 'Creating...' : 'Create Key'}
          </button>
        </div>

        {error && (
          <p className="text-red-500 text-sm mt-2">{error}</p>
        )}

        {newKeyValue && (
          <div className="mt-4 p-4 bg-yellow-500/10 border border-yellow-500/30 rounded-lg">
            <p className="text-yellow-400 font-medium mb-2">
              Copy your API key now - it won't be shown again!
            </p>
            <code className="block p-2 bg-[var(--surface-1)] rounded text-sm font-mono break-all">
              {newKeyValue}
            </code>
            <button
              onClick={() => {
                navigator.clipboard.writeText(newKeyValue);
                setNewKeyValue(null);
              }}
              className="mt-2 text-sm text-[var(--accent)]"
            >
              Copy and dismiss
            </button>
          </div>
        )}
      </div>

      {/* Existing keys */}
      <div className="bg-[var(--surface-2)] rounded-lg">
        <h2 className="font-medium text-[var(--text-primary)] p-4 border-b border-[var(--border)]">
          Active API Keys
        </h2>

        {keys.length === 0 ? (
          <p className="p-4 text-[var(--text-muted)]">
            No API keys yet. Create one above.
          </p>
        ) : (
          <ul className="divide-y divide-[var(--border)]">
            {keys.map((key) => (
              <li key={key.id} className="p-4 flex items-center justify-between">
                <div>
                  <div className="font-medium text-[var(--text-primary)]">
                    {key.name}
                  </div>
                  <div className="text-sm text-[var(--text-muted)]">
                    <code>{key.keyPrefix}...</code>
                    {' '}
                    {key.lastUsedAt ? (
                      <>Last used {formatDate(key.lastUsedAt)}</>
                    ) : (
                      <>Never used</>
                    )}
                    {key.expiresAt && (
                      <> | Expires {formatDate(key.expiresAt)}</>
                    )}
                  </div>
                </div>
                <button
                  onClick={() => handleRevoke(key.id)}
                  className="text-red-500 hover:text-red-400 text-sm"
                >
                  Revoke
                </button>
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
}

function formatDate(date: string): string {
  return new Date(date).toLocaleDateString(undefined, {
    month: 'short',
    day: 'numeric',
    year: 'numeric',
  });
}
```

Create the directory if needed: `src/app/(dashboard)/[slug]/settings/api-keys/`
  </action>
  <verify>TypeScript compilation passes for both files</verify>
  <done>API key management page created with create, list, and revoke functionality</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete RBAC and security foundation:
- 5-role hierarchy (FACILITY_ADMIN, CLUB_ADMIN, COACH, ATHLETE, PARENT)
- Multi-club membership with ClubMembership model
- CASL-based permissions (no role inheritance)
- Club context switching with cookie persistence
- Audit logging for security-critical operations
- API key authentication for external integrations
- API key management admin UI
- 365-day audit log retention via cron</what-built>
  <how-to-verify>
1. Start the dev server: `npm run dev`

2. **Test role permissions:**
   - Log in as a coach user
   - Verify you can create practices
   - Check that you cannot access admin settings (API keys)

3. **Test club switcher (if multi-club):**
   - If user has multiple club memberships, verify dropdown appears
   - Switch clubs and verify data refreshes

4. **Test API key management (as admin):**
   - Navigate to /[slug]/settings/api-keys
   - Create a new API key - verify raw key is shown once
   - Copy the key and verify it's not shown again
   - Revoke the key

5. **Test API key auth:**
   ```bash
   curl -H "Authorization: Bearer sk_..." http://localhost:3000/api/practices
   ```
   Should return 401 for invalid key, 200 for valid key

6. **Verify audit logging:**
   - Check database for AuditLog entries after role changes, API key create/revoke
   - As admin, navigate to audit log view (if implemented)
  </how-to-verify>
  <resume-signal>Type "phase 10 verified" to confirm RBAC system works correctly, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. TypeScript compiles all new files
2. Role changes are audited (ROLE_CHANGED action)
3. Member joins are audited (MEMBER_JOINED action)
4. API key management UI works for admins
5. CASL permissions enforce role-based access throughout
6. Club switching refreshes all data correctly
7. API key authentication works for external requests
</verification>

<success_criteria>
Phase 10 success criteria from roadmap:
1. System enforces 5-role hierarchy (FACILITY_ADMIN -> CLUB_ADMIN -> COACH -> ATHLETE -> PARENT) with NO inheritance
2. User can have different roles in different clubs (admin in Club A, athlete in Club B)
3. All sensitive operations (role changes, team deletion, export) are logged with 365-day retention
4. User sessions refresh securely without re-login, expire appropriately on inactivity
5. External integrations can authenticate via API keys with scoped permissions

Additional verification:
- Role update endpoint audits all changes
- Invitation acceptance creates ClubMembership
- API key UI shows prefix, last used, expiration
- API key creation returns raw key exactly once
</success_criteria>

<output>
After completion, create `.planning/phases/10-security-foundation-rbac/10-11-SUMMARY.md`
</output>
