---
phase: 01-security-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/auth/claims.ts
  - src/lib/errors/index.ts
  - src/app/api/equipment/route.ts
  - src/app/api/equipment/[id]/route.ts
  - src/app/api/invitations/route.ts
  - src/app/api/invitations/[id]/route.ts
  - src/app/api/invitations/bulk/route.ts
  - src/app/api/athletes/route.ts
  - src/app/api/athletes/[id]/route.ts
  - src/app/api/team-settings/route.ts
  - src/app/api/notifications/route.ts
autonomous: true

must_haves:
  truths:
    - "All API routes use centralized claims helper instead of inline JWT decoding"
    - "Claims helper uses getUser() for auth verification before getSession() for claims"
    - "Claims helper has database fallback when JWT team_id is null"
    - "CustomJwtPayload interface is defined once and imported everywhere"
  artifacts:
    - path: "src/lib/auth/claims.ts"
      provides: "Centralized claims helper with getClaimsForApiRoute()"
      exports: ["getClaimsForApiRoute", "CustomJwtPayload"]
    - path: "src/lib/errors/index.ts"
      provides: "Error response utilities with reference IDs"
      exports: ["unauthorizedResponse", "forbiddenResponse", "notFoundResponse", "serverErrorResponse"]
  key_links:
    - from: "src/app/api/*/route.ts"
      to: "src/lib/auth/claims.ts"
      via: "import { getClaimsForApiRoute }"
      pattern: "import.*getClaimsForApiRoute.*from.*@/lib/auth/claims"
---

<objective>
Extract duplicated JWT claims logic into a centralized helper and refactor all API routes to use it.

Purpose: Eliminates the security gap where some routes use getSession() without getUser() verification. Creates single source of truth for auth patterns per SEC-01 and DEBT-01.

Output: `src/lib/auth/claims.ts` with getClaimsForApiRoute(), error utilities, and all 10 authenticated API routes refactored.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-foundation/01-RESEARCH.md

# Existing auth patterns to understand
@src/lib/auth/authorize.ts
@src/app/api/equipment/route.ts
@src/app/api/athletes/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create claims helper and error utilities</name>
  <files>
    src/lib/auth/claims.ts
    src/lib/errors/index.ts
  </files>
  <action>
Create `src/lib/auth/claims.ts` with:

1. Export `CustomJwtPayload` interface (single definition):
```typescript
export interface CustomJwtPayload {
  sub: string;
  email: string;
  team_id: string | null;
  user_role: 'COACH' | 'ATHLETE' | 'PARENT' | null;
}
```

2. Export `getClaimsForApiRoute()` async function that:
   - Creates Supabase client
   - Calls `getUser()` FIRST (security: verifies JWT with Supabase)
   - Returns `{ user: null, claims: null, error: 'Unauthorized' }` if getUser fails
   - Calls `getSession()` to get JWT for claims extraction
   - Decodes JWT with jwtDecode
   - If `team_id` is null, queries `prisma.teamMember.findFirst({ where: { userId } })` for database fallback
   - Returns `{ user, claims, error: null }` on success

3. Export helper type `ClaimsResult`:
```typescript
export type ClaimsResult = {
  user: User | null;
  claims: CustomJwtPayload | null;
  error: string | null;
};
```

Create `src/lib/errors/index.ts` with:

1. `generateErrorRef()` - returns 8-char alphanumeric reference ID
2. `unauthorizedResponse()` - returns NextResponse with 401, logs with ref
3. `forbiddenResponse(message?: string)` - returns NextResponse with 403
4. `notFoundResponse(resource?: string)` - returns NextResponse with 404
5. `serverErrorResponse(error: unknown)` - logs error with ref, returns 500 with ref in response

All error responses should include `{ error: string, ref?: string }` shape.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/lib/auth/claims.ts src/lib/errors/index.ts`
  </verify>
  <done>
claims.ts exports getClaimsForApiRoute and CustomJwtPayload. errors/index.ts exports 4 response helpers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor API routes to use claims helper</name>
  <files>
    src/app/api/equipment/route.ts
    src/app/api/equipment/[id]/route.ts
    src/app/api/invitations/route.ts
    src/app/api/invitations/[id]/route.ts
    src/app/api/invitations/bulk/route.ts
    src/app/api/athletes/route.ts
    src/app/api/athletes/[id]/route.ts
    src/app/api/team-settings/route.ts
    src/app/api/notifications/route.ts
  </files>
  <action>
For each API route file:

1. Remove local `CustomJwtPayload` interface definition
2. Remove local `getClaimsWithFallback()` helper if present
3. Remove direct `jwtDecode` import
4. Add imports:
   ```typescript
   import { getClaimsForApiRoute, type CustomJwtPayload } from '@/lib/auth/claims';
   import { unauthorizedResponse, forbiddenResponse, notFoundResponse, serverErrorResponse } from '@/lib/errors';
   ```

5. Replace auth boilerplate in each handler:
   ```typescript
   // BEFORE (varies by file)
   const supabase = await createClient();
   const { data: { user }, error: authError } = await supabase.auth.getUser();
   if (authError || !user) { return NextResponse.json({ error: 'Unauthorized' }, { status: 401 }); }
   const { data: { session } } = await supabase.auth.getSession();
   const claims = jwtDecode<CustomJwtPayload>(session.access_token);
   // ... database fallback logic ...

   // AFTER
   const { user, claims, error } = await getClaimsForApiRoute();
   if (error || !user) return unauthorizedResponse();
   if (!claims?.team_id) return forbiddenResponse('No team associated with user');
   ```

6. Replace error responses:
   - `NextResponse.json({ error: 'Unauthorized' }, { status: 401 })` -> `unauthorizedResponse()`
   - `NextResponse.json({ error: 'Only coaches can...' }, { status: 403 })` -> `forbiddenResponse('Only coaches can...')`
   - `NextResponse.json({ error: 'Not found' }, { status: 404 })` -> `notFoundResponse('Equipment')`
   - catch block `console.error + return 500` -> `serverErrorResponse(error)`

7. Keep the `createClient` import ONLY if used for other Supabase operations (storage, etc). Most routes can remove it.

Files to refactor (10 total):
- equipment/route.ts (GET, POST)
- equipment/[id]/route.ts (GET, PATCH, DELETE)
- invitations/route.ts (GET, POST)
- invitations/[id]/route.ts (DELETE, PATCH)
- invitations/bulk/route.ts (POST)
- athletes/route.ts (GET, POST)
- athletes/[id]/route.ts (GET, PATCH)
- team-settings/route.ts (GET, PATCH)
- notifications/route.ts (GET, PATCH) - Note: this one uses userId, not team_id for queries

For notifications/route.ts specifically: it queries by userId not team_id, so the claims helper still works but the team_id check may not apply.
  </action>
  <verify>
1. `npm run build` passes
2. Grep confirms no local CustomJwtPayload: `grep -r "interface CustomJwtPayload" src/app/api/` returns empty
3. Grep confirms imports: `grep -r "getClaimsForApiRoute" src/app/api/ | wc -l` shows 10+ matches
  </verify>
  <done>
All 10 API route files import from @/lib/auth/claims, no duplicate CustomJwtPayload definitions, build passes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update authorize.ts to use shared types</name>
  <files>
    src/lib/auth/authorize.ts
  </files>
  <action>
Update src/lib/auth/authorize.ts to import CustomJwtPayload from claims.ts instead of defining its own:

1. Remove the local `CustomJwtPayload` interface definition
2. Add import: `import { type CustomJwtPayload } from './claims';`
3. Keep all existing functions (getAuthUser, getUserClaims, requireAuth, requireTeam, requireRole, isCoach, canViewRoster, canViewLineups)
4. The getUserClaims() function can stay as-is since it's used for Server Components (different from API route pattern)

This ensures a single CustomJwtPayload definition across the codebase.
  </action>
  <verify>
1. `npx tsc --noEmit src/lib/auth/authorize.ts`
2. `grep "interface CustomJwtPayload" src/lib/auth/` returns only claims.ts
  </verify>
  <done>
authorize.ts imports CustomJwtPayload from claims.ts, single type definition in codebase.
  </done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build`
2. Type check passes: `npx tsc --noEmit`
3. No duplicate CustomJwtPayload: `grep -rn "interface CustomJwtPayload" src/` shows only claims.ts
4. All API routes use helper: `grep -l "getClaimsForApiRoute" src/app/api/**/*.ts` shows 10 files
5. No direct jwtDecode in API routes: `grep -l "jwtDecode" src/app/api/` returns empty (only in lib/)
</verification>

<success_criteria>
- CustomJwtPayload defined once in src/lib/auth/claims.ts
- getClaimsForApiRoute() uses getUser() before getSession() (security fix)
- Database fallback for team_id is centralized
- All 10 API routes refactored to use the helper
- Error responses use standardized utilities with reference IDs
- Build and type check pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-foundation/01-01-SUMMARY.md`
</output>
