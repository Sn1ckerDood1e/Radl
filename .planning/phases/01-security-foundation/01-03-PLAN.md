---
phase: 01-security-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - prisma/schema.prisma
  - src/app/api/seasons/route.ts
  - src/app/api/seasons/[id]/route.ts
  - src/lib/validations/season.ts
autonomous: true

must_haves:
  truths:
    - "Season model exists with name, optional date range, and status"
    - "AthleteEligibility model tracks per-season eligibility with waiver/swim-test fields"
    - "Coaches can create, list, and archive seasons for their team"
    - "Multiple seasons can be active simultaneously"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Season and AthleteEligibility models"
      contains: "model Season"
    - path: "src/app/api/seasons/route.ts"
      provides: "Season CRUD endpoints (GET list, POST create)"
      exports: ["GET", "POST"]
    - path: "src/app/api/seasons/[id]/route.ts"
      provides: "Single season operations (GET, PATCH, DELETE)"
      exports: ["GET", "PATCH", "DELETE"]
    - path: "src/lib/validations/season.ts"
      provides: "Zod schemas for season validation"
      exports: ["createSeasonSchema", "updateSeasonSchema"]
  key_links:
    - from: "src/app/api/seasons/route.ts"
      to: "prisma.season"
      via: "Prisma client queries"
      pattern: "prisma\\.season\\.(findMany|create)"
    - from: "prisma/schema.prisma Season"
      to: "prisma/schema.prisma Team"
      via: "teamId foreign key"
      pattern: "team.*Team.*@relation"
---

<objective>
Create Season and AthleteEligibility data models per SEASON-01 and SEASON-02, with basic CRUD API.

Purpose: Seasons are containers for practices, regattas, and eligibility tracking. Multiple active seasons support overlapping programs (e.g., "Fall Racing" and "Novice Training"). This is foundational data modeling for scheduling features in Phase 2.

Output: Prisma schema with Season/AthleteEligibility models, season CRUD API, validation schemas.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-security-foundation/01-CONTEXT.md
@.planning/phases/01-security-foundation/01-RESEARCH.md
@.planning/phases/01-security-foundation/01-01-SUMMARY.md

# Existing schema to extend
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Season and AthleteEligibility models to Prisma schema</name>
  <files>
    prisma/schema.prisma
  </files>
  <action>
Add to prisma/schema.prisma after the existing models:

1. Add SeasonStatus enum:
```prisma
// Season status enum
enum SeasonStatus {
  ACTIVE
  ARCHIVED
}
```

2. Add Season model:
```prisma
// Season container for practices, regattas, and eligibility
model Season {
  id        String       @id @default(uuid())
  teamId    String
  name      String       // e.g., "Fall 2026", "Novice Training"
  startDate DateTime?
  endDate   DateTime?
  status    SeasonStatus @default(ACTIVE)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  team               Team                 @relation(fields: [teamId], references: [id], onDelete: Cascade)
  athleteEligibility AthleteEligibility[]

  @@index([teamId])
  @@index([teamId, status])
}
```

3. Add AthleteEligibility model:
```prisma
// Per-season eligibility tracking for athletes
model AthleteEligibility {
  id             String  @id @default(uuid())
  seasonId       String
  athleteId      String  // References AthleteProfile.id

  isEligible     Boolean @default(false)  // Manual override flag
  waiverSigned   Boolean @default(false)
  swimTestPassed Boolean @default(false)
  customFields   Json    @default("{}")   // Team-defined requirements

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  season  Season         @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  athlete AthleteProfile @relation(fields: [athleteId], references: [id], onDelete: Cascade)

  @@unique([seasonId, athleteId])
  @@index([seasonId])
  @@index([athleteId])
}
```

4. Update Team model to add seasons relation:
```prisma
// In the Team model, add:
seasons     Season[]
```

5. Update AthleteProfile model to add eligibility relation:
```prisma
// In the AthleteProfile model, add:
eligibility AthleteEligibility[]
```

After editing, run:
```bash
npx prisma db push
npx prisma generate
```
  </action>
  <verify>
1. `npx prisma validate` passes
2. `npx prisma db push` succeeds
3. `grep "model Season" prisma/schema.prisma` finds the model
4. `grep "model AthleteEligibility" prisma/schema.prisma` finds the model
  </verify>
  <done>
Season and AthleteEligibility models added to schema, database migrated, Prisma client regenerated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create season validation schemas and CRUD API</name>
  <files>
    src/lib/validations/season.ts
    src/app/api/seasons/route.ts
    src/app/api/seasons/[id]/route.ts
  </files>
  <action>
1. Create `src/lib/validations/season.ts`:
```typescript
import { z } from 'zod';

export const createSeasonSchema = z.object({
  name: z.string().min(1, 'Name is required').max(100),
  startDate: z.string().datetime().optional().nullable(),
  endDate: z.string().datetime().optional().nullable(),
}).refine(
  (data) => {
    if (data.startDate && data.endDate) {
      return new Date(data.startDate) <= new Date(data.endDate);
    }
    return true;
  },
  { message: 'End date must be after start date', path: ['endDate'] }
);

export const updateSeasonSchema = z.object({
  name: z.string().min(1).max(100).optional(),
  startDate: z.string().datetime().optional().nullable(),
  endDate: z.string().datetime().optional().nullable(),
  status: z.enum(['ACTIVE', 'ARCHIVED']).optional(),
});
```

2. Create `src/app/api/seasons/route.ts`:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { unauthorizedResponse, forbiddenResponse, serverErrorResponse } from '@/lib/errors';
import { createSeasonSchema } from '@/lib/validations/season';

// GET: List seasons for current team
export async function GET(request: NextRequest) {
  try {
    const { user, claims, error } = await getClaimsForApiRoute();
    if (error || !user) return unauthorizedResponse();
    if (!claims?.team_id) return forbiddenResponse('No team associated with user');

    // Check for status filter
    const { searchParams } = new URL(request.url);
    const statusFilter = searchParams.get('status');

    const where: { teamId: string; status?: 'ACTIVE' | 'ARCHIVED' } = {
      teamId: claims.team_id,
    };

    if (statusFilter === 'active') {
      where.status = 'ACTIVE';
    } else if (statusFilter === 'archived') {
      where.status = 'ARCHIVED';
    }

    const seasons = await prisma.season.findMany({
      where,
      orderBy: [
        { status: 'asc' }, // ACTIVE before ARCHIVED
        { startDate: 'desc' },
        { createdAt: 'desc' },
      ],
    });

    return NextResponse.json({ seasons });
  } catch (error) {
    return serverErrorResponse(error);
  }
}

// POST: Create new season (coach only)
export async function POST(request: NextRequest) {
  try {
    const { user, claims, error } = await getClaimsForApiRoute();
    if (error || !user) return unauthorizedResponse();
    if (!claims?.team_id) return forbiddenResponse('No team associated with user');
    if (claims.user_role !== 'COACH') return forbiddenResponse('Only coaches can create seasons');

    const body = await request.json();
    const validationResult = createSeasonSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: validationResult.error.flatten() },
        { status: 400 }
      );
    }

    const { name, startDate, endDate } = validationResult.data;

    const season = await prisma.season.create({
      data: {
        teamId: claims.team_id,
        name,
        startDate: startDate ? new Date(startDate) : null,
        endDate: endDate ? new Date(endDate) : null,
        status: 'ACTIVE',
      },
    });

    return NextResponse.json({ season }, { status: 201 });
  } catch (error) {
    return serverErrorResponse(error);
  }
}
```

3. Create `src/app/api/seasons/[id]/route.ts`:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { unauthorizedResponse, forbiddenResponse, notFoundResponse, serverErrorResponse } from '@/lib/errors';
import { updateSeasonSchema } from '@/lib/validations/season';

interface RouteParams {
  params: Promise<{ id: string }>;
}

// GET: Get single season with eligibility summary
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params;
    const { user, claims, error } = await getClaimsForApiRoute();
    if (error || !user) return unauthorizedResponse();
    if (!claims?.team_id) return forbiddenResponse('No team associated with user');

    const season = await prisma.season.findFirst({
      where: {
        id,
        teamId: claims.team_id,
      },
      include: {
        _count: {
          select: { athleteEligibility: true },
        },
      },
    });

    if (!season) return notFoundResponse('Season');

    return NextResponse.json({ season });
  } catch (error) {
    return serverErrorResponse(error);
  }
}

// PATCH: Update season (coach only)
export async function PATCH(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params;
    const { user, claims, error } = await getClaimsForApiRoute();
    if (error || !user) return unauthorizedResponse();
    if (!claims?.team_id) return forbiddenResponse('No team associated with user');
    if (claims.user_role !== 'COACH') return forbiddenResponse('Only coaches can update seasons');

    const body = await request.json();
    const validationResult = updateSeasonSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: validationResult.error.flatten() },
        { status: 400 }
      );
    }

    const data = validationResult.data;

    // Build update object
    const updateData: {
      name?: string;
      startDate?: Date | null;
      endDate?: Date | null;
      status?: 'ACTIVE' | 'ARCHIVED';
    } = {};

    if (data.name !== undefined) updateData.name = data.name;
    if (data.startDate !== undefined) updateData.startDate = data.startDate ? new Date(data.startDate) : null;
    if (data.endDate !== undefined) updateData.endDate = data.endDate ? new Date(data.endDate) : null;
    if (data.status !== undefined) updateData.status = data.status;

    const result = await prisma.season.updateMany({
      where: {
        id,
        teamId: claims.team_id,
      },
      data: updateData,
    });

    if (result.count === 0) return notFoundResponse('Season');

    const season = await prisma.season.findUnique({ where: { id } });

    return NextResponse.json({ season });
  } catch (error) {
    return serverErrorResponse(error);
  }
}

// DELETE: Delete season (coach only) - soft delete by archiving
export async function DELETE(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params;
    const { user, claims, error } = await getClaimsForApiRoute();
    if (error || !user) return unauthorizedResponse();
    if (!claims?.team_id) return forbiddenResponse('No team associated with user');
    if (claims.user_role !== 'COACH') return forbiddenResponse('Only coaches can delete seasons');

    // Archive instead of hard delete to preserve historical data
    const result = await prisma.season.updateMany({
      where: {
        id,
        teamId: claims.team_id,
      },
      data: {
        status: 'ARCHIVED',
      },
    });

    if (result.count === 0) return notFoundResponse('Season');

    return NextResponse.json({ success: true });
  } catch (error) {
    return serverErrorResponse(error);
  }
}
```
  </action>
  <verify>
1. `npm run build` passes
2. `ls src/app/api/seasons/route.ts src/app/api/seasons/[id]/route.ts` shows both files
3. `ls src/lib/validations/season.ts` shows validation file
  </verify>
  <done>
Season validation schemas created, seasons CRUD API (list, create, get, update, archive) implemented using centralized claims helper.
  </done>
</task>

</tasks>

<verification>
1. Prisma validates: `npx prisma validate`
2. Build passes: `npm run build`
3. Season model exists: `grep "model Season" prisma/schema.prisma`
4. AthleteEligibility model exists: `grep "model AthleteEligibility" prisma/schema.prisma`
5. Season API routes exist: `ls src/app/api/seasons/`
6. API uses claims helper: `grep "getClaimsForApiRoute" src/app/api/seasons/*.ts`
</verification>

<success_criteria>
- Season model in Prisma with name, optional date range, status (ACTIVE/ARCHIVED)
- AthleteEligibility model with seasonId, athleteId, isEligible, waiverSigned, swimTestPassed, customFields
- Many-to-many through AthleteEligibility (unique constraint on seasonId+athleteId)
- Season CRUD API: GET /api/seasons (list), POST /api/seasons (create), GET /api/seasons/:id, PATCH /api/seasons/:id, DELETE /api/seasons/:id (archives)
- All routes use centralized claims helper from Plan 01
- Coach-only restrictions on create/update/delete
- Database migrated successfully
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-foundation/01-03-SUMMARY.md`
</output>
