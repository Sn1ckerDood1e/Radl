---
phase: 01-security-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-01", "01-03"]
files_modified:
  - src/app/api/seasons/[id]/eligibility/route.ts
  - src/app/api/seasons/[id]/eligibility/[athleteId]/route.ts
  - src/lib/validations/eligibility.ts
autonomous: true

must_haves:
  truths:
    - "Coaches can view all athlete eligibility for a season"
    - "Coaches can set eligibility status for individual athletes"
    - "Athletes can see their own eligibility status and what's missing"
    - "Eligibility includes waiver signed, swim test passed, and custom fields"
  artifacts:
    - path: "src/app/api/seasons/[id]/eligibility/route.ts"
      provides: "List and bulk update eligibility for season"
      exports: ["GET", "POST"]
    - path: "src/app/api/seasons/[id]/eligibility/[athleteId]/route.ts"
      provides: "Individual athlete eligibility operations"
      exports: ["GET", "PATCH"]
    - path: "src/lib/validations/eligibility.ts"
      provides: "Zod schemas for eligibility validation"
      exports: ["updateEligibilitySchema", "bulkEligibilitySchema"]
  key_links:
    - from: "src/app/api/seasons/[id]/eligibility/route.ts"
      to: "prisma.athleteEligibility"
      via: "Prisma client queries"
      pattern: "prisma\\.athleteEligibility\\.(findMany|createMany|upsert)"
---

<objective>
Create eligibility management API per SEASON-02 for coaches to track and athletes to view eligibility status.

Purpose: Eligibility determines which athletes can participate in practices/regattas. Coaches need to track waiver, swim test, and custom requirements. Athletes need visibility into their status and what's missing.

Output: Eligibility API endpoints nested under /api/seasons/:id/eligibility, validation schemas.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-security-foundation/01-CONTEXT.md
@.planning/phases/01-security-foundation/01-01-SUMMARY.md
@.planning/phases/01-security-foundation/01-03-SUMMARY.md

# Season model from Plan 03
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create eligibility validation schemas</name>
  <files>
    src/lib/validations/eligibility.ts
  </files>
  <action>
Create `src/lib/validations/eligibility.ts`:

```typescript
import { z } from 'zod';

// Schema for updating single athlete's eligibility
export const updateEligibilitySchema = z.object({
  isEligible: z.boolean().optional(),
  waiverSigned: z.boolean().optional(),
  swimTestPassed: z.boolean().optional(),
  customFields: z.record(z.string(), z.boolean()).optional(), // { "CPR Certified": true, ... }
});

// Schema for bulk eligibility operations (initialize season)
export const bulkEligibilitySchema = z.object({
  athleteIds: z.array(z.string().uuid()),
  defaults: z.object({
    isEligible: z.boolean().default(false),
    waiverSigned: z.boolean().default(false),
    swimTestPassed: z.boolean().default(false),
    customFields: z.record(z.string(), z.boolean()).default({}),
  }).optional(),
});

// Schema for adding custom field to all eligibility records
export const addCustomFieldSchema = z.object({
  fieldName: z.string().min(1).max(50),
  defaultValue: z.boolean().default(false),
});
```
  </action>
  <verify>
`npx tsc --noEmit src/lib/validations/eligibility.ts`
  </verify>
  <done>
Eligibility validation schemas created for single update, bulk operations, and custom fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create season eligibility list and bulk create endpoint</name>
  <files>
    src/app/api/seasons/[id]/eligibility/route.ts
  </files>
  <action>
Create `src/app/api/seasons/[id]/eligibility/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { unauthorizedResponse, forbiddenResponse, notFoundResponse, serverErrorResponse } from '@/lib/errors';
import { bulkEligibilitySchema } from '@/lib/validations/eligibility';

interface RouteParams {
  params: Promise<{ id: string }>;
}

// GET: List all eligibility records for a season
// Coaches see all, athletes see only their own
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const { id: seasonId } = await params;
    const { user, claims, error } = await getClaimsForApiRoute();
    if (error || !user) return unauthorizedResponse();
    if (!claims?.team_id) return forbiddenResponse('No team associated with user');

    // Verify season belongs to team
    const season = await prisma.season.findFirst({
      where: { id: seasonId, teamId: claims.team_id },
    });
    if (!season) return notFoundResponse('Season');

    const isCoach = claims.user_role === 'COACH';

    if (isCoach) {
      // Coaches see all eligibility with athlete details
      const eligibility = await prisma.athleteEligibility.findMany({
        where: { seasonId },
        include: {
          athlete: {
            select: {
              id: true,
              displayName: true,
              teamMember: {
                select: { userId: true },
              },
            },
          },
        },
        orderBy: { athlete: { displayName: 'asc' } },
      });

      return NextResponse.json({
        season: { id: season.id, name: season.name },
        eligibility: eligibility.map(e => ({
          id: e.id,
          athleteId: e.athleteId,
          athleteName: e.athlete.displayName || 'Unknown',
          isEligible: e.isEligible,
          waiverSigned: e.waiverSigned,
          swimTestPassed: e.swimTestPassed,
          customFields: e.customFields as Record<string, boolean>,
          updatedAt: e.updatedAt.toISOString(),
        })),
      });
    } else {
      // Athletes see only their own eligibility
      // First, find the athlete's profile
      const teamMember = await prisma.teamMember.findFirst({
        where: { userId: user.id, teamId: claims.team_id },
        include: { athleteProfile: true },
      });

      if (!teamMember?.athleteProfile) {
        return NextResponse.json({
          season: { id: season.id, name: season.name },
          eligibility: null,
          message: 'No athlete profile found',
        });
      }

      const eligibility = await prisma.athleteEligibility.findUnique({
        where: {
          seasonId_athleteId: {
            seasonId,
            athleteId: teamMember.athleteProfile.id,
          },
        },
      });

      if (!eligibility) {
        return NextResponse.json({
          season: { id: season.id, name: season.name },
          eligibility: null,
          message: 'No eligibility record for this season',
        });
      }

      // Calculate what's missing for the athlete
      const missing: string[] = [];
      if (!eligibility.waiverSigned) missing.push('Waiver not signed');
      if (!eligibility.swimTestPassed) missing.push('Swim test not passed');
      const customFields = eligibility.customFields as Record<string, boolean>;
      for (const [field, value] of Object.entries(customFields)) {
        if (!value) missing.push(field);
      }

      return NextResponse.json({
        season: { id: season.id, name: season.name },
        eligibility: {
          id: eligibility.id,
          isEligible: eligibility.isEligible,
          waiverSigned: eligibility.waiverSigned,
          swimTestPassed: eligibility.swimTestPassed,
          customFields,
          missing,
        },
      });
    }
  } catch (error) {
    return serverErrorResponse(error);
  }
}

// POST: Bulk create eligibility records for athletes (coach only)
// Used when initializing eligibility for a new season
export async function POST(request: NextRequest, { params }: RouteParams) {
  try {
    const { id: seasonId } = await params;
    const { user, claims, error } = await getClaimsForApiRoute();
    if (error || !user) return unauthorizedResponse();
    if (!claims?.team_id) return forbiddenResponse('No team associated with user');
    if (claims.user_role !== 'COACH') return forbiddenResponse('Only coaches can manage eligibility');

    // Verify season belongs to team
    const season = await prisma.season.findFirst({
      where: { id: seasonId, teamId: claims.team_id },
    });
    if (!season) return notFoundResponse('Season');

    const body = await request.json();
    const validationResult = bulkEligibilitySchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: validationResult.error.flatten() },
        { status: 400 }
      );
    }

    const { athleteIds, defaults } = validationResult.data;

    // Verify all athleteIds are valid AthleteProfile IDs from this team
    const validAthletes = await prisma.athleteProfile.findMany({
      where: {
        id: { in: athleteIds },
        teamMember: { teamId: claims.team_id },
      },
      select: { id: true },
    });

    const validAthleteIds = new Set(validAthletes.map(a => a.id));
    const invalidIds = athleteIds.filter(id => !validAthleteIds.has(id));

    if (invalidIds.length > 0) {
      return NextResponse.json(
        { error: 'Some athlete IDs are invalid', invalidIds },
        { status: 400 }
      );
    }

    // Create eligibility records (skip existing)
    const created = await prisma.$transaction(
      athleteIds.map(athleteId =>
        prisma.athleteEligibility.upsert({
          where: {
            seasonId_athleteId: { seasonId, athleteId },
          },
          create: {
            seasonId,
            athleteId,
            isEligible: defaults?.isEligible ?? false,
            waiverSigned: defaults?.waiverSigned ?? false,
            swimTestPassed: defaults?.swimTestPassed ?? false,
            customFields: defaults?.customFields ?? {},
          },
          update: {}, // Don't update existing records
        })
      )
    );

    return NextResponse.json({
      success: true,
      created: created.length,
    }, { status: 201 });
  } catch (error) {
    return serverErrorResponse(error);
  }
}
```
  </action>
  <verify>
1. `npm run build` passes
2. `ls src/app/api/seasons/[id]/eligibility/route.ts` shows file exists
  </verify>
  <done>
Season eligibility list endpoint created - coaches see all athletes, athletes see their own status with missing items highlighted.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create individual athlete eligibility endpoint</name>
  <files>
    src/app/api/seasons/[id]/eligibility/[athleteId]/route.ts
  </files>
  <action>
Create `src/app/api/seasons/[id]/eligibility/[athleteId]/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { unauthorizedResponse, forbiddenResponse, notFoundResponse, serverErrorResponse } from '@/lib/errors';
import { updateEligibilitySchema } from '@/lib/validations/eligibility';

interface RouteParams {
  params: Promise<{ id: string; athleteId: string }>;
}

// GET: Get single athlete's eligibility for a season
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const { id: seasonId, athleteId } = await params;
    const { user, claims, error } = await getClaimsForApiRoute();
    if (error || !user) return unauthorizedResponse();
    if (!claims?.team_id) return forbiddenResponse('No team associated with user');

    // Verify season belongs to team
    const season = await prisma.season.findFirst({
      where: { id: seasonId, teamId: claims.team_id },
    });
    if (!season) return notFoundResponse('Season');

    // Authorization: coaches can view any, athletes only their own
    const isCoach = claims.user_role === 'COACH';
    if (!isCoach) {
      const teamMember = await prisma.teamMember.findFirst({
        where: { userId: user.id, teamId: claims.team_id },
        include: { athleteProfile: true },
      });

      if (teamMember?.athleteProfile?.id !== athleteId) {
        return forbiddenResponse('You can only view your own eligibility');
      }
    }

    const eligibility = await prisma.athleteEligibility.findUnique({
      where: {
        seasonId_athleteId: { seasonId, athleteId },
      },
      include: {
        athlete: {
          select: { displayName: true },
        },
      },
    });

    if (!eligibility) return notFoundResponse('Eligibility record');

    // Calculate what's missing
    const missing: string[] = [];
    if (!eligibility.waiverSigned) missing.push('Waiver not signed');
    if (!eligibility.swimTestPassed) missing.push('Swim test not passed');
    const customFields = eligibility.customFields as Record<string, boolean>;
    for (const [field, value] of Object.entries(customFields)) {
      if (!value) missing.push(field);
    }

    return NextResponse.json({
      eligibility: {
        id: eligibility.id,
        athleteId: eligibility.athleteId,
        athleteName: eligibility.athlete.displayName,
        isEligible: eligibility.isEligible,
        waiverSigned: eligibility.waiverSigned,
        swimTestPassed: eligibility.swimTestPassed,
        customFields,
        missing,
        updatedAt: eligibility.updatedAt.toISOString(),
      },
    });
  } catch (error) {
    return serverErrorResponse(error);
  }
}

// PATCH: Update athlete's eligibility (coach only)
export async function PATCH(request: NextRequest, { params }: RouteParams) {
  try {
    const { id: seasonId, athleteId } = await params;
    const { user, claims, error } = await getClaimsForApiRoute();
    if (error || !user) return unauthorizedResponse();
    if (!claims?.team_id) return forbiddenResponse('No team associated with user');
    if (claims.user_role !== 'COACH') return forbiddenResponse('Only coaches can update eligibility');

    // Verify season belongs to team
    const season = await prisma.season.findFirst({
      where: { id: seasonId, teamId: claims.team_id },
    });
    if (!season) return notFoundResponse('Season');

    // Verify athlete belongs to team
    const athlete = await prisma.athleteProfile.findFirst({
      where: {
        id: athleteId,
        teamMember: { teamId: claims.team_id },
      },
    });
    if (!athlete) return notFoundResponse('Athlete');

    const body = await request.json();
    const validationResult = updateEligibilitySchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: validationResult.error.flatten() },
        { status: 400 }
      );
    }

    const data = validationResult.data;

    // Get existing eligibility to merge customFields
    const existing = await prisma.athleteEligibility.findUnique({
      where: { seasonId_athleteId: { seasonId, athleteId } },
    });

    // Merge customFields if provided
    let mergedCustomFields = (existing?.customFields ?? {}) as Record<string, boolean>;
    if (data.customFields) {
      mergedCustomFields = { ...mergedCustomFields, ...data.customFields };
    }

    // Upsert eligibility record
    const eligibility = await prisma.athleteEligibility.upsert({
      where: {
        seasonId_athleteId: { seasonId, athleteId },
      },
      create: {
        seasonId,
        athleteId,
        isEligible: data.isEligible ?? false,
        waiverSigned: data.waiverSigned ?? false,
        swimTestPassed: data.swimTestPassed ?? false,
        customFields: data.customFields ?? {},
      },
      update: {
        ...(data.isEligible !== undefined && { isEligible: data.isEligible }),
        ...(data.waiverSigned !== undefined && { waiverSigned: data.waiverSigned }),
        ...(data.swimTestPassed !== undefined && { swimTestPassed: data.swimTestPassed }),
        ...(data.customFields !== undefined && { customFields: mergedCustomFields }),
      },
      include: {
        athlete: { select: { displayName: true } },
      },
    });

    return NextResponse.json({
      eligibility: {
        id: eligibility.id,
        athleteId: eligibility.athleteId,
        athleteName: eligibility.athlete.displayName,
        isEligible: eligibility.isEligible,
        waiverSigned: eligibility.waiverSigned,
        swimTestPassed: eligibility.swimTestPassed,
        customFields: eligibility.customFields as Record<string, boolean>,
        updatedAt: eligibility.updatedAt.toISOString(),
      },
    });
  } catch (error) {
    return serverErrorResponse(error);
  }
}
```
  </action>
  <verify>
1. `npm run build` passes
2. `ls src/app/api/seasons/[id]/eligibility/[athleteId]/route.ts` shows file exists
  </verify>
  <done>
Individual eligibility endpoint created - coaches can update any athlete's eligibility, athletes can view their own.
  </done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build`
2. Eligibility validation exists: `ls src/lib/validations/eligibility.ts`
3. Season eligibility endpoint: `ls src/app/api/seasons/[id]/eligibility/route.ts`
4. Athlete eligibility endpoint: `ls src/app/api/seasons/[id]/eligibility/[athleteId]/route.ts`
5. All routes use claims helper: `grep "getClaimsForApiRoute" src/app/api/seasons/*/eligibility/*.ts`
</verification>

<success_criteria>
- GET /api/seasons/:id/eligibility returns all athletes (coach) or self (athlete)
- POST /api/seasons/:id/eligibility bulk creates eligibility records for athletes
- GET /api/seasons/:id/eligibility/:athleteId returns single athlete's eligibility
- PATCH /api/seasons/:id/eligibility/:athleteId updates eligibility (coach only)
- Athletes see "missing" items (waiver, swim test, custom fields not completed)
- All routes use centralized claims helper
- Coach-only restrictions enforced where appropriate
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-foundation/01-04-SUMMARY.md`
</output>
