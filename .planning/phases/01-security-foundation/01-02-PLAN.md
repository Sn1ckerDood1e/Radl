---
phase: 01-security-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/rate-limit/index.ts
  - src/app/api/equipment/[id]/damage-reports/route.ts
  - src/app/api/join/route.ts
  - .env.example
autonomous: true
user_setup:
  - service: upstash
    why: "Redis-based rate limiting for serverless"
    env_vars:
      - name: UPSTASH_REDIS_REST_URL
        source: "Upstash Console -> Database -> REST API -> UPSTASH_REDIS_REST_URL"
      - name: UPSTASH_REDIS_REST_TOKEN
        source: "Upstash Console -> Database -> REST API -> UPSTASH_REDIS_REST_TOKEN"
    dashboard_config:
      - task: "Create a Redis database"
        location: "https://console.upstash.com/ -> Create Database -> Select region closest to Vercel deployment"

must_haves:
  truths:
    - "Anonymous damage report submissions are rate limited to 10/hour per IP"
    - "Team join attempts are rate limited to 10/hour per IP"
    - "Rate limit exceeded returns 429 with Retry-After header"
    - "Rate limiting only applies when UPSTASH env vars are configured (graceful fallback)"
  artifacts:
    - path: "src/lib/rate-limit/index.ts"
      provides: "Rate limiter factory and check function"
      exports: ["checkRateLimit", "RateLimitResult"]
    - path: ".env.example"
      provides: "Documents required Upstash environment variables"
      contains: "UPSTASH_REDIS_REST_URL"
  key_links:
    - from: "src/app/api/equipment/[id]/damage-reports/route.ts"
      to: "src/lib/rate-limit/index.ts"
      via: "checkRateLimit import and call at start of POST"
      pattern: "checkRateLimit.*identifier"
    - from: "src/app/api/join/route.ts"
      to: "src/lib/rate-limit/index.ts"
      via: "checkRateLimit import and call at start of POST"
      pattern: "checkRateLimit.*identifier"
---

<objective>
Add rate limiting to anonymous/sensitive endpoints to prevent abuse per SEC-02.

Purpose: Damage report and join endpoints can be abused (spam reports, brute-force join codes). Rate limiting with Upstash Redis provides serverless-compatible protection.

Output: Rate limit utility in src/lib/rate-limit/, applied to damage-reports POST and join POST endpoints.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-security-foundation/01-RESEARCH.md
@.planning/phases/01-security-foundation/01-01-SUMMARY.md

# Endpoints to protect
@src/app/api/equipment/[id]/damage-reports/route.ts
@src/app/api/join/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Upstash packages and create rate limit utility</name>
  <files>
    package.json
    src/lib/rate-limit/index.ts
    .env.example
  </files>
  <action>
1. Install packages:
```bash
npm install @upstash/ratelimit @upstash/redis
```

2. Create `src/lib/rate-limit/index.ts`:

```typescript
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

export type RateLimitResult = {
  success: boolean;
  limit: number;
  remaining: number;
  reset: number; // Unix timestamp
};

// Singleton rate limiter - created lazily when env vars available
let rateLimiter: Ratelimit | null = null;

function getRateLimiter(): Ratelimit | null {
  if (rateLimiter) return rateLimiter;

  const url = process.env.UPSTASH_REDIS_REST_URL;
  const token = process.env.UPSTASH_REDIS_REST_TOKEN;

  if (!url || !token) {
    // Graceful fallback: rate limiting disabled if not configured
    console.warn('Rate limiting disabled: UPSTASH_REDIS_REST_URL or UPSTASH_REDIS_REST_TOKEN not set');
    return null;
  }

  rateLimiter = new Ratelimit({
    redis: new Redis({ url, token }),
    limiter: Ratelimit.slidingWindow(10, '1 h'), // 10 requests per hour
    analytics: true,
    prefix: 'radl:ratelimit',
  });

  return rateLimiter;
}

/**
 * Check rate limit for an identifier (typically IP address)
 * Returns success: true if under limit, success: false if exceeded
 *
 * @param identifier - Unique identifier (IP address for anonymous, user ID for authenticated)
 * @param action - Action name for namespacing (e.g., 'damage-report', 'join')
 */
export async function checkRateLimit(
  identifier: string,
  action: string
): Promise<RateLimitResult> {
  const limiter = getRateLimiter();

  // If rate limiting not configured, allow all requests
  if (!limiter) {
    return {
      success: true,
      limit: Infinity,
      remaining: Infinity,
      reset: 0,
    };
  }

  const key = `${action}:${identifier}`;
  const { success, limit, remaining, reset } = await limiter.limit(key);

  return { success, limit, remaining, reset };
}

/**
 * Get client IP from Next.js request
 * Handles X-Forwarded-For header for reverse proxy scenarios
 */
export function getClientIp(request: Request): string {
  // Check X-Forwarded-For header (set by reverse proxies like Vercel)
  const forwardedFor = request.headers.get('x-forwarded-for');
  if (forwardedFor) {
    // Take the first IP (client IP) from the comma-separated list
    return forwardedFor.split(',')[0].trim();
  }

  // Fallback: check X-Real-IP header
  const realIp = request.headers.get('x-real-ip');
  if (realIp) {
    return realIp;
  }

  // Last resort fallback
  return 'unknown';
}
```

3. Update `.env.example` (create if not exists) to document:
```
# Upstash Redis (rate limiting)
UPSTASH_REDIS_REST_URL=
UPSTASH_REDIS_REST_TOKEN=
```
  </action>
  <verify>
1. `npm ls @upstash/ratelimit @upstash/redis` shows packages installed
2. `npx tsc --noEmit src/lib/rate-limit/index.ts` passes
  </verify>
  <done>
@upstash/ratelimit and @upstash/redis installed, rate-limit/index.ts exports checkRateLimit and getClientIp, .env.example documents required vars.
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply rate limiting to damage-reports and join endpoints</name>
  <files>
    src/app/api/equipment/[id]/damage-reports/route.ts
    src/app/api/join/route.ts
  </files>
  <action>
1. Update `src/app/api/equipment/[id]/damage-reports/route.ts`:

At the top of the file, add imports:
```typescript
import { checkRateLimit, getClientIp } from '@/lib/rate-limit';
```

At the START of the POST handler (before any other logic):
```typescript
export async function POST(request: NextRequest, { params }: RouteParams) {
  // Rate limit check FIRST - before any database operations
  const clientIp = getClientIp(request);
  const rateLimit = await checkRateLimit(clientIp, 'damage-report');

  if (!rateLimit.success) {
    return NextResponse.json(
      { error: 'Too many damage reports. Please try again later.' },
      {
        status: 429,
        headers: {
          'Retry-After': String(Math.ceil((rateLimit.reset - Date.now()) / 1000)),
          'X-RateLimit-Limit': String(rateLimit.limit),
          'X-RateLimit-Remaining': String(rateLimit.remaining),
        }
      }
    );
  }

  // ... rest of existing handler
```

2. Update `src/app/api/join/route.ts`:

Add imports at top:
```typescript
import { checkRateLimit, getClientIp } from '@/lib/rate-limit';
```

At the START of the POST handler (after auth check, which is needed):
```typescript
export async function POST(request: NextRequest) {
  // Rate limit check FIRST - before database operations
  const clientIp = getClientIp(request);
  const rateLimit = await checkRateLimit(clientIp, 'join');

  if (!rateLimit.success) {
    return NextResponse.json(
      { error: 'Too many join attempts. Please try again later.' },
      {
        status: 429,
        headers: {
          'Retry-After': String(Math.ceil((rateLimit.reset - Date.now()) / 1000)),
          'X-RateLimit-Limit': String(rateLimit.limit),
          'X-RateLimit-Remaining': String(rateLimit.remaining),
        }
      }
    );
  }

  // ... rest of existing handler (auth check, etc.)
```

Note: For join/route.ts, keep the rate limit check BEFORE the auth check. This prevents brute-force attacks even if attacker doesn't have valid auth.
  </action>
  <verify>
1. `npm run build` passes
2. `grep -l "checkRateLimit" src/app/api/` shows both files
3. `grep "status: 429" src/app/api/equipment/[id]/damage-reports/route.ts` finds the rate limit response
4. `grep "status: 429" src/app/api/join/route.ts` finds the rate limit response
  </verify>
  <done>
Both damage-reports and join endpoints have rate limiting at 10/hour per IP, return 429 with Retry-After header when exceeded.
  </done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build`
2. Rate limit utility exists: `ls src/lib/rate-limit/index.ts`
3. Both endpoints protected: `grep -l "checkRateLimit" src/app/api/**/*.ts` shows 2 files
4. 429 responses configured: `grep -rn "status: 429" src/app/api/` shows both endpoints
5. Retry-After header included: `grep -rn "Retry-After" src/app/api/` shows both endpoints
</verification>

<success_criteria>
- @upstash/ratelimit and @upstash/redis packages installed
- Rate limit utility in src/lib/rate-limit/index.ts
- Graceful fallback when env vars not configured (rate limiting disabled, not broken)
- damage-reports POST rate limited at 10/hour per IP
- join POST rate limited at 10/hour per IP
- 429 responses include Retry-After and X-RateLimit-* headers
- .env.example documents required environment variables
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-foundation/01-02-SUMMARY.md`
</output>
