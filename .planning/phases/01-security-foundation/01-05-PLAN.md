---
phase: 01-security-foundation
plan: 05
type: execute
wave: 3
depends_on: ["01-01", "01-02", "01-03"]
files_modified:
  - src/app/error.tsx
  - src/app/global-error.tsx
autonomous: false

must_haves:
  truths:
    - "Route segment errors show friendly error page with reference ID"
    - "Global errors (layout crashes) show recovery page"
    - "Coach cannot access another team's data even with manipulated requests"
    - "Unauthenticated damage reports are rate limited"
  artifacts:
    - path: "src/app/error.tsx"
      provides: "Route segment error boundary"
      min_lines: 20
    - path: "src/app/global-error.tsx"
      provides: "Global error boundary for layout crashes"
      min_lines: 20
  key_links:
    - from: "src/app/error.tsx"
      to: "User-visible error page"
      via: "Next.js error boundary convention"
      pattern: "'use client'"
---

<objective>
Add error boundaries and verify all Phase 1 security requirements through manual testing.

Purpose: Complete the security foundation with proper error handling and verify SEC-01, SEC-02, SEC-03 success criteria through human testing.

Output: Error boundary components, verification that all phase requirements are met.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-security-foundation/01-CONTEXT.md
@.planning/phases/01-security-foundation/01-01-SUMMARY.md
@.planning/phases/01-security-foundation/01-02-SUMMARY.md
@.planning/phases/01-security-foundation/01-03-SUMMARY.md
@.planning/phases/01-security-foundation/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error boundary components</name>
  <files>
    src/app/error.tsx
    src/app/global-error.tsx
  </files>
  <action>
1. Create `src/app/error.tsx` (route segment error boundary):

```tsx
'use client';

import { useEffect } from 'react';

interface ErrorProps {
  error: Error & { digest?: string };
  reset: () => void;
}

export default function Error({ error, reset }: ErrorProps) {
  useEffect(() => {
    // Log the error to console (could send to error tracking service)
    console.error('Route error:', error);
  }, [error]);

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 px-4">
      <div className="max-w-md w-full text-center">
        <div className="mb-8">
          <h1 className="text-6xl font-bold text-gray-900 mb-4">Oops!</h1>
          <h2 className="text-xl text-gray-600 mb-2">Something went wrong</h2>
          <p className="text-gray-500">
            We encountered an unexpected error. Please try again.
          </p>
        </div>

        {error.digest && (
          <p className="text-sm text-gray-400 mb-6">
            Error Reference: <code className="bg-gray-100 px-2 py-1 rounded">{error.digest}</code>
          </p>
        )}

        <div className="space-y-4">
          <button
            onClick={reset}
            className="w-full px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
          >
            Try Again
          </button>
          <a
            href="/"
            className="block w-full px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 transition-colors"
          >
            Go Home
          </a>
        </div>
      </div>
    </div>
  );
}
```

2. Create `src/app/global-error.tsx` (global error boundary for layout crashes):

```tsx
'use client';

interface GlobalErrorProps {
  error: Error & { digest?: string };
  reset: () => void;
}

export default function GlobalError({ error, reset }: GlobalErrorProps) {
  return (
    <html>
      <body>
        <div style={{
          minHeight: '100vh',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          backgroundColor: '#f9fafb',
          padding: '1rem',
        }}>
          <div style={{
            maxWidth: '28rem',
            width: '100%',
            textAlign: 'center',
          }}>
            <h1 style={{
              fontSize: '3.75rem',
              fontWeight: 'bold',
              color: '#111827',
              marginBottom: '1rem',
            }}>
              Error
            </h1>
            <h2 style={{
              fontSize: '1.25rem',
              color: '#4b5563',
              marginBottom: '0.5rem',
            }}>
              Application Error
            </h2>
            <p style={{
              color: '#6b7280',
              marginBottom: '1.5rem',
            }}>
              A critical error occurred. Please refresh the page.
            </p>

            {error.digest && (
              <p style={{
                fontSize: '0.875rem',
                color: '#9ca3af',
                marginBottom: '1.5rem',
              }}>
                Error Reference: <code style={{
                  backgroundColor: '#f3f4f6',
                  padding: '0.25rem 0.5rem',
                  borderRadius: '0.25rem',
                }}>{error.digest}</code>
              </p>
            )}

            <button
              onClick={reset}
              style={{
                width: '100%',
                padding: '0.5rem 1rem',
                backgroundColor: '#2563eb',
                color: 'white',
                borderRadius: '0.5rem',
                border: 'none',
                cursor: 'pointer',
                fontSize: '1rem',
              }}
            >
              Try Again
            </button>
          </div>
        </div>
      </body>
    </html>
  );
}
```

Note: GlobalError uses inline styles because it replaces the entire layout including any CSS imports.
  </action>
  <verify>
1. `npm run build` passes
2. `ls src/app/error.tsx src/app/global-error.tsx` shows both files
  </verify>
  <done>
Error boundary components created with user-friendly messages and error reference IDs for support.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 1 security foundation:
1. Centralized claims helper (SEC-01, DEBT-01)
2. Rate limiting on damage reports and join endpoints (SEC-02)
3. Season model with eligibility tracking (SEASON-01, SEASON-02)
4. Error boundaries with reference IDs
  </what-built>
  <how-to-verify>
**SEC-01: JWT claims verification**
1. Start the dev server: `npm run dev`
2. Log in as a coach
3. Open browser dev tools -> Network tab
4. Make any API request (view equipment, etc.)
5. Verify the request succeeds (claims helper working)

**SEC-02: Rate limiting** (requires Upstash configured)
1. If Upstash not configured, verify graceful fallback:
   - Check server logs show: "Rate limiting disabled: UPSTASH_REDIS_REST_URL..."
   - Damage report still works (not blocked)
2. If Upstash configured:
   - Submit a damage report via QR code flow
   - Submit 10+ damage reports rapidly
   - Verify 429 response with "Too many damage reports" message

**SEC-03: Multi-tenant isolation**
1. Log in as Coach A (Team A)
2. Note an equipment ID from Team A
3. Log out, log in as Coach B (Team B)
4. Try to access Team A's equipment via direct URL: `/api/equipment/{teamA-equipment-id}`
5. Verify 404 response (not 200 with data, not 403)

**SEASON-01: Season model**
1. As coach, create a season: POST /api/seasons with `{ "name": "Fall 2026" }`
2. Verify season created: GET /api/seasons shows the new season
3. Verify multiple active seasons allowed: create "Novice Training" season

**SEASON-02: Eligibility tracking**
1. As coach, initialize eligibility: POST /api/seasons/{id}/eligibility with athlete IDs
2. Update an athlete's eligibility: PATCH /api/seasons/{id}/eligibility/{athleteId}
3. As athlete, view own eligibility: GET /api/seasons/{id}/eligibility
4. Verify athlete sees "missing" items list

**Error boundaries**
1. Trigger an error by visiting a broken page or API
2. Verify friendly error page appears (not white screen)
3. Verify error reference ID is displayed
  </how-to-verify>
  <resume-signal>Type "approved" if all verification passes, or describe specific issues found</resume-signal>
</task>

</tasks>

<verification>
1. Error boundaries exist: `ls src/app/error.tsx src/app/global-error.tsx`
2. Build passes: `npm run build`
3. All Phase 1 requirements verified through human testing
</verification>

<success_criteria>
**Phase 1 Success Criteria (from ROADMAP.md):**

1. [x] Coach cannot access another team's data even with manipulated JWT claims
   - Verified through SEC-03 cross-team access test
   - Claims helper uses database verification
   - All queries include teamId filter

2. [x] Unauthenticated users are rate-limited on damage report and join endpoints
   - Rate limiting applied to POST /api/equipment/{id}/damage-reports
   - Rate limiting applied to POST /api/join
   - 10 attempts per IP per hour
   - 429 response with Retry-After header

3. [x] Coach can create a season and see practices grouped by season
   - Season CRUD API implemented
   - Note: Practice grouping is Phase 2 feature, Season container is ready

4. [x] Coach can mark athletes as eligible/ineligible for a specific season
   - AthleteEligibility model with isEligible, waiverSigned, swimTestPassed, customFields
   - Eligibility API with coach-only write, athlete self-read

5. [x] JWT claims are validated through a single reusable utility across all API routes
   - getClaimsForApiRoute() in src/lib/auth/claims.ts
   - All 10+ API routes refactored to use it
   - CustomJwtPayload defined once
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-foundation/01-05-SUMMARY.md`
</output>
