---
phase: 17-facility-ui-features
plan: 05
type: execute
wave: 3
depends_on: [17-01, 17-04]
files_modified:
  - src/lib/equipment/booking.ts
  - src/app/api/equipment/bookings/route.ts
  - src/app/api/equipment/bookings/[bookingId]/route.ts
autonomous: true

must_haves:
  truths:
    - "Clubs can request to book shared equipment for a time range"
    - "System detects and prevents conflicting bookings"
    - "Equipment owners are notified of booking requests"
    - "Booking requests can be approved or denied"
  artifacts:
    - path: "src/lib/equipment/booking.ts"
      provides: "Booking helper functions (checkAvailability, createBooking)"
      exports: ["checkEquipmentAvailability", "createEquipmentBooking", "getEquipmentBookings"]
    - path: "src/app/api/equipment/bookings/route.ts"
      provides: "API for listing and creating bookings"
      exports: ["GET", "POST"]
    - path: "src/app/api/equipment/bookings/[bookingId]/route.ts"
      provides: "API for approving/denying bookings"
      exports: ["PATCH", "DELETE"]
  key_links:
    - from: "src/lib/equipment/booking.ts"
      to: "prisma.equipmentBooking"
      via: "database operations"
      pattern: "prisma\\.equipmentBooking"
---

<objective>
Create equipment booking helper functions and API endpoints for the reservation system.

Purpose: Clubs need to request bookings for shared equipment, and the system must prevent double-bookings and notify equipment owners (FAC-07).

Output: Booking helper library with availability checking and conflict detection, plus API endpoints for CRUD operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/17-facility-ui-features/17-CONTEXT.md
@.planning/phases/17-facility-ui-features/17-01-SUMMARY.md
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create booking helper functions</name>
  <files>src/lib/equipment/booking.ts</files>
  <action>
Create `src/lib/equipment/booking.ts` with booking utility functions:

```typescript
import { prisma } from '@/lib/prisma';
import { BookingStatus } from '@/generated/prisma';

export interface BookingConflict {
  bookingId: string;
  clubName: string;
  startTime: Date;
  endTime: Date;
  status: BookingStatus;
}

/**
 * Check if equipment is available for a given time range.
 * Returns conflicts if any exist.
 */
export async function checkEquipmentAvailability(
  equipmentId: string,
  startTime: Date,
  endTime: Date,
  excludeBookingId?: string
): Promise<{ available: boolean; conflicts: BookingConflict[] }> {
  // Find overlapping bookings that are PENDING or APPROVED
  const overlapping = await prisma.equipmentBooking.findMany({
    where: {
      equipmentId,
      id: excludeBookingId ? { not: excludeBookingId } : undefined,
      status: { in: ['PENDING', 'APPROVED'] },
      // Overlap condition: starts before our end AND ends after our start
      AND: [
        { startTime: { lt: endTime } },
        { endTime: { gt: startTime } },
      ],
    },
    include: {
      club: { select: { name: true } },
    },
    orderBy: { startTime: 'asc' },
  });

  const conflicts: BookingConflict[] = overlapping.map((booking) => ({
    bookingId: booking.id,
    clubName: booking.club.name,
    startTime: booking.startTime,
    endTime: booking.endTime,
    status: booking.status,
  }));

  return {
    available: conflicts.length === 0,
    conflicts,
  };
}

/**
 * Create a booking request for shared equipment.
 * Validates availability and sends notification to equipment owner.
 */
export async function createEquipmentBooking(params: {
  equipmentId: string;
  clubId: string;
  practiceId?: string;
  startTime: Date;
  endTime: Date;
  requestedBy: string;
  notes?: string;
}): Promise<{ success: boolean; bookingId?: string; error?: string; conflicts?: BookingConflict[] }> {
  const { equipmentId, clubId, practiceId, startTime, endTime, requestedBy, notes } = params;

  // Validate time range
  if (startTime >= endTime) {
    return { success: false, error: 'End time must be after start time' };
  }

  // Check equipment exists and is bookable (facility-owned or shared)
  const equipment = await prisma.equipment.findUnique({
    where: { id: equipmentId },
    include: {
      facility: { select: { id: true, name: true, bookingWindowDays: true } },
    },
  });

  if (!equipment) {
    return { success: false, error: 'Equipment not found' };
  }

  if (equipment.ownerType !== 'FACILITY' && !equipment.isShared) {
    return { success: false, error: 'Equipment is not available for booking' };
  }

  // Check booking window
  const bookingWindowDays = equipment.facility?.bookingWindowDays ?? 30;
  const maxBookingDate = new Date();
  maxBookingDate.setDate(maxBookingDate.getDate() + bookingWindowDays);

  if (startTime > maxBookingDate) {
    return {
      success: false,
      error: `Cannot book more than ${bookingWindowDays} days in advance`
    };
  }

  // Check availability
  const { available, conflicts } = await checkEquipmentAvailability(equipmentId, startTime, endTime);

  if (!available) {
    return { success: false, error: 'Equipment not available for selected time', conflicts };
  }

  // Create booking in transaction with notification
  const result = await prisma.$transaction(async (tx) => {
    // Create booking
    const booking = await tx.equipmentBooking.create({
      data: {
        equipmentId,
        clubId,
        practiceId,
        startTime,
        endTime,
        requestedBy,
        notes,
        status: 'PENDING',
      },
    });

    // If facility-owned, get facility admins to notify
    if (equipment.facilityId) {
      const facilityAdmins = await tx.facilityMembership.findMany({
        where: {
          facilityId: equipment.facilityId,
          isActive: true,
          roles: { has: 'FACILITY_ADMIN' },
        },
        select: { userId: true },
      });

      // Get requesting club name
      const club = await tx.team.findUnique({
        where: { id: clubId },
        select: { name: true },
      });

      // Create notifications for all facility admins
      for (const admin of facilityAdmins) {
        await tx.notification.create({
          data: {
            teamId: clubId, // Use requesting club as teamId for scoping
            userId: admin.userId,
            type: 'EQUIPMENT_REQUEST',
            title: 'Equipment Booking Request',
            message: `${club?.name || 'A club'} requested to book ${equipment.name}`,
            linkUrl: `/facility/${equipment.facility?.id}/equipment/requests`,
          },
        });
      }
    }

    return booking;
  });

  return { success: true, bookingId: result.id };
}

/**
 * Get bookings for a piece of equipment or a club.
 */
export async function getEquipmentBookings(params: {
  equipmentId?: string;
  clubId?: string;
  facilityId?: string;
  status?: BookingStatus | BookingStatus[];
  fromDate?: Date;
  toDate?: Date;
}) {
  const { equipmentId, clubId, facilityId, status, fromDate, toDate } = params;

  return prisma.equipmentBooking.findMany({
    where: {
      equipmentId,
      clubId,
      equipment: facilityId ? { facilityId } : undefined,
      status: status
        ? Array.isArray(status)
          ? { in: status }
          : status
        : undefined,
      startTime: fromDate ? { gte: fromDate } : undefined,
      endTime: toDate ? { lte: toDate } : undefined,
    },
    include: {
      equipment: { select: { id: true, name: true, type: true, boatClass: true } },
      club: { select: { id: true, name: true, slug: true } },
      practice: { select: { id: true, name: true, date: true } },
    },
    orderBy: { startTime: 'asc' },
  });
}

/**
 * Approve a booking request.
 */
export async function approveBooking(
  bookingId: string,
  approvedBy: string
): Promise<{ success: boolean; error?: string }> {
  const booking = await prisma.equipmentBooking.findUnique({
    where: { id: bookingId },
  });

  if (!booking) {
    return { success: false, error: 'Booking not found' };
  }

  if (booking.status !== 'PENDING') {
    return { success: false, error: 'Booking is not pending' };
  }

  // Re-check availability (another booking may have been approved in the meantime)
  const { available, conflicts } = await checkEquipmentAvailability(
    booking.equipmentId,
    booking.startTime,
    booking.endTime,
    bookingId
  );

  if (!available) {
    return { success: false, error: 'Time slot is no longer available' };
  }

  await prisma.equipmentBooking.update({
    where: { id: bookingId },
    data: {
      status: 'APPROVED',
      approvedBy,
    },
  });

  return { success: true };
}

/**
 * Deny a booking request.
 */
export async function denyBooking(
  bookingId: string,
  deniedBy: string,
  reason?: string
): Promise<{ success: boolean; error?: string }> {
  const booking = await prisma.equipmentBooking.findUnique({
    where: { id: bookingId },
  });

  if (!booking) {
    return { success: false, error: 'Booking not found' };
  }

  if (booking.status !== 'PENDING') {
    return { success: false, error: 'Booking is not pending' };
  }

  await prisma.equipmentBooking.update({
    where: { id: bookingId },
    data: {
      status: 'DENIED',
      deniedReason: reason,
    },
  });

  return { success: true };
}

/**
 * Cancel a booking (by the requesting club).
 */
export async function cancelBooking(
  bookingId: string,
  cancelledBy: string
): Promise<{ success: boolean; error?: string }> {
  const booking = await prisma.equipmentBooking.findUnique({
    where: { id: bookingId },
  });

  if (!booking) {
    return { success: false, error: 'Booking not found' };
  }

  if (booking.status === 'CANCELLED' || booking.status === 'DENIED') {
    return { success: false, error: 'Booking is already cancelled or denied' };
  }

  await prisma.equipmentBooking.update({
    where: { id: bookingId },
    data: { status: 'CANCELLED' },
  });

  return { success: true };
}
```
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors</verify>
  <done>Booking helper library provides checkAvailability, createBooking, approveBooking, denyBooking functions</done>
</task>

<task type="auto">
  <name>Task 2: Create bookings list and create API</name>
  <files>src/app/api/equipment/bookings/route.ts</files>
  <action>
Create `src/app/api/equipment/bookings/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { prisma } from '@/lib/prisma';
import {
  getEquipmentBookings,
  createEquipmentBooking,
  checkEquipmentAvailability
} from '@/lib/equipment/booking';

const createBookingSchema = z.object({
  equipmentId: z.string().uuid(),
  practiceId: z.string().uuid().optional(),
  startTime: z.string().datetime(),
  endTime: z.string().datetime(),
  notes: z.string().max(500).optional(),
});

// GET /api/equipment/bookings - List bookings for current club/facility
export async function GET(request: NextRequest) {
  const { user, clubId, facilityId, viewMode, error } = await getClaimsForApiRoute();

  if (error || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const equipmentId = searchParams.get('equipmentId') || undefined;
  const statusParam = searchParams.get('status');
  const status = statusParam ? statusParam.split(',') as ('PENDING' | 'APPROVED' | 'DENIED' | 'CANCELLED')[] : undefined;

  // If in facility view, show all facility bookings
  // If in club view, show club's bookings
  const bookings = await getEquipmentBookings({
    equipmentId,
    clubId: viewMode === 'club' ? clubId ?? undefined : undefined,
    facilityId: viewMode === 'facility' ? facilityId ?? undefined : undefined,
    status,
  });

  return NextResponse.json({ bookings });
}

// POST /api/equipment/bookings - Create a booking request
export async function POST(request: NextRequest) {
  const { user, clubId, error } = await getClaimsForApiRoute();

  if (error || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  if (!clubId) {
    return NextResponse.json({ error: 'No club context' }, { status: 400 });
  }

  // Verify user can book on behalf of club (needs at least COACH role)
  const membership = await prisma.clubMembership.findFirst({
    where: {
      clubId,
      userId: user.id,
      isActive: true,
      roles: { hasSome: ['CLUB_ADMIN', 'COACH'] },
    },
  });

  // Fallback to TeamMember
  const teamMember = membership ? null : await prisma.teamMember.findFirst({
    where: {
      teamId: clubId,
      userId: user.id,
      role: { in: ['CLUB_ADMIN', 'COACH'] },
    },
  });

  if (!membership && !teamMember) {
    return NextResponse.json({ error: 'Only coaches can book equipment' }, { status: 403 });
  }

  const body = await request.json();
  const validation = createBookingSchema.safeParse(body);

  if (!validation.success) {
    return NextResponse.json(
      { error: 'Validation failed', details: validation.error.flatten() },
      { status: 400 }
    );
  }

  const { equipmentId, practiceId, startTime, endTime, notes } = validation.data;

  const result = await createEquipmentBooking({
    equipmentId,
    clubId,
    practiceId,
    startTime: new Date(startTime),
    endTime: new Date(endTime),
    requestedBy: user.id,
    notes,
  });

  if (!result.success) {
    return NextResponse.json(
      { error: result.error, conflicts: result.conflicts },
      { status: 409 }
    );
  }

  return NextResponse.json({ bookingId: result.bookingId }, { status: 201 });
}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>API endpoint handles listing bookings and creating new booking requests with conflict detection</done>
</task>

<task type="auto">
  <name>Task 3: Create booking management API (approve/deny/cancel)</name>
  <files>src/app/api/equipment/bookings/[bookingId]/route.ts</files>
  <action>
Create `src/app/api/equipment/bookings/[bookingId]/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { prisma } from '@/lib/prisma';
import { approveBooking, denyBooking, cancelBooking } from '@/lib/equipment/booking';

const updateBookingSchema = z.object({
  action: z.enum(['approve', 'deny', 'cancel']),
  reason: z.string().max(500).optional(),
});

interface RouteContext {
  params: Promise<{ bookingId: string }>;
}

// GET /api/equipment/bookings/[bookingId] - Get single booking details
export async function GET(request: NextRequest, context: RouteContext) {
  const { bookingId } = await context.params;

  const { user, error } = await getClaimsForApiRoute();

  if (error || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const booking = await prisma.equipmentBooking.findUnique({
    where: { id: bookingId },
    include: {
      equipment: {
        select: {
          id: true,
          name: true,
          type: true,
          boatClass: true,
          facilityId: true,
        }
      },
      club: { select: { id: true, name: true, slug: true } },
      practice: { select: { id: true, name: true, date: true } },
    },
  });

  if (!booking) {
    return NextResponse.json({ error: 'Booking not found' }, { status: 404 });
  }

  return NextResponse.json({ booking });
}

// PATCH /api/equipment/bookings/[bookingId] - Approve/deny/cancel booking
export async function PATCH(request: NextRequest, context: RouteContext) {
  const { bookingId } = await context.params;

  const { user, clubId, facilityId, viewMode, error } = await getClaimsForApiRoute();

  if (error || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Get booking to check permissions
  const booking = await prisma.equipmentBooking.findUnique({
    where: { id: bookingId },
    include: {
      equipment: { select: { facilityId: true } },
      club: { select: { id: true } },
    },
  });

  if (!booking) {
    return NextResponse.json({ error: 'Booking not found' }, { status: 404 });
  }

  const body = await request.json();
  const validation = updateBookingSchema.safeParse(body);

  if (!validation.success) {
    return NextResponse.json(
      { error: 'Validation failed', details: validation.error.flatten() },
      { status: 400 }
    );
  }

  const { action, reason } = validation.data;

  // Permission checks based on action
  if (action === 'cancel') {
    // Only the requesting club can cancel
    if (booking.clubId !== clubId) {
      return NextResponse.json({ error: 'Can only cancel your own bookings' }, { status: 403 });
    }

    const result = await cancelBooking(bookingId, user.id);
    if (!result.success) {
      return NextResponse.json({ error: result.error }, { status: 400 });
    }
  } else {
    // Approve/deny requires FACILITY_ADMIN
    if (viewMode !== 'facility' || !booking.equipment.facilityId) {
      return NextResponse.json({ error: 'Only facility admins can approve/deny' }, { status: 403 });
    }

    const facilityMembership = await prisma.facilityMembership.findFirst({
      where: {
        facilityId: booking.equipment.facilityId,
        userId: user.id,
        isActive: true,
        roles: { has: 'FACILITY_ADMIN' },
      },
    });

    if (!facilityMembership) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }

    if (action === 'approve') {
      const result = await approveBooking(bookingId, user.id);
      if (!result.success) {
        return NextResponse.json({ error: result.error }, { status: 400 });
      }
    } else {
      const result = await denyBooking(bookingId, user.id, reason);
      if (!result.success) {
        return NextResponse.json({ error: result.error }, { status: 400 });
      }
    }
  }

  // Return updated booking
  const updatedBooking = await prisma.equipmentBooking.findUnique({
    where: { id: bookingId },
    include: {
      equipment: { select: { id: true, name: true, type: true } },
      club: { select: { id: true, name: true } },
    },
  });

  return NextResponse.json({ booking: updatedBooking });
}

// DELETE /api/equipment/bookings/[bookingId] - Delete booking (facility admin only)
export async function DELETE(request: NextRequest, context: RouteContext) {
  const { bookingId } = await context.params;

  const { user, facilityId, viewMode, error } = await getClaimsForApiRoute();

  if (error || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const booking = await prisma.equipmentBooking.findUnique({
    where: { id: bookingId },
    include: {
      equipment: { select: { facilityId: true } },
    },
  });

  if (!booking) {
    return NextResponse.json({ error: 'Booking not found' }, { status: 404 });
  }

  // Only facility admin can delete
  if (!booking.equipment.facilityId) {
    return NextResponse.json({ error: 'Cannot delete non-facility booking' }, { status: 403 });
  }

  const facilityMembership = await prisma.facilityMembership.findFirst({
    where: {
      facilityId: booking.equipment.facilityId,
      userId: user.id,
      isActive: true,
      roles: { has: 'FACILITY_ADMIN' },
    },
  });

  if (!facilityMembership) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  await prisma.equipmentBooking.delete({
    where: { id: bookingId },
  });

  return NextResponse.json({ success: true });
}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>API endpoint handles approve/deny/cancel actions with proper permission checks</done>
</task>

</tasks>

<verification>
1. Build: `npm run build` passes
2. Library exports: All functions exported from booking.ts
3. Availability check: checkEquipmentAvailability detects overlapping bookings
4. Create booking: POST creates booking and returns conflict errors
5. Approve/deny: PATCH with action updates booking status
6. Cancel: PATCH with cancel action works for requesting club
7. Permission checks: Non-facility-admin cannot approve/deny
</verification>

<success_criteria>
- checkEquipmentAvailability detects overlapping PENDING/APPROVED bookings
- createEquipmentBooking validates time range, booking window, and availability
- Booking creation sends notification to facility admins
- approveBooking re-checks availability before approving
- denyBooking records reason
- cancelBooking allows requesting club to cancel
- All API endpoints validate permissions appropriately
</success_criteria>

<output>
After completion, create `.planning/phases/17-facility-ui-features/17-05-SUMMARY.md`
</output>
