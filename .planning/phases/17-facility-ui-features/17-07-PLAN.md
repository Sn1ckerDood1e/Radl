---
phase: 17-facility-ui-features
plan: 07
type: execute
wave: 4
depends_on: [17-02, 17-03]
files_modified:
  - src/app/(dashboard)/facility/[facilitySlug]/events/page.tsx
  - src/app/(dashboard)/facility/[facilitySlug]/events/new/page.tsx
  - src/app/api/facility/[facilityId]/events/route.ts
autonomous: true

must_haves:
  truths:
    - "Facility admin can create events for multiple clubs at once"
    - "Created events are copied to each selected club's practices"
    - "Facility admin can view list of facility-created events"
    - "Clubs receive their own copy they can modify"
  artifacts:
    - path: "src/app/(dashboard)/facility/[facilitySlug]/events/page.tsx"
      provides: "Facility events list page"
      min_lines: 80
    - path: "src/app/(dashboard)/facility/[facilitySlug]/events/new/page.tsx"
      provides: "Cross-club event creation page"
      min_lines: 120
    - path: "src/app/api/facility/[facilityId]/events/route.ts"
      provides: "API for creating cross-club events"
      exports: ["GET", "POST"]
  key_links:
    - from: "events/new/page.tsx"
      to: "/api/facility/[facilityId]/events"
      via: "fetch POST"
      pattern: "fetch.*facility.*events"
---

<objective>
Create cross-club event scheduling where facility admin can create events visible to multiple clubs.

Purpose: Facility admins need to schedule facility-wide events (practices, regattas, meetings) that apply to selected clubs (FAC-08).

Output: Events list page, event creation form with club selection, and API that copies events to each club.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/17-facility-ui-features/17-CONTEXT.md
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cross-club events API</name>
  <files>src/app/api/facility/[facilityId]/events/route.ts</files>
  <action>
Create `src/app/api/facility/[facilityId]/events/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { prisma } from '@/lib/prisma';

const createEventSchema = z.object({
  name: z.string().min(1, 'Name is required').max(100),
  date: z.string().datetime(),
  startTime: z.string().datetime(),
  endTime: z.string().datetime(),
  clubIds: z.array(z.string().uuid()).min(1, 'Select at least one club'),
  notes: z.string().max(1000).optional(),
});

interface RouteContext {
  params: Promise<{ facilityId: string }>;
}

// GET /api/facility/[facilityId]/events - List events created by facility
export async function GET(request: NextRequest, context: RouteContext) {
  const { facilityId } = await context.params;

  const { user, viewMode, error } = await getClaimsForApiRoute();
  if (error || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Verify FACILITY_ADMIN role
  const membership = await prisma.facilityMembership.findFirst({
    where: {
      facilityId,
      userId: user.id,
      isActive: true,
      roles: { has: 'FACILITY_ADMIN' },
    },
  });

  if (!membership) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  // Get practices created by this facility (via metadata)
  // We store facilityEventId in notes as JSON for tracking
  const facilityPractices = await prisma.practice.findMany({
    where: {
      notes: { contains: '"facilityEventId":' },
      team: { facilityId },
    },
    include: {
      team: { select: { id: true, name: true, slug: true } },
      season: { select: { id: true, name: true } },
    },
    orderBy: { date: 'desc' },
    take: 100,
  });

  // Group by facilityEventId
  const eventsMap = new Map<string, {
    id: string;
    name: string;
    date: Date;
    startTime: Date;
    endTime: Date;
    clubs: { id: string; name: string; practiceId: string }[];
  }>();

  for (const practice of facilityPractices) {
    try {
      const metadata = JSON.parse(practice.notes || '{}');
      if (metadata.facilityEventId) {
        const existing = eventsMap.get(metadata.facilityEventId);
        if (existing) {
          existing.clubs.push({
            id: practice.team.id,
            name: practice.team.name,
            practiceId: practice.id,
          });
        } else {
          eventsMap.set(metadata.facilityEventId, {
            id: metadata.facilityEventId,
            name: practice.name,
            date: practice.date,
            startTime: practice.startTime,
            endTime: practice.endTime,
            clubs: [{
              id: practice.team.id,
              name: practice.team.name,
              practiceId: practice.id,
            }],
          });
        }
      }
    } catch {
      // Skip practices with invalid notes JSON
    }
  }

  const events = Array.from(eventsMap.values()).sort(
    (a, b) => b.date.getTime() - a.date.getTime()
  );

  return NextResponse.json({ events });
}

// POST /api/facility/[facilityId]/events - Create event for multiple clubs
export async function POST(request: NextRequest, context: RouteContext) {
  const { facilityId } = await context.params;

  const { user, viewMode, error } = await getClaimsForApiRoute();
  if (error || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Verify FACILITY_ADMIN role
  const membership = await prisma.facilityMembership.findFirst({
    where: {
      facilityId,
      userId: user.id,
      isActive: true,
      roles: { has: 'FACILITY_ADMIN' },
    },
  });

  if (!membership) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  // Verify facility exists
  const facility = await prisma.facility.findUnique({
    where: { id: facilityId },
  });

  if (!facility) {
    return NextResponse.json({ error: 'Facility not found' }, { status: 404 });
  }

  // Parse and validate body
  const body = await request.json();
  const validation = createEventSchema.safeParse(body);

  if (!validation.success) {
    return NextResponse.json(
      { error: 'Validation failed', details: validation.error.flatten() },
      { status: 400 }
    );
  }

  const { name, date, startTime, endTime, clubIds, notes } = validation.data;

  // Verify all clubs belong to this facility
  const clubs = await prisma.team.findMany({
    where: {
      id: { in: clubIds },
      facilityId,
    },
    include: {
      seasons: {
        where: { status: 'ACTIVE' },
        take: 1,
        orderBy: { createdAt: 'desc' },
      },
    },
  });

  if (clubs.length !== clubIds.length) {
    return NextResponse.json(
      { error: 'Some clubs not found or not in this facility' },
      { status: 400 }
    );
  }

  // Generate unique facility event ID for tracking
  const facilityEventId = crypto.randomUUID();

  // Create practice for each club in transaction
  const practices = await prisma.$transaction(async (tx) => {
    const created = [];

    for (const club of clubs) {
      // Get or create a season for the club
      let season = club.seasons[0];
      if (!season) {
        season = await tx.season.create({
          data: {
            teamId: club.id,
            name: `${new Date().getFullYear()} Season`,
            status: 'ACTIVE',
          },
        });
      }

      // Create practice with metadata tracking
      const metadata = {
        facilityEventId,
        createdByFacilityId: facilityId,
        originalNotes: notes,
      };

      const practice = await tx.practice.create({
        data: {
          teamId: club.id,
          seasonId: season.id,
          name,
          date: new Date(date),
          startTime: new Date(startTime),
          endTime: new Date(endTime),
          status: 'PUBLISHED', // Facility events are published immediately
          notes: JSON.stringify(metadata),
        },
      });

      created.push({
        practiceId: practice.id,
        clubId: club.id,
        clubName: club.name,
      });
    }

    return created;
  });

  return NextResponse.json({
    facilityEventId,
    practices,
  }, { status: 201 });
}
```

Note: Per CONTEXT decision, clubs can modify their copy after creation. The facilityEventId metadata tracks which practices came from the same facility event, but there's no synchronization - each club's copy is independent.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>API creates practices for each selected club with metadata tracking the facility event origin</done>
</task>

<task type="auto">
  <name>Task 2: Create facility events list page</name>
  <files>src/app/(dashboard)/facility/[facilitySlug]/events/page.tsx, src/app/(dashboard)/facility/[facilitySlug]/events/loading.tsx</files>
  <action>
Create `src/app/(dashboard)/facility/[facilitySlug]/events/page.tsx`:

```tsx
import { redirect } from 'next/navigation';
import Link from 'next/link';
import { format } from 'date-fns';
import { Calendar, Plus, ArrowLeft, Users } from 'lucide-react';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { prisma } from '@/lib/prisma';

interface EventsPageProps {
  params: Promise<{ facilitySlug: string }>;
}

export default async function FacilityEventsPage({ params }: EventsPageProps) {
  const { facilitySlug } = await params;

  // Auth checks
  const { user, viewMode, error } = await getClaimsForApiRoute();
  if (error || !user) redirect('/login');
  if (viewMode !== 'facility') redirect('/');

  // Get facility and verify admin
  const facility = await prisma.facility.findUnique({
    where: { slug: facilitySlug },
    select: { id: true, name: true },
  });
  if (!facility) redirect('/');

  const membership = await prisma.facilityMembership.findFirst({
    where: {
      facilityId: facility.id,
      userId: user.id,
      isActive: true,
      roles: { has: 'FACILITY_ADMIN' },
    },
  });
  if (!membership) redirect('/');

  // Get facility-created practices (grouped by facilityEventId)
  const facilityPractices = await prisma.practice.findMany({
    where: {
      notes: { contains: '"facilityEventId":' },
      team: { facilityId: facility.id },
    },
    include: {
      team: { select: { id: true, name: true, slug: true } },
    },
    orderBy: { date: 'desc' },
    take: 200,
  });

  // Group by facilityEventId
  const eventsMap = new Map<string, {
    id: string;
    name: string;
    date: Date;
    startTime: Date;
    endTime: Date;
    clubs: { id: string; name: string; slug: string }[];
  }>();

  for (const practice of facilityPractices) {
    try {
      const metadata = JSON.parse(practice.notes || '{}');
      if (metadata.facilityEventId) {
        const existing = eventsMap.get(metadata.facilityEventId);
        if (existing) {
          if (!existing.clubs.some(c => c.id === practice.team.id)) {
            existing.clubs.push({
              id: practice.team.id,
              name: practice.team.name,
              slug: practice.team.slug,
            });
          }
        } else {
          eventsMap.set(metadata.facilityEventId, {
            id: metadata.facilityEventId,
            name: practice.name,
            date: practice.date,
            startTime: practice.startTime,
            endTime: practice.endTime,
            clubs: [{
              id: practice.team.id,
              name: practice.team.name,
              slug: practice.team.slug,
            }],
          });
        }
      }
    } catch {
      // Skip practices with invalid notes JSON
    }
  }

  const events = Array.from(eventsMap.values()).sort(
    (a, b) => b.date.getTime() - a.date.getTime()
  );

  // Split into upcoming and past
  const now = new Date();
  const upcomingEvents = events.filter(e => e.date >= now);
  const pastEvents = events.filter(e => e.date < now);

  return (
    <div className="max-w-6xl mx-auto">
      {/* Header */}
      <div className="flex items-center justify-between mb-8">
        <div>
          <div className="flex items-center gap-3 mb-2">
            <Link
              href={`/facility/${facilitySlug}`}
              className="text-[var(--text-muted)] hover:text-[var(--text-secondary)] transition-colors"
            >
              <ArrowLeft className="h-5 w-5" />
            </Link>
            <Calendar className="h-6 w-6 text-[var(--accent)]" />
            <h1 className="text-2xl font-bold text-[var(--text-primary)]">Facility Events</h1>
          </div>
          <p className="text-[var(--text-secondary)]">
            Cross-club events created for {facility.name}
          </p>
        </div>
        <Link
          href={`/facility/${facilitySlug}/events/new`}
          className="inline-flex items-center px-4 py-2 rounded-lg text-sm font-medium text-white bg-emerald-600 hover:bg-emerald-500 transition-colors"
        >
          <Plus className="h-5 w-5 mr-2" />
          Create Event
        </Link>
      </div>

      {events.length === 0 ? (
        <div className="bg-[var(--surface-1)] rounded-xl p-8 text-center border border-[var(--border-subtle)]">
          <Calendar className="h-12 w-12 text-[var(--text-muted)] mx-auto mb-4" />
          <h3 className="text-lg font-medium text-[var(--text-primary)] mb-2">No facility events</h3>
          <p className="text-[var(--text-muted)] mb-4">
            Create events that appear on multiple clubs&apos; calendars at once.
          </p>
          <Link
            href={`/facility/${facilitySlug}/events/new`}
            className="inline-flex items-center px-4 py-2 rounded-lg text-sm font-medium text-white bg-emerald-600 hover:bg-emerald-500 transition-colors"
          >
            <Plus className="h-5 w-5 mr-2" />
            Create First Event
          </Link>
        </div>
      ) : (
        <div className="space-y-8">
          {/* Upcoming Events */}
          {upcomingEvents.length > 0 && (
            <div>
              <h2 className="text-lg font-semibold text-[var(--text-primary)] mb-4">
                Upcoming Events ({upcomingEvents.length})
              </h2>
              <div className="space-y-3">
                {upcomingEvents.map((event) => (
                  <div
                    key={event.id}
                    className="bg-[var(--surface-1)] rounded-xl p-4 border border-[var(--border-subtle)]"
                  >
                    <div className="flex items-start justify-between">
                      <div>
                        <h3 className="font-medium text-[var(--text-primary)]">{event.name}</h3>
                        <p className="text-sm text-[var(--text-secondary)] mt-1">
                          {format(event.date, 'EEEE, MMMM d, yyyy')} &middot;{' '}
                          {format(event.startTime, 'h:mm a')} - {format(event.endTime, 'h:mm a')}
                        </p>
                        <div className="flex items-center gap-1 mt-2">
                          <Users className="h-4 w-4 text-[var(--text-muted)]" />
                          <span className="text-sm text-[var(--text-muted)]">
                            {event.clubs.map(c => c.name).join(', ')}
                          </span>
                        </div>
                      </div>
                      <span className="px-2 py-1 text-xs rounded-full bg-emerald-500/20 text-emerald-400">
                        {event.clubs.length} club{event.clubs.length !== 1 ? 's' : ''}
                      </span>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Past Events */}
          {pastEvents.length > 0 && (
            <div>
              <h2 className="text-lg font-semibold text-[var(--text-primary)] mb-4">
                Past Events ({pastEvents.length})
              </h2>
              <div className="space-y-3">
                {pastEvents.slice(0, 20).map((event) => (
                  <div
                    key={event.id}
                    className="bg-[var(--surface-1)] rounded-xl p-4 border border-[var(--border-subtle)] opacity-75"
                  >
                    <div className="flex items-start justify-between">
                      <div>
                        <h3 className="font-medium text-[var(--text-primary)]">{event.name}</h3>
                        <p className="text-sm text-[var(--text-muted)] mt-1">
                          {format(event.date, 'MMMM d, yyyy')}
                        </p>
                        <p className="text-xs text-[var(--text-muted)] mt-1">
                          {event.clubs.map(c => c.name).join(', ')}
                        </p>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      )}

      {/* Info note */}
      <div className="mt-8 p-4 bg-[var(--surface-1)] rounded-lg border border-[var(--border-subtle)]">
        <p className="text-sm text-[var(--text-muted)]">
          <strong className="text-[var(--text-secondary)]">Note:</strong> Each club receives their own copy of the event. Clubs can modify their copy independently (change times, add notes).
        </p>
      </div>
    </div>
  );
}
```

Also create loading.tsx:
```tsx
import { Skeleton } from '@/components/ui/skeleton';

export default function EventsLoading() {
  return (
    <div className="max-w-6xl mx-auto">
      <div className="flex items-center justify-between mb-8">
        <div>
          <div className="flex items-center gap-3 mb-2">
            <Skeleton className="h-5 w-5" />
            <Skeleton className="h-6 w-6" />
            <Skeleton className="h-8 w-40" />
          </div>
          <Skeleton className="h-5 w-64" />
        </div>
        <Skeleton className="h-10 w-32" />
      </div>
      <div className="space-y-3">
        {[1, 2, 3, 4].map((i) => (
          <div key={i} className="bg-[var(--surface-1)] rounded-xl p-4 border border-[var(--border-subtle)]">
            <Skeleton className="h-5 w-48 mb-2" />
            <Skeleton className="h-4 w-64 mb-2" />
            <Skeleton className="h-4 w-32" />
          </div>
        ))}
      </div>
    </div>
  );
}
```
  </action>
  <verify>Navigate to /facility/{facilitySlug}/events - shows list of facility-created events</verify>
  <done>Events page displays facility-created events grouped by upcoming/past with club participation</done>
</task>

<task type="auto">
  <name>Task 3: Create cross-club event creation page</name>
  <files>src/app/(dashboard)/facility/[facilitySlug]/events/new/page.tsx</files>
  <action>
Create `src/app/(dashboard)/facility/[facilitySlug]/events/new/page.tsx`:

```tsx
'use client';

import { useState, useEffect } from 'react';
import { useRouter, useParams } from 'next/navigation';
import Link from 'next/link';
import { ArrowLeft, Calendar, Loader2, Check } from 'lucide-react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { format } from 'date-fns';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';

const eventSchema = z.object({
  name: z.string().min(1, 'Name is required').max(100),
  date: z.string().min(1, 'Date is required'),
  startTime: z.string().min(1, 'Start time is required'),
  endTime: z.string().min(1, 'End time is required'),
  notes: z.string().max(1000).optional(),
});

type FormData = z.infer<typeof eventSchema>;

interface Club {
  id: string;
  name: string;
  slug: string;
}

export default function NewFacilityEventPage() {
  const router = useRouter();
  const params = useParams();
  const facilitySlug = params.facilitySlug as string;

  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [clubs, setClubs] = useState<Club[]>([]);
  const [selectedClubIds, setSelectedClubIds] = useState<string[]>([]);
  const [isLoadingClubs, setIsLoadingClubs] = useState(true);
  const [facilityId, setFacilityId] = useState<string | null>(null);

  const { register, handleSubmit, formState: { errors } } = useForm<FormData>({
    resolver: zodResolver(eventSchema),
    defaultValues: {
      date: format(new Date(), 'yyyy-MM-dd'),
      startTime: '06:00',
      endTime: '08:00',
    },
  });

  // Load facility and clubs
  useEffect(() => {
    async function loadClubs() {
      try {
        const facilityRes = await fetch(`/api/facility/by-slug/${facilitySlug}`);
        if (!facilityRes.ok) throw new Error('Failed to get facility');
        const { facility } = await facilityRes.json();
        setFacilityId(facility.id);

        const clubsRes = await fetch(`/api/facility/${facility.id}/clubs`);
        if (!clubsRes.ok) throw new Error('Failed to get clubs');
        const { clubs: clubList } = await clubsRes.json();
        setClubs(clubList);
        // Select all clubs by default
        setSelectedClubIds(clubList.map((c: Club) => c.id));
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load clubs');
      } finally {
        setIsLoadingClubs(false);
      }
    }
    loadClubs();
  }, [facilitySlug]);

  const toggleClub = (clubId: string) => {
    setSelectedClubIds(prev =>
      prev.includes(clubId)
        ? prev.filter(id => id !== clubId)
        : [...prev, clubId]
    );
  };

  const toggleAll = () => {
    if (selectedClubIds.length === clubs.length) {
      setSelectedClubIds([]);
    } else {
      setSelectedClubIds(clubs.map(c => c.id));
    }
  };

  const onSubmit = async (data: FormData) => {
    if (selectedClubIds.length === 0) {
      setError('Select at least one club');
      return;
    }

    setIsSubmitting(true);
    setError(null);

    try {
      // Combine date and time
      const dateStr = data.date;
      const startDateTime = new Date(`${dateStr}T${data.startTime}:00`);
      const endDateTime = new Date(`${dateStr}T${data.endTime}:00`);

      const response = await fetch(`/api/facility/${facilityId}/events`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: data.name,
          date: startDateTime.toISOString(),
          startTime: startDateTime.toISOString(),
          endTime: endDateTime.toISOString(),
          clubIds: selectedClubIds,
          notes: data.notes,
        }),
      });

      if (!response.ok) {
        const result = await response.json();
        throw new Error(result.error || 'Failed to create event');
      }

      router.push(`/facility/${facilitySlug}/events`);
      router.refresh();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Something went wrong');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="max-w-2xl mx-auto">
      {/* Header */}
      <div className="mb-8">
        <div className="flex items-center gap-3 mb-2">
          <Link
            href={`/facility/${facilitySlug}/events`}
            className="text-[var(--text-muted)] hover:text-[var(--text-secondary)] transition-colors"
          >
            <ArrowLeft className="h-5 w-5" />
          </Link>
          <Calendar className="h-6 w-6 text-[var(--accent)]" />
          <h1 className="text-2xl font-bold text-[var(--text-primary)]">Create Facility Event</h1>
        </div>
        <p className="text-[var(--text-secondary)]">
          Create an event that appears on selected clubs&apos; calendars
        </p>
      </div>

      {error && (
        <div className="mb-6 p-4 bg-red-500/10 border border-red-500/30 rounded-lg text-red-400">
          {error}
        </div>
      )}

      <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
        {/* Event Details */}
        <div className="bg-[var(--surface-1)] rounded-xl p-6 border border-[var(--border-subtle)] space-y-6">
          <h2 className="text-lg font-medium text-[var(--text-primary)]">Event Details</h2>

          {/* Name */}
          <div>
            <label className="block text-sm font-medium text-[var(--text-secondary)] mb-2">
              Event Name *
            </label>
            <Input {...register('name')} placeholder="e.g., Facility Safety Meeting, Combined Practice" />
            {errors.name && <p className="text-sm text-red-400 mt-1">{errors.name.message}</p>}
          </div>

          {/* Date and Time */}
          <div className="grid grid-cols-3 gap-4">
            <div>
              <label className="block text-sm font-medium text-[var(--text-secondary)] mb-2">
                Date *
              </label>
              <Input type="date" {...register('date')} />
              {errors.date && <p className="text-sm text-red-400 mt-1">{errors.date.message}</p>}
            </div>
            <div>
              <label className="block text-sm font-medium text-[var(--text-secondary)] mb-2">
                Start Time *
              </label>
              <Input type="time" {...register('startTime')} />
              {errors.startTime && <p className="text-sm text-red-400 mt-1">{errors.startTime.message}</p>}
            </div>
            <div>
              <label className="block text-sm font-medium text-[var(--text-secondary)] mb-2">
                End Time *
              </label>
              <Input type="time" {...register('endTime')} />
              {errors.endTime && <p className="text-sm text-red-400 mt-1">{errors.endTime.message}</p>}
            </div>
          </div>

          {/* Notes */}
          <div>
            <label className="block text-sm font-medium text-[var(--text-secondary)] mb-2">
              Notes (optional)
            </label>
            <textarea
              {...register('notes')}
              rows={3}
              className="w-full px-3 py-2 bg-[var(--surface-2)] border border-[var(--border)] rounded-lg text-[var(--text-primary)] focus:outline-none focus:ring-2 focus:ring-[var(--accent)]"
              placeholder="Additional information for all clubs..."
            />
          </div>
        </div>

        {/* Club Selection */}
        <div className="bg-[var(--surface-1)] rounded-xl p-6 border border-[var(--border-subtle)]">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-lg font-medium text-[var(--text-primary)]">Select Clubs *</h2>
            <button
              type="button"
              onClick={toggleAll}
              className="text-sm text-[var(--accent)] hover:underline"
            >
              {selectedClubIds.length === clubs.length ? 'Deselect All' : 'Select All'}
            </button>
          </div>

          {isLoadingClubs ? (
            <div className="py-8 text-center text-[var(--text-muted)]">
              <Loader2 className="h-6 w-6 animate-spin mx-auto mb-2" />
              Loading clubs...
            </div>
          ) : clubs.length === 0 ? (
            <div className="py-8 text-center text-[var(--text-muted)]">
              No clubs in this facility
            </div>
          ) : (
            <div className="space-y-2">
              {clubs.map((club) => (
                <label
                  key={club.id}
                  className={`flex items-center gap-3 p-3 rounded-lg cursor-pointer transition-colors ${
                    selectedClubIds.includes(club.id)
                      ? 'bg-emerald-500/10 border border-emerald-500/30'
                      : 'bg-[var(--surface-2)] border border-transparent hover:border-[var(--border)]'
                  }`}
                >
                  <div
                    className={`h-5 w-5 rounded border flex items-center justify-center ${
                      selectedClubIds.includes(club.id)
                        ? 'bg-emerald-600 border-emerald-600'
                        : 'border-[var(--border)]'
                    }`}
                  >
                    {selectedClubIds.includes(club.id) && (
                      <Check className="h-3 w-3 text-white" />
                    )}
                  </div>
                  <input
                    type="checkbox"
                    className="sr-only"
                    checked={selectedClubIds.includes(club.id)}
                    onChange={() => toggleClub(club.id)}
                  />
                  <span className="font-medium text-[var(--text-primary)]">{club.name}</span>
                </label>
              ))}
            </div>
          )}

          {selectedClubIds.length === 0 && (
            <p className="text-sm text-red-400 mt-2">Select at least one club</p>
          )}
        </div>

        {/* Info box */}
        <div className="p-4 bg-blue-500/10 border border-blue-500/30 rounded-lg">
          <p className="text-sm text-blue-300">
            Each selected club will receive their own copy of this event. Clubs can modify their copy independently (change times, add notes, cancel).
          </p>
        </div>

        <div className="flex justify-end gap-3">
          <Button type="button" variant="outline" asChild>
            <Link href={`/facility/${facilitySlug}/events`}>Cancel</Link>
          </Button>
          <Button type="submit" disabled={isSubmitting || selectedClubIds.length === 0}>
            {isSubmitting ? (
              <>
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                Creating...
              </>
            ) : (
              `Create Event for ${selectedClubIds.length} Club${selectedClubIds.length !== 1 ? 's' : ''}`
            )}
          </Button>
        </div>
      </form>
    </div>
  );
}
```

Also need to create the clubs API endpoint for the facility. Create `src/app/api/facility/[facilityId]/clubs/route.ts`:

```tsx
import { NextRequest, NextResponse } from 'next/server';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { prisma } from '@/lib/prisma';

interface RouteContext {
  params: Promise<{ facilityId: string }>;
}

export async function GET(request: NextRequest, context: RouteContext) {
  const { facilityId } = await context.params;

  const { user, error } = await getClaimsForApiRoute();
  if (error || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Verify user has access to this facility
  const membership = await prisma.facilityMembership.findFirst({
    where: {
      facilityId,
      userId: user.id,
      isActive: true,
    },
  });

  if (!membership) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const clubs = await prisma.team.findMany({
    where: { facilityId },
    select: {
      id: true,
      name: true,
      slug: true,
    },
    orderBy: { name: 'asc' },
  });

  return NextResponse.json({ clubs });
}
```
  </action>
  <verify>Navigate to /facility/{facilitySlug}/events/new, select clubs, submit - should create event and redirect</verify>
  <done>Event creation page allows selecting clubs and creates practice for each</done>
</task>

</tasks>

<verification>
1. Build: `npm run build` passes
2. Events list: Navigate to /facility/{facilitySlug}/events - shows facility events
3. Empty state: If no events, shows helpful message with create button
4. Create flow: /events/new shows form with club selection
5. Club selection: Can select/deselect individual clubs or use Select All
6. Submit: Creates practice for each selected club
7. After create: Shows new event in events list
8. Info note: Explains clubs can modify their copy
</verification>

<success_criteria>
- Events list page shows facility-created events with participating clubs
- Events grouped by upcoming/past with appropriate styling
- Create event form has name, date, time inputs
- Club selection allows individual or bulk selection
- Creating event generates practice for each selected club
- Practices have metadata tracking facility event origin
- Info note explains copy independence
</success_criteria>

<output>
After completion, create `.planning/phases/17-facility-ui-features/17-07-SUMMARY.md`
</output>
