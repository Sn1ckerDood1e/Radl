---
phase: 12-facility-schema-migration
plan: 03
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - supabase/migrations/00006_facility_access_token_hook.sql
autonomous: true

must_haves:
  truths:
    - "JWT contains facility_id claim"
    - "JWT contains club_id claim"
    - "JWT contains user_roles array"
    - "Legacy team_id claim preserved for backward compat"
  artifacts:
    - path: "supabase/migrations/00006_facility_access_token_hook.sql"
      provides: "Updated custom access token hook with facility hierarchy claims"
      contains: "facility_id"
  key_links:
    - from: "custom_access_token_hook"
      to: "ClubMembership"
      via: "JOIN to get roles"
      pattern: "ClubMembership.*roles"
    - from: "custom_access_token_hook"
      to: "Team (Club)"
      via: "JOIN to get facilityId"
      pattern: "Team.*facilityId"
---

<objective>
Update Custom Access Token Hook for facility hierarchy

Purpose: JWT claims need facility_id, club_id, and user_roles for RLS policies. The hook injects these claims when user authenticates.
Output: Updated custom_access_token_hook function with facility hierarchy support
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/12-facility-schema-migration/12-RESEARCH.md
@supabase/migrations/00003_custom_access_token_hook.sql
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create updated access token hook SQL migration</name>
  <files>supabase/migrations/00006_facility_access_token_hook.sql</files>
  <action>
Create supabase/migrations/00006_facility_access_token_hook.sql with:

```sql
-- Updated Custom Access Token Hook for Facility Hierarchy
-- Injects facility_id, club_id, team_id, and user_roles into JWT claims
-- Run this in Supabase SQL Editor

-- =============================================================================
-- Updated Custom Access Token Hook
-- =============================================================================

CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
RETURNS jsonb
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  claims jsonb;
  user_facility_id uuid;
  user_club_id uuid;
  user_roles text[];
  legacy_role text;
BEGIN
  -- Get user's current context from ClubMembership + Team (Club) -> Facility
  -- Uses first active membership found (user can switch clubs via cookie)
  SELECT
    t."facilityId",
    cm."clubId",
    cm.roles
  INTO user_facility_id, user_club_id, user_roles
  FROM public."ClubMembership" cm
  JOIN public."Team" t ON t.id = cm."clubId"
  WHERE cm."userId" = (event->>'user_id')
    AND cm."isActive" = true
  LIMIT 1;

  -- If no ClubMembership, try legacy TeamMember
  IF user_club_id IS NULL THEN
    SELECT tm."teamId", t."facilityId", ARRAY[tm.role::text]
    INTO user_club_id, user_facility_id, user_roles
    FROM public."TeamMember" tm
    JOIN public."Team" t ON t.id = tm."teamId"
    WHERE tm."userId" = (event->>'user_id')
    LIMIT 1;
  END IF;

  claims := event->'claims';

  -- Add facility_id claim
  IF user_facility_id IS NOT NULL THEN
    claims := jsonb_set(claims, '{facility_id}', to_jsonb(user_facility_id::text));
  ELSE
    claims := jsonb_set(claims, '{facility_id}', 'null');
  END IF;

  -- Add club_id claim
  IF user_club_id IS NOT NULL THEN
    claims := jsonb_set(claims, '{club_id}', to_jsonb(user_club_id::text));
    -- Legacy: team_id = club_id for backward compatibility
    claims := jsonb_set(claims, '{team_id}', to_jsonb(user_club_id::text));
  ELSE
    claims := jsonb_set(claims, '{club_id}', 'null');
    claims := jsonb_set(claims, '{team_id}', 'null');
  END IF;

  -- Add user_roles claim (array)
  IF user_roles IS NOT NULL AND array_length(user_roles, 1) > 0 THEN
    claims := jsonb_set(claims, '{user_roles}', to_jsonb(user_roles));
    -- Legacy: user_role = first role for backward compatibility
    legacy_role := user_roles[1];
    claims := jsonb_set(claims, '{user_role}', to_jsonb(legacy_role));
  ELSE
    claims := jsonb_set(claims, '{user_roles}', '[]'::jsonb);
    claims := jsonb_set(claims, '{user_role}', 'null');
  END IF;

  RETURN jsonb_set(event, '{claims}', claims);
END;
$$;

-- =============================================================================
-- Permissions (re-grant after function replacement)
-- =============================================================================

-- Grant execute to supabase_auth_admin (required for hook)
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;

-- Revoke from other roles for security
REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM authenticated, anon, public;

-- =============================================================================
-- Documentation
-- =============================================================================
--
-- This hook is called by Supabase Auth when generating access tokens.
-- It injects custom claims that are used by RLS policies.
--
-- Claims added:
--   facility_id: UUID of user's facility (null if none)
--   club_id: UUID of user's current club (null if none)
--   team_id: Same as club_id (backward compatibility)
--   user_roles: Array of roles in current club (e.g., ['COACH', 'ATHLETE'])
--   user_role: First role (backward compatibility)
--
-- Note: The hook reads from ClubMembership first, falling back to TeamMember.
-- This provides backward compatibility during migration.
--
-- IMPORTANT: After running this SQL, verify the hook is enabled:
-- Authentication -> Hooks -> customAccessTokenHook should point to this function
```
  </action>
  <verify>File exists at supabase/migrations/00006_facility_access_token_hook.sql</verify>
  <done>SQL migration file created with updated hook</done>
</task>

<task type="auto">
  <name>Task 2: Apply updated access token hook to database</name>
  <files>supabase/migrations/00006_facility_access_token_hook.sql</files>
  <action>
Run the SQL migration in Supabase:

Option A - If using Supabase CLI:
```bash
supabase db push
```

Option B - If using Supabase Dashboard:
1. Open Supabase Dashboard -> SQL Editor
2. Copy contents of supabase/migrations/00006_facility_access_token_hook.sql
3. Run the SQL

Verify function was updated by running this query in SQL Editor:
```sql
SELECT pg_get_functiondef(oid)
FROM pg_proc
WHERE proname = 'custom_access_token_hook';
```

Should show the updated function with facility_id, club_id, user_roles.
  </action>
  <verify>
Run this query in Supabase SQL Editor:
```sql
SELECT routine_name, created, last_altered
FROM information_schema.routines
WHERE routine_schema = 'public'
  AND routine_name = 'custom_access_token_hook';
```
Function exists and last_altered shows recent update.
  </verify>
  <done>Updated custom_access_token_hook deployed to database</done>
</task>

</tasks>

<verification>
- SQL file exists at supabase/migrations/00006_facility_access_token_hook.sql
- custom_access_token_hook function updated in database
- Function includes facility_id, club_id, user_roles claims
- Function has backward compatibility with team_id, user_role
- Function granted to supabase_auth_admin only
</verification>

<success_criteria>
- JWT tokens include facility_id claim (from Team.facilityId)
- JWT tokens include club_id claim (from ClubMembership.clubId)
- JWT tokens include user_roles array (from ClubMembership.roles)
- Legacy team_id and user_role claims preserved
- Hook falls back to TeamMember if no ClubMembership exists
</success_criteria>

<output>
After completion, create `.planning/phases/12-facility-schema-migration/12-03-SUMMARY.md`
</output>
