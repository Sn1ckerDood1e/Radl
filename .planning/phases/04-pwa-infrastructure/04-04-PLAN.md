---
phase: 04-pwa-infrastructure
plan: 04
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - prisma/schema.prisma
  - src/app/api/push/subscribe/route.ts
  - src/app/api/push/unsubscribe/route.ts
  - src/lib/push/subscribe.ts
  - src/lib/push/vapid.ts
  - supabase/functions/send-notification/index.ts
  - .env.example
autonomous: false
user_setup:
  - service: vapid
    why: "Push notification encryption"
    env_vars:
      - name: VAPID_PUBLIC_KEY
        source: "Generate with: npx web-push generate-vapid-keys"
      - name: VAPID_PRIVATE_KEY
        source: "Generate with: npx web-push generate-vapid-keys"
      - name: NEXT_PUBLIC_VAPID_PUBLIC_KEY
        source: "Same as VAPID_PUBLIC_KEY (needed on client)"

must_haves:
  truths:
    - "User can subscribe to push notifications"
    - "Push subscription is stored in database"
    - "User can unsubscribe from notifications"
    - "VAPID keys configured for Web Push Protocol"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "PushSubscription model for storing subscriptions"
      contains: "model PushSubscription"
    - path: "src/app/api/push/subscribe/route.ts"
      provides: "API endpoint to store push subscription"
      exports: ["POST"]
    - path: "src/lib/push/subscribe.ts"
      provides: "Client-side subscription management"
      exports: ["subscribeToPush", "unsubscribeFromPush", "isPushSupported"]
    - path: "supabase/functions/send-notification/index.ts"
      provides: "Edge Function for sending push notifications"
      contains: "webpush.sendNotification"
  key_links:
    - from: "src/lib/push/subscribe.ts"
      to: "/api/push/subscribe"
      via: "fetch POST to store subscription"
      pattern: "fetch.*api/push/subscribe"
    - from: "supabase/functions/send-notification/index.ts"
      to: "PushSubscription"
      via: "reads subscriptions from database"
      pattern: "supabase.*push_subscriptions"
---

<objective>
Set up push notification infrastructure with VAPID and subscription management

Purpose: Enable the ability to send push notifications to users (actual triggers come in Plan 06)
Output: Database model for subscriptions, subscription API, and Supabase Edge Function for sending
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-pwa-infrastructure/04-RESEARCH.md
@.planning/phases/04-pwa-infrastructure/04-CONTEXT.md
@.planning/phases/04-pwa-infrastructure/04-01-SUMMARY.md

# Existing patterns
@prisma/schema.prisma
@src/lib/auth/claims.ts
@src/app/api/notifications/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PushSubscription model and generate VAPID keys</name>
  <files>
    - prisma/schema.prisma
    - .env.example
  </files>
  <action>
Add PushSubscription model to prisma/schema.prisma:

```prisma
// Push notification subscriptions for Web Push
model PushSubscription {
  id        String   @id @default(uuid())
  userId    String   // Supabase auth user ID
  teamId    String   // For team-scoped notifications
  endpoint  String   @unique // Push service endpoint URL
  p256dh    String   // Public key for encryption
  auth      String   // Auth secret for encryption
  expirationTime DateTime? // Optional expiration from browser
  userAgent String?  // For debugging
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([teamId])
  @@index([teamId, userId])
}
```

Add to existing NotificationType enum:
```prisma
enum NotificationType {
  DAMAGE_REPORT
  LINEUP_ASSIGNMENT    // New
  PRACTICE_CHANGE      // New
  PRACTICE_CANCELLED   // New
  ATHLETE_JOINED       // New (for coaches)
}
```

Update .env.example with VAPID placeholders:
```
# Push Notifications (generate with: npx web-push generate-vapid-keys)
VAPID_PUBLIC_KEY=
VAPID_PRIVATE_KEY=
NEXT_PUBLIC_VAPID_PUBLIC_KEY=
VAPID_SUBJECT=mailto:admin@rowops.app
```

Run `npx prisma db push` to update database.

Generate VAPID keys (one-time, manual):
```bash
npx web-push generate-vapid-keys --json
```
Output the command for the user to run and add keys to .env.local.
  </action>
  <verify>
- `npx prisma db push` succeeds
- PushSubscription table exists in database
- .env.example contains VAPID placeholders
  </verify>
  <done>
PushSubscription model added to schema, VAPID env vars documented
  </done>
</task>

<task type="auto">
  <name>Task 2: Create push subscription API endpoints</name>
  <files>
    - src/app/api/push/subscribe/route.ts
    - src/app/api/push/unsubscribe/route.ts
    - src/lib/push/vapid.ts
  </files>
  <action>
Create src/lib/push/vapid.ts for VAPID configuration:

```typescript
// VAPID keys for Web Push Protocol
export const vapidPublicKey = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!;
export const vapidPrivateKey = process.env.VAPID_PRIVATE_KEY!;
export const vapidSubject = process.env.VAPID_SUBJECT || 'mailto:admin@rowops.app';

export function isVapidConfigured(): boolean {
  return !!(vapidPublicKey && vapidPrivateKey);
}
```

Create src/app/api/push/subscribe/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { unauthorizedResponse, forbiddenResponse } from '@/lib/errors/responses';
import { isVapidConfigured } from '@/lib/push/vapid';

export async function POST(request: NextRequest) {
  // Check VAPID configuration
  if (!isVapidConfigured()) {
    return NextResponse.json(
      { error: 'Push notifications not configured' },
      { status: 503 }
    );
  }

  const { user, claims, error } = await getClaimsForApiRoute();
  if (error || !user) return unauthorizedResponse();
  if (!claims?.team_id) return forbiddenResponse('No team associated');

  try {
    const body = await request.json();
    const { endpoint, keys, expirationTime } = body;

    if (!endpoint || !keys?.p256dh || !keys?.auth) {
      return NextResponse.json(
        { error: 'Invalid subscription format' },
        { status: 400 }
      );
    }

    // Upsert subscription (endpoint is unique)
    const subscription = await prisma.pushSubscription.upsert({
      where: { endpoint },
      update: {
        p256dh: keys.p256dh,
        auth: keys.auth,
        expirationTime: expirationTime ? new Date(expirationTime) : null,
        userAgent: request.headers.get('user-agent') || undefined,
        updatedAt: new Date(),
      },
      create: {
        userId: user.id,
        teamId: claims.team_id,
        endpoint,
        p256dh: keys.p256dh,
        auth: keys.auth,
        expirationTime: expirationTime ? new Date(expirationTime) : null,
        userAgent: request.headers.get('user-agent') || undefined,
      },
    });

    return NextResponse.json({ success: true, id: subscription.id });
  } catch (err) {
    console.error('Failed to save push subscription:', err);
    return NextResponse.json(
      { error: 'Failed to save subscription' },
      { status: 500 }
    );
  }
}
```

Create src/app/api/push/unsubscribe/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { unauthorizedResponse } from '@/lib/errors/responses';

export async function POST(request: NextRequest) {
  const { user, error } = await getClaimsForApiRoute();
  if (error || !user) return unauthorizedResponse();

  try {
    const body = await request.json();
    const { endpoint } = body;

    if (!endpoint) {
      return NextResponse.json(
        { error: 'Endpoint required' },
        { status: 400 }
      );
    }

    // Delete subscription
    await prisma.pushSubscription.deleteMany({
      where: {
        endpoint,
        userId: user.id, // Only delete own subscriptions
      },
    });

    return NextResponse.json({ success: true });
  } catch (err) {
    console.error('Failed to remove push subscription:', err);
    return NextResponse.json(
      { error: 'Failed to remove subscription' },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>
- Both API routes compile: `npx tsc --noEmit src/app/api/push/*/route.ts`
- POST /api/push/subscribe returns 200 with valid subscription data (test with curl or Postman)
- POST /api/push/unsubscribe removes the subscription
  </verify>
  <done>
Push subscription API endpoints created for subscribe and unsubscribe
  </done>
</task>

<task type="auto">
  <name>Task 3: Create client subscription helper and Supabase Edge Function</name>
  <files>
    - src/lib/push/subscribe.ts
    - supabase/functions/send-notification/index.ts
  </files>
  <action>
Create src/lib/push/subscribe.ts:

```typescript
'use client';

import { vapidPublicKey } from './vapid';

/**
 * Check if push notifications are supported
 */
export function isPushSupported(): boolean {
  return (
    typeof window !== 'undefined' &&
    'serviceWorker' in navigator &&
    'PushManager' in window &&
    'Notification' in window
  );
}

/**
 * Check current notification permission
 */
export function getNotificationPermission(): NotificationPermission | null {
  if (!isPushSupported()) return null;
  return Notification.permission;
}

/**
 * Request permission and subscribe to push notifications
 */
export async function subscribeToPush(): Promise<PushSubscription | null> {
  if (!isPushSupported()) {
    throw new Error('Push notifications not supported');
  }

  // Request notification permission
  const permission = await Notification.requestPermission();
  if (permission !== 'granted') {
    throw new Error('Notification permission denied');
  }

  // Get service worker registration
  const registration = await navigator.serviceWorker.ready;

  // Subscribe to push
  const subscription = await registration.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: urlBase64ToUint8Array(vapidPublicKey),
  });

  // Send subscription to server
  const response = await fetch('/api/push/subscribe', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(subscription.toJSON()),
  });

  if (!response.ok) {
    throw new Error('Failed to save subscription on server');
  }

  return subscription;
}

/**
 * Unsubscribe from push notifications
 */
export async function unsubscribeFromPush(): Promise<void> {
  if (!isPushSupported()) return;

  const registration = await navigator.serviceWorker.ready;
  const subscription = await registration.pushManager.getSubscription();

  if (subscription) {
    // Notify server
    await fetch('/api/push/unsubscribe', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ endpoint: subscription.endpoint }),
    });

    // Unsubscribe locally
    await subscription.unsubscribe();
  }
}

/**
 * Get current push subscription (if any)
 */
export async function getCurrentSubscription(): Promise<PushSubscription | null> {
  if (!isPushSupported()) return null;

  const registration = await navigator.serviceWorker.ready;
  return registration.pushManager.getSubscription();
}

// Helper to convert VAPID key
function urlBase64ToUint8Array(base64String: string): Uint8Array {
  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding)
    .replace(/-/g, '+')
    .replace(/_/g, '/');

  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);

  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}
```

Create supabase/functions/send-notification/index.ts:

```typescript
// Supabase Edge Function for sending push notifications
// Deploy with: supabase functions deploy send-notification

import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import webpush from 'npm:web-push@3.6.7';

const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
const vapidPublicKey = Deno.env.get('VAPID_PUBLIC_KEY')!;
const vapidPrivateKey = Deno.env.get('VAPID_PRIVATE_KEY')!;
const vapidSubject = Deno.env.get('VAPID_SUBJECT') || 'mailto:admin@rowops.app';

webpush.setVapidDetails(vapidSubject, vapidPublicKey, vapidPrivateKey);

serve(async (req) => {
  try {
    const { teamId, userIds, title, body, url, tag } = await req.json();

    if (!teamId || !title || !body) {
      return new Response(
        JSON.stringify({ error: 'teamId, title, and body required' }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }

    const supabase = createClient(supabaseUrl, supabaseKey);

    // Get subscriptions for target users
    let query = supabase
      .from('PushSubscription')
      .select('endpoint, p256dh, auth, userId')
      .eq('teamId', teamId);

    if (userIds && userIds.length > 0) {
      query = query.in('userId', userIds);
    }

    const { data: subscriptions, error } = await query;

    if (error) {
      console.error('Failed to fetch subscriptions:', error);
      return new Response(
        JSON.stringify({ error: 'Failed to fetch subscriptions' }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
    }

    const payload = JSON.stringify({
      title,
      body,
      url: url || '/',
      icon: '/icons/icon-192x192.png',
      badge: '/icons/icon-192x192.png',
      tag: tag || 'rowops-notification',
    });

    const results = await Promise.allSettled(
      subscriptions.map(async (sub) => {
        try {
          await webpush.sendNotification(
            {
              endpoint: sub.endpoint,
              keys: { p256dh: sub.p256dh, auth: sub.auth },
            },
            payload
          );
          return { userId: sub.userId, success: true };
        } catch (err: any) {
          // Handle expired subscriptions (410 Gone)
          if (err.statusCode === 410) {
            await supabase
              .from('PushSubscription')
              .delete()
              .eq('endpoint', sub.endpoint);
          }
          return { userId: sub.userId, success: false, error: err.message };
        }
      })
    );

    const sent = results.filter(
      (r) => r.status === 'fulfilled' && r.value.success
    ).length;
    const failed = results.length - sent;

    return new Response(
      JSON.stringify({ sent, failed, total: subscriptions.length }),
      { headers: { 'Content-Type': 'application/json' } }
    );
  } catch (err) {
    console.error('Edge function error:', err);
    return new Response(
      JSON.stringify({ error: 'Internal server error' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
});
```

Add push event handling to service worker (update src/app/sw.ts):
```typescript
// Add after serwist.addEventListeners();

self.addEventListener('push', (event: PushEvent) => {
  const data = event.data?.json() || {};

  event.waitUntil(
    self.registration.showNotification(data.title || 'RowOps', {
      body: data.body,
      icon: data.icon || '/icons/icon-192x192.png',
      badge: data.badge || '/icons/icon-192x192.png',
      data: { url: data.url },
      tag: data.tag,
    })
  );
});

self.addEventListener('notificationclick', (event: NotificationEvent) => {
  event.notification.close();

  event.waitUntil(
    clients.openWindow(event.notification.data?.url || '/')
  );
});
```
  </action>
  <verify>
- Client subscribe.ts compiles without errors
- Supabase function file exists at supabase/functions/send-notification/index.ts
- Service worker has push and notificationclick handlers
  </verify>
  <done>
Client subscription helper and Supabase Edge Function for sending notifications created
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Push notification infrastructure including database model, API endpoints, client subscription helper, and Supabase Edge Function</what-built>
  <how-to-verify>
1. Generate VAPID keys:
   ```bash
   cd /home/hb/rowops && npx web-push generate-vapid-keys --json
   ```
2. Add keys to .env.local:
   - VAPID_PUBLIC_KEY=...
   - VAPID_PRIVATE_KEY=...
   - NEXT_PUBLIC_VAPID_PUBLIC_KEY=... (same as public)
   - VAPID_SUBJECT=mailto:your-email@example.com

3. Run database migration:
   ```bash
   npx prisma db push
   ```

4. Build and verify:
   ```bash
   npm run build
   ```

5. (Optional) Deploy Edge Function to Supabase:
   ```bash
   supabase functions deploy send-notification
   ```
   Then add VAPID keys to Supabase function secrets.
  </how-to-verify>
  <resume-signal>Type "approved" when VAPID keys are configured and database is migrated</resume-signal>
</task>

</tasks>

<verification>
1. PushSubscription table exists in database
2. VAPID keys are configured in .env.local
3. API endpoints respond correctly:
   - POST /api/push/subscribe with valid subscription body returns 200
   - POST /api/push/unsubscribe removes the subscription
4. Client-side subscribeToPush() successfully subscribes (check DevTools > Application > Push Messaging)
5. Edge Function deployed to Supabase (can test later with triggers)
</verification>

<success_criteria>
1. PushSubscription model in database storing user subscriptions
2. VAPID keys configured for Web Push Protocol
3. Users can subscribe via client-side function
4. Subscriptions stored in database with team context
5. Supabase Edge Function ready to send notifications
6. Expired subscriptions (410 Gone) automatically cleaned up
</success_criteria>

<output>
After completion, create `.planning/phases/04-pwa-infrastructure/04-04-SUMMARY.md`
</output>
