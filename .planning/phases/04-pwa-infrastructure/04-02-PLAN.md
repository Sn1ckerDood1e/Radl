---
phase: 04-pwa-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/lib/db/hooks.ts
  - src/lib/db/sync-queue.ts
autonomous: true

must_haves:
  truths:
    - "IndexedDB database created with radl-offline name"
    - "Schedules and lineups can be stored locally"
    - "React components can reactively query offline data"
    - "Sync queue can track pending mutations"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "Dexie database schema with versioning"
      exports: ["db", "AppDB", "OfflineSchedule", "OfflineLineup", "SyncQueueItem"]
    - path: "src/lib/db/hooks.ts"
      provides: "React hooks for offline data queries"
      exports: ["useOfflineSchedules", "useOfflineLineups", "useSyncQueueCount"]
    - path: "src/lib/db/sync-queue.ts"
      provides: "Mutation queue operations"
      exports: ["queueMutation", "processSyncQueue", "clearSyncQueue"]
  key_links:
    - from: "src/lib/db/hooks.ts"
      to: "src/lib/db/schema.ts"
      via: "db import"
      pattern: "from.*schema"
    - from: "src/lib/db/sync-queue.ts"
      to: "src/lib/db/schema.ts"
      via: "db import for queue operations"
      pattern: "db\\.syncQueue"
---

<objective>
Create IndexedDB schema and React hooks using Dexie.js

Purpose: Establish offline data storage layer that schedules/lineups can be cached to and read from
Output: Database schema, reactive query hooks, and sync queue infrastructure
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-pwa-infrastructure/04-RESEARCH.md
@.planning/phases/04-pwa-infrastructure/04-CONTEXT.md

# Existing data patterns
@prisma/schema.prisma
@src/lib/utils/date-time-helpers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Dexie database schema with offline data types</name>
  <files>
    - src/lib/db/schema.ts
  </files>
  <action>
Create src/lib/db/schema.ts with Dexie database:

```typescript
import Dexie, { Table } from 'dexie';

// Offline schedule - simplified Practice data for athletes
export interface OfflineSchedule {
  id: string;              // Practice ID
  teamId: string;
  seasonId: string;
  name: string;
  date: string;            // ISO date string
  startTime: string;       // ISO datetime string
  endTime: string;         // ISO datetime string
  status: 'DRAFT' | 'PUBLISHED';
  notes?: string;
  location?: string;       // Derived from practice notes or future field
  cachedAt: number;        // Timestamp when cached
  syncStatus: 'synced' | 'pending' | 'error';
}

// Offline lineup - simplified Lineup data for coaches
export interface OfflineLineup {
  id: string;              // Lineup ID
  practiceId: string;
  blockId: string;
  blockType: 'WATER' | 'LAND' | 'ERG';
  blockPosition: number;
  boatId?: string;
  boatName?: string;
  seats: {
    position: number;
    athleteId: string;
    athleteName: string;
    side: 'PORT' | 'STARBOARD' | 'NONE';
  }[];
  cachedAt: number;
  syncStatus: 'synced' | 'pending' | 'error';
}

// Sync queue item for background sync
export interface SyncQueueItem {
  id?: number;             // Auto-increment
  operation: 'create' | 'update' | 'delete';
  entity: 'practice' | 'lineup' | 'assignment';
  entityId: string;
  payload: unknown;
  timestamp: number;
  retries: number;
}

// Metadata for tracking cache freshness
export interface CacheMeta {
  key: string;             // e.g., "schedules:team123", "lineups:team123"
  lastUpdated: number;
  expiresAt: number;
}

export class AppDB extends Dexie {
  schedules!: Table<OfflineSchedule>;
  lineups!: Table<OfflineLineup>;
  syncQueue!: Table<SyncQueueItem>;
  cacheMeta!: Table<CacheMeta>;

  constructor() {
    super('radl-offline');

    // Version 1: Initial schema
    this.version(1).stores({
      schedules: 'id, teamId, date, cachedAt, [teamId+date]',
      lineups: 'id, practiceId, blockId, cachedAt, [practiceId+blockId]',
      syncQueue: '++id, timestamp, entity',
      cacheMeta: 'key',
    });
  }
}

export const db = new AppDB();
```

Key design decisions:
- `cachedAt` timestamp on every record for staleness detection
- `syncStatus` for tracking what needs syncing
- Compound indexes for efficient team+date queries
- Separate cacheMeta table for tracking when data was last fetched
- Auto-increment ID on syncQueue for ordering
  </action>
  <verify>
- File exists at src/lib/db/schema.ts
- TypeScript compiles without errors: `npx tsc --noEmit src/lib/db/schema.ts`
- Exports: db, AppDB, OfflineSchedule, OfflineLineup, SyncQueueItem, CacheMeta
  </verify>
  <done>
Dexie database schema created with offline data types and proper indexes
  </done>
</task>

<task type="auto">
  <name>Task 2: Create React hooks for offline data queries</name>
  <files>
    - src/lib/db/hooks.ts
  </files>
  <action>
Create src/lib/db/hooks.ts with useLiveQuery hooks:

```typescript
import { useLiveQuery } from 'dexie-react-hooks';
import { db, OfflineSchedule, OfflineLineup } from './schema';
import { addDays, startOfDay } from 'date-fns';

const CACHE_WINDOW_DAYS = 14; // 2 weeks as per CONTEXT.md

/**
 * Get cached schedules for a team within the next 2 weeks
 * Automatically re-renders when IndexedDB data changes
 */
export function useOfflineSchedules(teamId: string | undefined) {
  return useLiveQuery(
    async () => {
      if (!teamId) return [];

      const today = startOfDay(new Date()).toISOString();
      const twoWeeksOut = addDays(new Date(), CACHE_WINDOW_DAYS).toISOString();

      return db.schedules
        .where('teamId')
        .equals(teamId)
        .and((s) => s.date >= today && s.date <= twoWeeksOut)
        .sortBy('date');
    },
    [teamId],
    [] // Default value while loading
  );
}

/**
 * Get cached lineups for a specific practice
 */
export function useOfflineLineups(practiceId: string | undefined) {
  return useLiveQuery(
    async () => {
      if (!practiceId) return [];

      return db.lineups
        .where('practiceId')
        .equals(practiceId)
        .sortBy('blockPosition');
    },
    [practiceId],
    []
  );
}

/**
 * Get count of pending sync items
 */
export function useSyncQueueCount() {
  return useLiveQuery(
    () => db.syncQueue.count(),
    [],
    0
  );
}

/**
 * Check if cache is stale (older than threshold)
 * Returns { isStale, lastUpdated } where lastUpdated is a Date or null
 */
export function useCacheFreshness(cacheKey: string, staleThresholdMs = 24 * 60 * 60 * 1000) {
  return useLiveQuery(
    async () => {
      const meta = await db.cacheMeta.get(cacheKey);
      if (!meta) {
        return { isStale: true, lastUpdated: null };
      }

      const isStale = Date.now() - meta.lastUpdated > staleThresholdMs;
      return {
        isStale,
        lastUpdated: new Date(meta.lastUpdated)
      };
    },
    [cacheKey, staleThresholdMs],
    { isStale: true, lastUpdated: null }
  );
}

/**
 * Get a specific schedule by ID from cache
 */
export function useOfflineSchedule(scheduleId: string | undefined) {
  return useLiveQuery(
    () => scheduleId ? db.schedules.get(scheduleId) : undefined,
    [scheduleId],
    undefined
  );
}
```

Uses useLiveQuery for automatic re-renders when data changes (including from other tabs).
  </action>
  <verify>
- File exists at src/lib/db/hooks.ts
- TypeScript compiles: `npx tsc --noEmit src/lib/db/hooks.ts`
- Exports: useOfflineSchedules, useOfflineLineups, useSyncQueueCount, useCacheFreshness, useOfflineSchedule
  </verify>
  <done>
Reactive query hooks created for schedules, lineups, and cache status
  </done>
</task>

<task type="auto">
  <name>Task 3: Create sync queue operations</name>
  <files>
    - src/lib/db/sync-queue.ts
  </files>
  <action>
Create src/lib/db/sync-queue.ts:

```typescript
import { db, SyncQueueItem } from './schema';

const MAX_RETRIES = 3;

/**
 * Add a mutation to the sync queue
 * Called when user makes a change (offline or online)
 */
export async function queueMutation(
  operation: SyncQueueItem['operation'],
  entity: SyncQueueItem['entity'],
  entityId: string,
  payload: unknown
): Promise<void> {
  await db.syncQueue.add({
    operation,
    entity,
    entityId,
    payload,
    timestamp: Date.now(),
    retries: 0,
  });

  // Attempt immediate sync if online
  if (navigator.onLine) {
    processSyncQueue().catch(console.error);
  }
}

/**
 * Process all pending items in the sync queue
 * Called on:
 * - After queueMutation if online
 * - When online event fires
 * - On app startup
 */
export async function processSyncQueue(): Promise<{
  processed: number;
  failed: number;
  remaining: number;
}> {
  const items = await db.syncQueue.orderBy('timestamp').toArray();
  let processed = 0;
  let failed = 0;

  for (const item of items) {
    try {
      const success = await syncItem(item);

      if (success) {
        await db.syncQueue.delete(item.id!);
        processed++;
      } else {
        // Increment retry count
        const newRetries = item.retries + 1;
        if (newRetries >= MAX_RETRIES) {
          // Move to failed state (keep in queue but stop retrying)
          // In production, might move to separate failed queue
          await db.syncQueue.delete(item.id!);
          failed++;
        } else {
          await db.syncQueue.update(item.id!, { retries: newRetries });
        }
      }
    } catch (error) {
      console.error('Sync failed for item:', item.id, error);
      const newRetries = item.retries + 1;
      if (newRetries >= MAX_RETRIES) {
        await db.syncQueue.delete(item.id!);
        failed++;
      } else {
        await db.syncQueue.update(item.id!, { retries: newRetries });
      }
    }
  }

  const remaining = await db.syncQueue.count();
  return { processed, failed, remaining };
}

/**
 * Sync a single queue item to the server
 */
async function syncItem(item: SyncQueueItem): Promise<boolean> {
  // Map entity to API endpoint
  const endpoints: Record<SyncQueueItem['entity'], string> = {
    practice: '/api/practices',
    lineup: '/api/lineups',
    assignment: '/api/lineups', // Assignments go through lineup API
  };

  const baseUrl = endpoints[item.entity];
  let url = baseUrl;
  let method: string;

  switch (item.operation) {
    case 'create':
      method = 'POST';
      break;
    case 'update':
      url = `${baseUrl}/${item.entityId}`;
      method = 'PATCH';
      break;
    case 'delete':
      url = `${baseUrl}/${item.entityId}`;
      method = 'DELETE';
      break;
  }

  const response = await fetch(url, {
    method,
    headers: { 'Content-Type': 'application/json' },
    body: item.operation !== 'delete' ? JSON.stringify(item.payload) : undefined,
  });

  if (response.ok) {
    return true;
  }

  // 4xx errors (client errors) - don't retry, data is bad
  if (response.status >= 400 && response.status < 500) {
    console.error('Client error syncing item, removing from queue:', response.status);
    return true; // Return true to remove from queue (won't succeed on retry)
  }

  // 5xx errors - server problem, should retry
  return false;
}

/**
 * Clear all items from sync queue (use with caution)
 */
export async function clearSyncQueue(): Promise<void> {
  await db.syncQueue.clear();
}

/**
 * Get all pending sync items (for debugging/display)
 */
export async function getPendingSyncItems(): Promise<SyncQueueItem[]> {
  return db.syncQueue.orderBy('timestamp').toArray();
}

// Register online listener to trigger sync
if (typeof window !== 'undefined') {
  window.addEventListener('online', () => {
    console.log('Online detected, processing sync queue...');
    processSyncQueue()
      .then((result) => console.log('Sync complete:', result))
      .catch(console.error);
  });
}
```

Key design decisions:
- Sequential processing (timestamp order) to maintain causality
- Max 3 retries before dropping (prevents infinite loops)
- 4xx errors removed immediately (bad data won't succeed on retry)
- Online listener triggers automatic sync
- Idempotent operations where possible
  </action>
  <verify>
- File exists at src/lib/db/sync-queue.ts
- TypeScript compiles: `npx tsc --noEmit src/lib/db/sync-queue.ts`
- Exports: queueMutation, processSyncQueue, clearSyncQueue, getPendingSyncItems
  </verify>
  <done>
Sync queue operations created with retry logic and online listener
  </done>
</task>

</tasks>

<verification>
1. All three files compile without TypeScript errors
2. `npm run build` succeeds with the new files
3. Can import and use in a test component:
```typescript
import { useOfflineSchedules, useSyncQueueCount } from '@/lib/db/hooks';
import { queueMutation } from '@/lib/db/sync-queue';
```
4. Database is created when app first accesses db (check DevTools > Application > IndexedDB)
</verification>

<success_criteria>
1. Dexie database schema defined with proper indexes
2. React hooks provide reactive queries to offline data
3. Sync queue infrastructure ready for background sync
4. All types exported for use in other modules
5. Online listener registered for automatic sync trigger
</success_criteria>

<output>
After completion, create `.planning/phases/04-pwa-infrastructure/04-02-SUMMARY.md`
</output>
