---
phase: 04-pwa-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - src/lib/db/cache-manager.ts
  - src/hooks/use-offline-data.ts
  - src/components/pwa/staleness-indicator.tsx
  - src/app/(dashboard)/[teamSlug]/schedule/page.tsx
autonomous: true

must_haves:
  truths:
    - "Schedule data is fetched from API and stored in IndexedDB"
    - "When offline, schedule loads from IndexedDB cache"
    - "Stale data shows 'Last updated X ago' indicator"
    - "Athletes see schedule for next 2 weeks when offline"
    - "API responses are cached to reduce network requests (DEBT-03)"
  artifacts:
    - path: "src/lib/db/cache-manager.ts"
      provides: "Functions to sync server data to IndexedDB"
      exports: ["cacheSchedules", "cacheLineups", "updateCacheMeta", "getCacheMeta"]
    - path: "src/hooks/use-offline-data.ts"
      provides: "Hook combining online fetch with offline fallback"
      exports: ["useScheduleWithOffline"]
    - path: "src/components/pwa/staleness-indicator.tsx"
      provides: "UI component showing cache freshness"
      exports: ["StalenessIndicator"]
  key_links:
    - from: "src/hooks/use-offline-data.ts"
      to: "src/lib/db/cache-manager.ts"
      via: "cacheSchedules call after API fetch"
      pattern: "cacheSchedules"
    - from: "src/hooks/use-offline-data.ts"
      to: "src/lib/db/hooks.ts"
      via: "useOfflineSchedules for fallback"
      pattern: "useOfflineSchedules"
---

<objective>
Implement offline data sync for schedules and lineups

Purpose: Athletes and coaches can view their schedule when offline with clear staleness indicators
Output: Cache manager, offline-aware data hooks, and staleness UI component
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-pwa-infrastructure/04-CONTEXT.md
@.planning/phases/04-pwa-infrastructure/04-01-SUMMARY.md
@.planning/phases/04-pwa-infrastructure/04-02-SUMMARY.md

# Existing schedule API and page
@src/app/api/schedule/route.ts
@src/app/(dashboard)/[teamSlug]/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cache manager for syncing server data to IndexedDB</name>
  <files>
    - src/lib/db/cache-manager.ts
  </files>
  <action>
Create src/lib/db/cache-manager.ts:

```typescript
import { db, OfflineSchedule, OfflineLineup, CacheMeta } from './schema';
import { addDays, startOfDay } from 'date-fns';

const CACHE_WINDOW_DAYS = 14;
const DEFAULT_CACHE_TTL = 24 * 60 * 60 * 1000; // 24 hours

/**
 * Cache schedules from API response to IndexedDB
 * Replaces existing cache for the team
 */
export async function cacheSchedules(
  teamId: string,
  practices: Array<{
    id: string;
    name: string;
    date: string;
    startTime: string;
    endTime: string;
    status: 'DRAFT' | 'PUBLISHED';
    notes?: string;
    seasonId: string;
  }>
): Promise<void> {
  const now = Date.now();

  // Transform to offline format
  const offlineSchedules: OfflineSchedule[] = practices.map((p) => ({
    id: p.id,
    teamId,
    seasonId: p.seasonId,
    name: p.name,
    date: p.date,
    startTime: p.startTime,
    endTime: p.endTime,
    status: p.status,
    notes: p.notes,
    cachedAt: now,
    syncStatus: 'synced' as const,
  }));

  await db.transaction('rw', [db.schedules, db.cacheMeta], async () => {
    // Clear old schedules for this team (within cache window only)
    const today = startOfDay(new Date()).toISOString();
    const windowEnd = addDays(new Date(), CACHE_WINDOW_DAYS).toISOString();

    await db.schedules
      .where('teamId')
      .equals(teamId)
      .and((s) => s.date >= today && s.date <= windowEnd)
      .delete();

    // Insert new schedules
    if (offlineSchedules.length > 0) {
      await db.schedules.bulkPut(offlineSchedules);
    }

    // Update cache metadata
    await updateCacheMeta(`schedules:${teamId}`);
  });
}

/**
 * Cache lineups for a practice to IndexedDB
 */
export async function cacheLineups(
  practiceId: string,
  lineups: Array<{
    id: string;
    blockId: string;
    block: {
      type: 'WATER' | 'LAND' | 'ERG';
      position: number;
    };
    boatId?: string;
    boat?: { name: string };
    seats: Array<{
      position: number;
      athleteId: string;
      athlete: { displayName?: string };
      side: 'PORT' | 'STARBOARD' | 'NONE';
    }>;
  }>
): Promise<void> {
  const now = Date.now();

  const offlineLineups: OfflineLineup[] = lineups.map((l) => ({
    id: l.id,
    practiceId,
    blockId: l.blockId,
    blockType: l.block.type,
    blockPosition: l.block.position,
    boatId: l.boatId,
    boatName: l.boat?.name,
    seats: l.seats.map((s) => ({
      position: s.position,
      athleteId: s.athleteId,
      athleteName: s.athlete.displayName || 'Unknown',
      side: s.side,
    })),
    cachedAt: now,
    syncStatus: 'synced' as const,
  }));

  await db.transaction('rw', [db.lineups, db.cacheMeta], async () => {
    // Clear old lineups for this practice
    await db.lineups.where('practiceId').equals(practiceId).delete();

    // Insert new lineups
    if (offlineLineups.length > 0) {
      await db.lineups.bulkPut(offlineLineups);
    }

    // Update cache metadata
    await updateCacheMeta(`lineups:${practiceId}`);
  });
}

/**
 * Update cache metadata timestamp
 */
export async function updateCacheMeta(
  key: string,
  ttlMs: number = DEFAULT_CACHE_TTL
): Promise<void> {
  const now = Date.now();
  await db.cacheMeta.put({
    key,
    lastUpdated: now,
    expiresAt: now + ttlMs,
  });
}

/**
 * Get cache metadata
 */
export async function getCacheMeta(key: string): Promise<CacheMeta | undefined> {
  return db.cacheMeta.get(key);
}

/**
 * Check if cache is expired
 */
export async function isCacheExpired(key: string): Promise<boolean> {
  const meta = await getCacheMeta(key);
  if (!meta) return true;
  return Date.now() > meta.expiresAt;
}

/**
 * Clear all cached data for a team (useful for logout)
 */
export async function clearTeamCache(teamId: string): Promise<void> {
  await db.transaction('rw', [db.schedules, db.lineups, db.cacheMeta], async () => {
    await db.schedules.where('teamId').equals(teamId).delete();
    // Note: lineups are keyed by practiceId, so we'd need practice IDs to clear
    // For now, clear all lineups (acceptable on logout)
    await db.lineups.clear();
    // Clear relevant cache meta
    await db.cacheMeta.where('key').startsWith(`schedules:${teamId}`).delete();
  });
}
```

Key features:
- Transaction-based updates for consistency
- Replaces existing data rather than merging (simpler conflict resolution)
- Stores cachedAt for staleness UI
- Clears only data within cache window (preserves historical)
  </action>
  <verify>
- File exists at src/lib/db/cache-manager.ts
- TypeScript compiles: `npx tsc --noEmit src/lib/db/cache-manager.ts`
- Exports: cacheSchedules, cacheLineups, updateCacheMeta, getCacheMeta, isCacheExpired, clearTeamCache
  </verify>
  <done>
Cache manager created with functions to sync API data to IndexedDB
  </done>
</task>

<task type="auto">
  <name>Task 2: Create offline-aware data hook and staleness indicator</name>
  <files>
    - src/hooks/use-offline-data.ts
    - src/components/pwa/staleness-indicator.tsx
  </files>
  <action>
Create src/hooks/use-offline-data.ts:

```typescript
'use client';

import { useState, useEffect, useCallback } from 'react';
import { useOfflineSchedules, useCacheFreshness } from '@/lib/db/hooks';
import { cacheSchedules, getCacheMeta } from '@/lib/db/cache-manager';
import type { OfflineSchedule } from '@/lib/db/schema';

interface UseScheduleWithOfflineOptions {
  teamId: string | undefined;
  onlineEndpoint: string;
}

interface UseScheduleWithOfflineResult {
  schedules: OfflineSchedule[];
  isLoading: boolean;
  isOffline: boolean;
  lastUpdated: Date | null;
  isStale: boolean;
  error: Error | null;
  refresh: () => Promise<void>;
}

/**
 * Hook that fetches schedules online and falls back to offline cache
 * Automatically caches API responses for offline use
 */
export function useScheduleWithOffline({
  teamId,
  onlineEndpoint,
}: UseScheduleWithOfflineOptions): UseScheduleWithOfflineResult {
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const [isOffline, setIsOffline] = useState(false);

  // Reactive offline data
  const offlineSchedules = useOfflineSchedules(teamId);
  const { isStale, lastUpdated } = useCacheFreshness(
    teamId ? `schedules:${teamId}` : '',
    24 * 60 * 60 * 1000 // 24 hour stale threshold
  );

  const fetchAndCache = useCallback(async () => {
    if (!teamId) return;

    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(onlineEndpoint);

      if (!response.ok) {
        throw new Error(`Failed to fetch: ${response.status}`);
      }

      const data = await response.json();

      // Cache the response
      await cacheSchedules(teamId, data.practices || data);

      setIsOffline(false);
    } catch (err) {
      console.error('Failed to fetch schedules:', err);

      // Check if we're offline
      if (!navigator.onLine) {
        setIsOffline(true);
        // Don't set error - we'll show cached data
      } else {
        setError(err instanceof Error ? err : new Error('Unknown error'));
      }
    } finally {
      setIsLoading(false);
    }
  }, [teamId, onlineEndpoint]);

  // Initial fetch
  useEffect(() => {
    fetchAndCache();
  }, [fetchAndCache]);

  // Listen for online/offline events
  useEffect(() => {
    const handleOnline = () => {
      setIsOffline(false);
      fetchAndCache(); // Refresh when back online
    };

    const handleOffline = () => {
      setIsOffline(true);
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, [fetchAndCache]);

  return {
    schedules: offlineSchedules || [],
    isLoading: isLoading && offlineSchedules.length === 0,
    isOffline,
    lastUpdated,
    isStale,
    error: !isOffline ? error : null, // Don't show error if offline with cache
    refresh: fetchAndCache,
  };
}
```

Create src/components/pwa/staleness-indicator.tsx:

```typescript
'use client';

import { formatDistanceToNow } from 'date-fns';

interface StalenessIndicatorProps {
  lastUpdated: Date | null;
  isStale: boolean;
  isOffline: boolean;
  className?: string;
}

/**
 * Shows cache freshness with "Last updated X ago" and warning for stale data
 * Per CONTEXT.md: subtle indicator, not alarming
 */
export function StalenessIndicator({
  lastUpdated,
  isStale,
  isOffline,
  className = '',
}: StalenessIndicatorProps) {
  if (!lastUpdated && !isOffline) {
    return null;
  }

  const timeAgo = lastUpdated
    ? formatDistanceToNow(lastUpdated, { addSuffix: true })
    : 'never';

  return (
    <div className={`text-sm ${className}`}>
      {isOffline && (
        <span className="inline-flex items-center gap-1 text-amber-600">
          <OfflineIcon className="w-4 h-4" />
          Offline
        </span>
      )}
      {lastUpdated && (
        <span className={`${isStale ? 'text-amber-600' : 'text-gray-500'}`}>
          {isOffline ? ' - ' : ''}
          Last updated {timeAgo}
          {isStale && !isOffline && (
            <span className="ml-1 text-amber-600" title="Data may be outdated">
              (stale)
            </span>
          )}
        </span>
      )}
    </div>
  );
}

function OfflineIcon({ className }: { className?: string }) {
  return (
    <svg
      className={className}
      fill="none"
      stroke="currentColor"
      viewBox="0 0 24 24"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M18.364 5.636a9 9 0 010 12.728m0 0l-2.829-2.829m2.829 2.829L21 21M15.536 8.464a5 5 0 010 7.072m0 0l-2.829-2.829m-4.243 2.829a5 5 0 01-7.072 0M3 3l3.757 3.757m0 0a9 9 0 0110.486-2.15"
      />
    </svg>
  );
}
```
  </action>
  <verify>
- Both files compile without TypeScript errors
- Hook exports useScheduleWithOffline
- Component exports StalenessIndicator
  </verify>
  <done>
Offline-aware data hook and staleness indicator component created
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate offline data into schedule page</name>
  <files>
    - src/app/(dashboard)/[teamSlug]/schedule/page.tsx
  </files>
  <action>
Update src/app/(dashboard)/[teamSlug]/schedule/page.tsx to use offline data:

The schedule page exists at this path (verified in codebase). Update the existing page to use offline-aware data fetching.

The page should:

1. Import and use useScheduleWithOffline hook:
```typescript
import { useScheduleWithOffline } from '@/hooks/use-offline-data';
import { StalenessIndicator } from '@/components/pwa/staleness-indicator';
```

2. Replace direct API fetch with offline-aware hook:
```typescript
const {
  schedules,
  isLoading,
  isOffline,
  lastUpdated,
  isStale,
  error,
  refresh
} = useScheduleWithOffline({
  teamId: claims?.team_id,
  onlineEndpoint: '/api/schedule',
});
```

3. Add StalenessIndicator to the UI (subtle placement, perhaps in header):
```typescript
<StalenessIndicator
  lastUpdated={lastUpdated}
  isStale={isStale}
  isOffline={isOffline}
  className="ml-auto"
/>
```

4. Handle loading state that respects cached data:
```typescript
// Show loading spinner only if no cached data
if (isLoading && schedules.length === 0) {
  return <LoadingSpinner />;
}
```

5. Add manual refresh button for when user wants fresh data:
```typescript
<button onClick={refresh} disabled={isLoading || isOffline}>
  Refresh
</button>
```

Note: The schedule page uses Next.js 16 server components. You may need to create a client wrapper component for the offline-aware hooks, or convert sections that need the hook to client components.
  </action>
  <verify>
- Schedule page loads cached data when offline (test by going offline in DevTools)
- StalenessIndicator shows appropriate message
- Page works both online and offline
- `npm run build` succeeds
  </verify>
  <done>
Schedule page integrated with offline data support and staleness indicator
  </done>
</task>

</tasks>

<verification>
1. With browser online: Schedule loads from API and caches to IndexedDB
2. Go offline in DevTools (Network tab > Offline checkbox)
3. Refresh page - schedule still displays from cache
4. StalenessIndicator shows "Last updated X ago"
5. Wait 24+ hours (or mock) - "stale" indicator appears
6. Go back online - data refreshes automatically
</verification>

<success_criteria>
1. Schedule data cached to IndexedDB after API fetch
2. Offline mode displays cached schedule data
3. StalenessIndicator shows cache freshness (per CONTEXT.md: subtle, not alarming)
4. Athletes see next 2 weeks of schedule when offline
5. Automatic refresh when device comes back online
</success_criteria>

<output>
After completion, create `.planning/phases/04-pwa-infrastructure/04-03-SUMMARY.md`
</output>
