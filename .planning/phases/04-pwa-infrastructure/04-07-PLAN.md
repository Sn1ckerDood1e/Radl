---
phase: 04-pwa-infrastructure
plan: 07
type: execute
wave: 4
depends_on: ["04-01", "04-03"]
files_modified:
  - src/components/pwa/install-banner.tsx
  - src/components/pwa/offline-indicator.tsx
  - src/app/(dashboard)/layout.tsx
  - src/hooks/use-online-status.ts
autonomous: true

must_haves:
  truths:
    - "New users see install banner on first visit"
    - "Install banner is dismissible and doesn't nag"
    - "Offline failure shows clear message with retry"
    - "App shell loads instantly from cache"
  artifacts:
    - path: "src/components/pwa/install-banner.tsx"
      provides: "PWA install prompt component"
      exports: ["InstallBanner"]
    - path: "src/components/pwa/offline-indicator.tsx"
      provides: "Offline action failure component"
      exports: ["OfflineIndicator", "useOfflineAction"]
    - path: "src/hooks/use-online-status.ts"
      provides: "Hook for tracking online/offline status"
      exports: ["useOnlineStatus"]
  key_links:
    - from: "src/components/pwa/install-banner.tsx"
      to: "beforeinstallprompt"
      via: "window event listener"
      pattern: "beforeinstallprompt"
    - from: "src/app/(dashboard)/layout.tsx"
      to: "src/components/pwa/install-banner.tsx"
      via: "Component render"
      pattern: "InstallBanner"
---

<objective>
Implement install UX and offline failure handling

Purpose: Smooth PWA installation experience and clear offline feedback when actions fail
Output: Install banner, offline indicator, and online status tracking
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-pwa-infrastructure/04-CONTEXT.md
@.planning/phases/04-pwa-infrastructure/04-01-SUMMARY.md
@.planning/phases/04-pwa-infrastructure/04-03-SUMMARY.md

# Dashboard layout
@src/app/(dashboard)/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create online status hook and offline indicator</name>
  <files>
    - src/hooks/use-online-status.ts
    - src/components/pwa/offline-indicator.tsx
  </files>
  <action>
Create src/hooks/use-online-status.ts:

```typescript
'use client';

import { useState, useEffect, useCallback } from 'react';

/**
 * Hook for tracking online/offline status
 * Note: navigator.onLine can be unreliable - use in combination with fetch errors
 */
export function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(true);

  useEffect(() => {
    // Set initial state from navigator (if available)
    if (typeof navigator !== 'undefined') {
      setIsOnline(navigator.onLine);
    }

    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return isOnline;
}

/**
 * Hook for actions that need offline awareness
 * Shows offline indicator on failure, provides retry
 */
export function useOfflineAction() {
  const [offlineError, setOfflineError] = useState<{
    action: string;
    timestamp: number;
  } | null>(null);

  const isOnline = useOnlineStatus();

  const wrapAction = useCallback(async <T>(
    actionName: string,
    action: () => Promise<T>
  ): Promise<T | null> => {
    try {
      const result = await action();
      setOfflineError(null); // Clear any previous error
      return result;
    } catch (error: any) {
      // Check if this is a network/offline error
      if (
        !navigator.onLine ||
        error.name === 'TypeError' ||
        error.message?.includes('fetch') ||
        error.message?.includes('network')
      ) {
        setOfflineError({
          action: actionName,
          timestamp: Date.now(),
        });
        return null;
      }
      // Re-throw non-network errors
      throw error;
    }
  }, []);

  const clearError = useCallback(() => {
    setOfflineError(null);
  }, []);

  const retry = useCallback(async <T>(action: () => Promise<T>): Promise<T | null> => {
    if (!navigator.onLine) {
      return null;
    }
    setOfflineError(null);
    try {
      return await action();
    } catch (error) {
      // If retry also fails due to network, show error again
      if (!navigator.onLine) {
        setOfflineError({
          action: offlineError?.action || 'Action',
          timestamp: Date.now(),
        });
      }
      throw error;
    }
  }, [offlineError]);

  return {
    isOnline,
    offlineError,
    wrapAction,
    clearError,
    retry,
  };
}
```

Create src/components/pwa/offline-indicator.tsx:

```typescript
'use client';

import { useEffect, useState } from 'react';

interface OfflineIndicatorProps {
  failedAction: string;
  onRetry?: () => void;
  onDismiss?: () => void;
}

/**
 * Shows when an action fails due to being offline
 * Per CONTEXT.md: Only shown when action fails, not persistent banner
 */
export function OfflineIndicator({
  failedAction,
  onRetry,
  onDismiss,
}: OfflineIndicatorProps) {
  const [isOnline, setIsOnline] = useState(false);

  useEffect(() => {
    setIsOnline(navigator.onLine);

    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return (
    <div className="fixed bottom-4 left-4 right-4 md:left-auto md:right-4 md:w-96 bg-white border border-gray-200 rounded-lg shadow-lg p-4 z-50">
      <div className="flex items-start gap-3">
        <div className="flex-shrink-0">
          <svg
            className="w-5 h-5 text-amber-500"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
            />
          </svg>
        </div>
        <div className="flex-1">
          <h3 className="font-medium text-gray-900">You're offline</h3>
          <p className="text-sm text-gray-600 mt-1">
            Couldn't {failedAction}. {isOnline ? 'Connection restored - you can retry.' : 'Check your connection and try again.'}
          </p>
          <div className="flex gap-2 mt-3">
            {onRetry && (
              <button
                onClick={onRetry}
                disabled={!isOnline}
                className="text-sm font-medium text-blue-600 hover:text-blue-800 disabled:text-gray-400"
              >
                Retry
              </button>
            )}
            {onDismiss && (
              <button
                onClick={onDismiss}
                className="text-sm text-gray-500 hover:text-gray-700"
              >
                Dismiss
              </button>
            )}
          </div>
        </div>
        {onDismiss && (
          <button
            onClick={onDismiss}
            className="flex-shrink-0 text-gray-400 hover:text-gray-600"
          >
            <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
              <path
                fillRule="evenodd"
                d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                clipRule="evenodd"
              />
            </svg>
          </button>
        )}
      </div>
    </div>
  );
}

/**
 * Context provider for app-wide offline indicator
 */
import { createContext, useContext, ReactNode, useCallback, useState as useStateReact } from 'react';

interface OfflineContextValue {
  showOfflineError: (action: string, retryFn?: () => void) => void;
  hideOfflineError: () => void;
}

const OfflineContext = createContext<OfflineContextValue | null>(null);

export function OfflineProvider({ children }: { children: ReactNode }) {
  const [error, setError] = useStateReact<{
    action: string;
    retryFn?: () => void;
  } | null>(null);

  const showOfflineError = useCallback((action: string, retryFn?: () => void) => {
    setError({ action, retryFn });
  }, []);

  const hideOfflineError = useCallback(() => {
    setError(null);
  }, []);

  return (
    <OfflineContext.Provider value={{ showOfflineError, hideOfflineError }}>
      {children}
      {error && (
        <OfflineIndicator
          failedAction={error.action}
          onRetry={error.retryFn}
          onDismiss={hideOfflineError}
        />
      )}
    </OfflineContext.Provider>
  );
}

export function useOfflineContext() {
  const context = useContext(OfflineContext);
  if (!context) {
    throw new Error('useOfflineContext must be used within OfflineProvider');
  }
  return context;
}
```
  </action>
  <verify>
- Both files compile without errors
- useOnlineStatus tracks navigator.onLine and events
- OfflineIndicator shows action failure with retry option
- OfflineProvider context can be used app-wide
  </verify>
  <done>
Online status hook and offline indicator components created
  </done>
</task>

<task type="auto">
  <name>Task 2: Create install banner component</name>
  <files>
    - src/components/pwa/install-banner.tsx
  </files>
  <action>
Create src/components/pwa/install-banner.tsx:

```typescript
'use client';

import { useEffect, useState } from 'react';

interface BeforeInstallPromptEvent extends Event {
  prompt: () => Promise<void>;
  userChoice: Promise<{ outcome: 'accepted' | 'dismissed' }>;
}

const STORAGE_KEY = 'pwa-install-dismissed';

/**
 * PWA install banner
 * Per CONTEXT.md:
 * - Show on first visit for new users
 * - Dismissible, don't nag if declined
 * - Bottom sheet placement
 */
export function InstallBanner() {
  const [deferredPrompt, setDeferredPrompt] = useState<BeforeInstallPromptEvent | null>(null);
  const [showBanner, setShowBanner] = useState(false);
  const [isInstalling, setIsInstalling] = useState(false);

  useEffect(() => {
    // Check if already dismissed
    const dismissed = localStorage.getItem(STORAGE_KEY);
    if (dismissed) {
      return;
    }

    // Check if already installed (standalone mode)
    if (window.matchMedia('(display-mode: standalone)').matches) {
      return;
    }

    const handler = (e: Event) => {
      e.preventDefault();
      setDeferredPrompt(e as BeforeInstallPromptEvent);
      setShowBanner(true);
    };

    window.addEventListener('beforeinstallprompt', handler);

    // Also listen for successful install to hide banner
    window.addEventListener('appinstalled', () => {
      setShowBanner(false);
      setDeferredPrompt(null);
    });

    return () => {
      window.removeEventListener('beforeinstallprompt', handler);
    };
  }, []);

  const handleInstall = async () => {
    if (!deferredPrompt) return;

    setIsInstalling(true);

    try {
      await deferredPrompt.prompt();
      const { outcome } = await deferredPrompt.userChoice;

      if (outcome === 'accepted') {
        setShowBanner(false);
      } else {
        // User declined - dismiss but don't nag
        handleDismiss();
      }
    } finally {
      setIsInstalling(false);
      setDeferredPrompt(null);
    }
  };

  const handleDismiss = () => {
    // Store dismissal for 30 days
    const expiresAt = Date.now() + 30 * 24 * 60 * 60 * 1000;
    localStorage.setItem(STORAGE_KEY, expiresAt.toString());
    setShowBanner(false);
  };

  if (!showBanner) {
    return null;
  }

  return (
    <div className="fixed bottom-0 inset-x-0 z-50 p-4 pb-safe">
      <div className="bg-blue-600 text-white rounded-lg shadow-lg max-w-lg mx-auto">
        <div className="p-4">
          <div className="flex items-start gap-4">
            <div className="flex-shrink-0 w-12 h-12 bg-white rounded-lg flex items-center justify-center">
              <span className="text-blue-600 font-bold text-lg">RO</span>
            </div>
            <div className="flex-1 min-w-0">
              <h3 className="font-semibold text-lg">Install Radl</h3>
              <p className="text-blue-100 text-sm mt-0.5">
                Quick access to schedules, even offline
              </p>
            </div>
          </div>

          <div className="flex gap-3 mt-4">
            <button
              onClick={handleDismiss}
              className="flex-1 px-4 py-2 text-sm font-medium text-blue-100 hover:text-white transition-colors"
            >
              Not now
            </button>
            <button
              onClick={handleInstall}
              disabled={isInstalling}
              className="flex-1 px-4 py-2 text-sm font-medium bg-white text-blue-600 rounded-lg hover:bg-blue-50 transition-colors disabled:opacity-50"
            >
              {isInstalling ? 'Installing...' : 'Install'}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}
```

Key design decisions:
- Bottom sheet placement per CONTEXT.md
- Remembers dismissal for 30 days (not permanent, in case user changes mind)
- Checks for standalone mode to avoid showing to already-installed users
- Clean, non-intrusive design
  </action>
  <verify>
- Component compiles without errors
- Banner only shows when beforeinstallprompt fires
- Dismiss button stores preference in localStorage
- Install button triggers native install prompt
  </verify>
  <done>
Install banner component created with dismissible bottom sheet design
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate into dashboard layout</name>
  <files>
    - src/app/(dashboard)/layout.tsx
  </files>
  <action>
Update src/app/(dashboard)/layout.tsx to include PWA components:

1. Import components:
```typescript
import { InstallBanner } from '@/components/pwa/install-banner';
import { OfflineProvider } from '@/components/pwa/offline-indicator';
```

2. Wrap dashboard content with OfflineProvider and add InstallBanner:
```typescript
export default function DashboardLayout({ children }) {
  return (
    <OfflineProvider>
      <div className="min-h-screen">
        {/* Existing header, nav, etc. */}

        <main>
          {children}
        </main>

        {/* PWA components */}
        <InstallBanner />
      </div>
    </OfflineProvider>
  );
}
```

The InstallBanner only renders when beforeinstallprompt fires, so no performance impact when not applicable.

OfflineProvider enables any child component to trigger the offline indicator via useOfflineContext().
  </action>
  <verify>
- Dashboard layout compiles without errors
- InstallBanner appears on eligible browsers (Chrome on supported platforms)
- OfflineProvider context available throughout dashboard
- `npm run build` succeeds
  </verify>
  <done>
PWA components integrated into dashboard layout
  </done>
</task>

</tasks>

<verification>
1. Build and serve production: `npm run build && npm run start`
2. Open in Chrome (not incognito) - install banner should appear
3. Click "Not now" - banner disappears, doesn't return for 30 days
4. Clear localStorage, refresh - banner reappears
5. Click "Install" - native install prompt appears
6. After install, open app in standalone mode - banner doesn't show
7. Go offline, try to perform an action that fetches - offline indicator appears
8. Come back online - retry button becomes active
</verification>

<success_criteria>
1. Install banner shows on first visit in eligible browsers
2. Dismissal is remembered (doesn't nag)
3. Native install prompt triggered on "Install" click
4. Offline action failures show clear indicator
5. Indicator includes failed action description and retry option
6. App shell loads instantly from service worker cache
</success_criteria>

<output>
After completion, create `.planning/phases/04-pwa-infrastructure/04-07-SUMMARY.md`
</output>
