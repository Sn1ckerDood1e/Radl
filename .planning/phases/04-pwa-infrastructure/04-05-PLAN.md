---
phase: 04-pwa-infrastructure
plan: 05
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - src/lib/db/offline-mutations.ts
  - src/hooks/use-offline-mutation.ts
  - src/components/pwa/sync-status.tsx
  - src/app/sw.ts
autonomous: true

must_haves:
  truths:
    - "Coach can save changes when offline"
    - "Changes are queued and sync when back online"
    - "User sees sync status indicator when items pending"
    - "Sync failures are handled gracefully with retry"
  artifacts:
    - path: "src/lib/db/offline-mutations.ts"
      provides: "Functions for queueing and executing offline mutations"
      exports: ["createOfflineMutation", "executeWithOfflineFallback"]
    - path: "src/hooks/use-offline-mutation.ts"
      provides: "React hook for offline-aware mutations"
      exports: ["useOfflineMutation"]
    - path: "src/components/pwa/sync-status.tsx"
      provides: "UI showing pending sync count"
      exports: ["SyncStatus"]
  key_links:
    - from: "src/hooks/use-offline-mutation.ts"
      to: "src/lib/db/sync-queue.ts"
      via: "queueMutation for offline storage"
      pattern: "queueMutation"
    - from: "src/components/pwa/sync-status.tsx"
      to: "src/lib/db/hooks.ts"
      via: "useSyncQueueCount for pending count"
      pattern: "useSyncQueueCount"
---

<objective>
Implement background sync queue for offline mutations

Purpose: Coaches can make changes offline that sync automatically when reconnected
Output: Offline mutation system with queue, retry logic, and sync status UI
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-pwa-infrastructure/04-CONTEXT.md
@.planning/phases/04-pwa-infrastructure/04-02-SUMMARY.md
@.planning/phases/04-pwa-infrastructure/04-03-SUMMARY.md

# Existing sync queue
@src/lib/db/sync-queue.ts
@src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create offline mutation utilities</name>
  <files>
    - src/lib/db/offline-mutations.ts
  </files>
  <action>
Create src/lib/db/offline-mutations.ts with mutation helpers:

```typescript
import { db, OfflineSchedule, OfflineLineup } from './schema';
import { queueMutation, processSyncQueue } from './sync-queue';

/**
 * Create an offline mutation that:
 * 1. Updates local IndexedDB immediately (optimistic update)
 * 2. Queues the change for sync
 * 3. Attempts immediate sync if online
 */
export async function createOfflineMutation<T>(
  options: {
    operation: 'create' | 'update' | 'delete';
    entity: 'practice' | 'lineup' | 'assignment';
    entityId: string;
    payload: T;
    optimisticUpdate?: () => Promise<void>;
    rollback?: () => Promise<void>;
  }
): Promise<{ queued: boolean; synced: boolean }> {
  const { operation, entity, entityId, payload, optimisticUpdate, rollback } = options;

  try {
    // Apply optimistic update to local storage
    if (optimisticUpdate) {
      await optimisticUpdate();
    }

    // Queue for background sync
    await queueMutation(operation, entity, entityId, payload);

    // Try immediate sync if online
    if (navigator.onLine) {
      try {
        const result = await processSyncQueue();
        return { queued: true, synced: result.processed > 0 };
      } catch (syncError) {
        console.warn('Immediate sync failed, will retry:', syncError);
        return { queued: true, synced: false };
      }
    }

    return { queued: true, synced: false };
  } catch (error) {
    // Rollback optimistic update on failure
    if (rollback) {
      try {
        await rollback();
      } catch (rollbackError) {
        console.error('Rollback failed:', rollbackError);
      }
    }
    throw error;
  }
}

/**
 * Execute a mutation with offline fallback
 * Tries online first, falls back to queue if offline
 */
export async function executeWithOfflineFallback<T, R>(
  options: {
    // Online execution
    onlineAction: () => Promise<R>;
    // Offline queue params
    entity: 'practice' | 'lineup' | 'assignment';
    operation: 'create' | 'update' | 'delete';
    entityId: string;
    payload: T;
    // Optimistic update
    optimisticUpdate?: () => Promise<void>;
    rollback?: () => Promise<void>;
  }
): Promise<{ result: R | null; mode: 'online' | 'offline' }> {
  const {
    onlineAction,
    entity,
    operation,
    entityId,
    payload,
    optimisticUpdate,
    rollback
  } = options;

  // Apply optimistic update first
  if (optimisticUpdate) {
    await optimisticUpdate();
  }

  // Try online action
  if (navigator.onLine) {
    try {
      const result = await onlineAction();
      return { result, mode: 'online' };
    } catch (error: any) {
      // Network error - fall through to offline
      if (error.name === 'TypeError' || error.message?.includes('fetch')) {
        console.log('Network error, falling back to offline queue');
      } else {
        // Server error - rollback and throw
        if (rollback) await rollback();
        throw error;
      }
    }
  }

  // Offline - queue the mutation
  await queueMutation(operation, entity, entityId, payload);
  return { result: null, mode: 'offline' };
}

/**
 * Update a schedule in local storage (optimistic)
 */
export async function updateLocalSchedule(
  scheduleId: string,
  updates: Partial<OfflineSchedule>
): Promise<void> {
  await db.schedules.update(scheduleId, {
    ...updates,
    syncStatus: 'pending',
  });
}

/**
 * Delete a schedule from local storage (optimistic)
 */
export async function deleteLocalSchedule(scheduleId: string): Promise<void> {
  await db.schedules.delete(scheduleId);
}

/**
 * Update a lineup in local storage (optimistic)
 */
export async function updateLocalLineup(
  lineupId: string,
  updates: Partial<OfflineLineup>
): Promise<void> {
  await db.lineups.update(lineupId, {
    ...updates,
    syncStatus: 'pending',
  });
}
```
  </action>
  <verify>
- File compiles: `npx tsc --noEmit src/lib/db/offline-mutations.ts`
- Exports: createOfflineMutation, executeWithOfflineFallback, updateLocalSchedule, deleteLocalSchedule, updateLocalLineup
  </verify>
  <done>
Offline mutation utilities created with optimistic updates and queue fallback
  </done>
</task>

<task type="auto">
  <name>Task 2: Create React hook for offline-aware mutations</name>
  <files>
    - src/hooks/use-offline-mutation.ts
  </files>
  <action>
Create src/hooks/use-offline-mutation.ts:

```typescript
'use client';

import { useState, useCallback } from 'react';
import { executeWithOfflineFallback } from '@/lib/db/offline-mutations';

interface UseOfflineMutationOptions<T, R> {
  // The online API call
  mutationFn: (payload: T) => Promise<R>;
  // Entity info for offline queue
  entity: 'practice' | 'lineup' | 'assignment';
  operation: 'create' | 'update' | 'delete';
  // Get entity ID from payload (for update/delete)
  getEntityId: (payload: T) => string;
  // Optimistic update (optional)
  onOptimisticUpdate?: (payload: T) => Promise<void>;
  // Rollback on failure (optional)
  onRollback?: (payload: T) => Promise<void>;
  // Callbacks
  onSuccess?: (result: R | null, mode: 'online' | 'offline') => void;
  onError?: (error: Error) => void;
}

interface UseOfflineMutationResult<T> {
  mutate: (payload: T) => Promise<void>;
  isLoading: boolean;
  isOffline: boolean;
  error: Error | null;
  reset: () => void;
}

/**
 * Hook for mutations that work offline
 * Tries online first, queues for background sync if offline
 */
export function useOfflineMutation<T, R = unknown>(
  options: UseOfflineMutationOptions<T, R>
): UseOfflineMutationResult<T> {
  const [isLoading, setIsLoading] = useState(false);
  const [isOffline, setIsOffline] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const {
    mutationFn,
    entity,
    operation,
    getEntityId,
    onOptimisticUpdate,
    onRollback,
    onSuccess,
    onError,
  } = options;

  const mutate = useCallback(async (payload: T) => {
    setIsLoading(true);
    setError(null);
    setIsOffline(false);

    try {
      const { result, mode } = await executeWithOfflineFallback({
        onlineAction: () => mutationFn(payload),
        entity,
        operation,
        entityId: getEntityId(payload),
        payload,
        optimisticUpdate: onOptimisticUpdate
          ? () => onOptimisticUpdate(payload)
          : undefined,
        rollback: onRollback
          ? () => onRollback(payload)
          : undefined,
      });

      if (mode === 'offline') {
        setIsOffline(true);
      }

      onSuccess?.(result, mode);
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error');
      setError(error);
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  }, [
    mutationFn,
    entity,
    operation,
    getEntityId,
    onOptimisticUpdate,
    onRollback,
    onSuccess,
    onError
  ]);

  const reset = useCallback(() => {
    setIsLoading(false);
    setIsOffline(false);
    setError(null);
  }, []);

  return {
    mutate,
    isLoading,
    isOffline,
    error,
    reset,
  };
}

/**
 * Simplified hook for delete operations
 */
export function useOfflineDelete(
  entity: 'practice' | 'lineup' | 'assignment',
  deleteFn: (id: string) => Promise<void>,
  options?: {
    onOptimisticDelete?: (id: string) => Promise<void>;
    onSuccess?: () => void;
    onError?: (error: Error) => void;
  }
) {
  return useOfflineMutation<string, void>({
    mutationFn: deleteFn,
    entity,
    operation: 'delete',
    getEntityId: (id) => id,
    onOptimisticUpdate: options?.onOptimisticDelete,
    onSuccess: options?.onSuccess,
    onError: options?.onError,
  });
}
```
  </action>
  <verify>
- File compiles: `npx tsc --noEmit src/hooks/use-offline-mutation.ts`
- Exports: useOfflineMutation, useOfflineDelete
  </verify>
  <done>
React hooks for offline-aware mutations created
  </done>
</task>

<task type="auto">
  <name>Task 3: Create sync status component and integrate</name>
  <files>
    - src/components/pwa/sync-status.tsx
    - src/app/(dashboard)/layout.tsx
  </files>
  <action>
Create src/components/pwa/sync-status.tsx:

```typescript
'use client';

import { useSyncQueueCount } from '@/lib/db/hooks';
import { processSyncQueue } from '@/lib/db/sync-queue';
import { useState } from 'react';

interface SyncStatusProps {
  className?: string;
}

/**
 * Shows sync queue status with pending count and manual sync button
 * Only visible when there are pending items
 */
export function SyncStatus({ className = '' }: SyncStatusProps) {
  const pendingCount = useSyncQueueCount();
  const [isSyncing, setIsSyncing] = useState(false);

  if (pendingCount === 0) {
    return null;
  }

  const handleSync = async () => {
    if (isSyncing || !navigator.onLine) return;

    setIsSyncing(true);
    try {
      await processSyncQueue();
    } catch (error) {
      console.error('Manual sync failed:', error);
    } finally {
      setIsSyncing(false);
    }
  };

  const isOnline = typeof navigator !== 'undefined' && navigator.onLine;

  return (
    <div className={`flex items-center gap-2 text-sm ${className}`}>
      <span className="inline-flex items-center gap-1.5">
        <span className="relative flex h-2 w-2">
          <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-amber-400 opacity-75"></span>
          <span className="relative inline-flex rounded-full h-2 w-2 bg-amber-500"></span>
        </span>
        <span className="text-amber-700">
          {pendingCount} pending {pendingCount === 1 ? 'change' : 'changes'}
        </span>
      </span>

      {isOnline && (
        <button
          onClick={handleSync}
          disabled={isSyncing}
          className="text-blue-600 hover:text-blue-800 disabled:text-gray-400"
        >
          {isSyncing ? 'Syncing...' : 'Sync now'}
        </button>
      )}

      {!isOnline && (
        <span className="text-gray-500">
          (waiting for connection)
        </span>
      )}
    </div>
  );
}

/**
 * Compact version for header placement
 */
export function SyncStatusBadge() {
  const pendingCount = useSyncQueueCount();

  if (pendingCount === 0) {
    return null;
  }

  return (
    <span
      className="inline-flex items-center justify-center w-5 h-5 text-xs font-medium text-white bg-amber-500 rounded-full"
      title={`${pendingCount} pending changes`}
    >
      {pendingCount > 9 ? '9+' : pendingCount}
    </span>
  );
}
```

Update src/app/(dashboard)/layout.tsx to include SyncStatus:

1. Import SyncStatus component
2. Add to header area (near user info or in a subtle location)

```typescript
import { SyncStatus } from '@/components/pwa/sync-status';

// In the layout JSX, add near the header
<SyncStatus className="mr-4" />
```

The component only renders when there are pending items, so it won't clutter the UI during normal use.
  </action>
  <verify>
- Components compile without errors
- SyncStatus only shows when pendingCount > 0
- SyncStatusBadge provides compact alternative
- Dashboard layout includes sync status
  </verify>
  <done>
Sync status UI component created and integrated into dashboard layout
  </done>
</task>

</tasks>

<verification>
1. Make a mutation when online - syncs immediately
2. Go offline (DevTools Network > Offline)
3. Make a mutation - SyncStatus shows "1 pending change"
4. Go back online - change syncs automatically
5. SyncStatus disappears when queue is empty
6. Manual "Sync now" button works when online
</verification>

<success_criteria>
1. Mutations queue when offline with optimistic local updates
2. Queued changes sync automatically when back online
3. SyncStatus component shows pending count
4. Manual sync option available for users
5. Graceful handling of sync failures with retry
</success_criteria>

<output>
After completion, create `.planning/phases/04-pwa-infrastructure/04-05-SUMMARY.md`
</output>
