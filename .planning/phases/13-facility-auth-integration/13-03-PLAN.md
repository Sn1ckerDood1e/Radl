---
phase: 13-facility-auth-integration
plan: 03
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/lib/auth/claims.ts
  - src/lib/auth/context-validator.ts
autonomous: true

must_haves:
  truths:
    - "Invalid club cookie auto-selects first available club in user's memberships"
    - "Invalid facility cookie auto-detects facility from user's clubs"
    - "User with no memberships redirects to onboarding (not crash)"
    - "Last used context restored on login"
  artifacts:
    - path: "src/lib/auth/context-validator.ts"
      provides: "Context validation and auto-recovery logic"
      exports: ["validateAndRecoverContext", "restoreLastContext"]
    - path: "src/lib/auth/claims.ts"
      provides: "getClaimsForApiRoute calling context validator"
  key_links:
    - from: "src/lib/auth/claims.ts"
      to: "src/lib/auth/context-validator.ts"
      via: "validateAndRecoverContext call"
      pattern: "validateAndRecoverContext"
    - from: "src/lib/auth/context-validator.ts"
      to: "src/lib/auth/club-context.ts"
      via: "Cookie setters"
      pattern: "setCurrentClubId|setCurrentFacilityId"
---

<objective>
Implement context validation with automatic recovery for invalid cookies and login restoration.

Purpose: Prevent crashes when user's club/facility cookie points to membership they no longer have. Auto-select first available context. Restore last used context on login for continuity.

Output: Context validator module and integration with claims helper.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/13-facility-auth-integration/13-CONTEXT.md
@.planning/phases/13-facility-auth-integration/13-RESEARCH.md
@.planning/phases/13-facility-auth-integration/13-01-SUMMARY.md

@src/lib/auth/claims.ts
@src/lib/auth/club-context.ts
@src/lib/auth/facility-context.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create context validator module</name>
  <files>src/lib/auth/context-validator.ts</files>
  <action>
Create new module at `src/lib/auth/context-validator.ts`:

```typescript
import { prisma } from '@/lib/prisma';
import { getCurrentClubId, setCurrentClubId, clearCurrentClubId } from './club-context';
import { getCurrentFacilityId, setCurrentFacilityId, clearCurrentFacilityId } from './facility-context';

export interface ValidatedContext {
  facilityId: string | null;
  clubId: string | null;
  wasRecovered: boolean;  // True if context was auto-corrected
}

/**
 * Validates current context cookies against user's actual memberships.
 * Auto-recovers invalid context by selecting first available membership.
 *
 * Recovery precedence:
 * 1. If clubId cookie invalid -> select first active ClubMembership
 * 2. If facilityId cookie invalid -> detect from validated club
 * 3. If no memberships at all -> return null (caller should redirect to onboarding)
 */
export async function validateAndRecoverContext(userId: string): Promise<ValidatedContext> {
  const currentClubId = await getCurrentClubId();
  const currentFacilityId = await getCurrentFacilityId();

  let validClubId: string | null = null;
  let validFacilityId: string | null = null;
  let wasRecovered = false;

  // Step 1: Validate clubId cookie
  if (currentClubId) {
    const membership = await prisma.clubMembership.findFirst({
      where: {
        clubId: currentClubId,
        userId,
        isActive: true,
      },
      include: {
        club: { select: { id: true, facilityId: true } },
      },
    });

    if (membership) {
      // Club is valid
      validClubId = currentClubId;
      validFacilityId = membership.club.facilityId;
    } else {
      // Club is invalid - need recovery
      wasRecovered = true;
      console.warn(`Invalid club cookie ${currentClubId} for user ${userId}, recovering...`);
    }
  }

  // Step 2: If no valid club, find first available
  if (!validClubId) {
    const firstMembership = await prisma.clubMembership.findFirst({
      where: {
        userId,
        isActive: true,
      },
      orderBy: { createdAt: 'asc' },
      include: {
        club: { select: { id: true, facilityId: true } },
      },
    });

    if (firstMembership) {
      validClubId = firstMembership.clubId;
      validFacilityId = firstMembership.club.facilityId;
      wasRecovered = true;
    }
  }

  // Step 3: Validate facilityId (if we have one from club lookup)
  if (validFacilityId && currentFacilityId !== validFacilityId) {
    // Facility cookie doesn't match club's facility - update it
    wasRecovered = true;
  }

  // Step 4: Update cookies if recovery happened
  if (wasRecovered) {
    if (validClubId) {
      await setCurrentClubId(validClubId);
    } else {
      await clearCurrentClubId();
    }

    if (validFacilityId) {
      await setCurrentFacilityId(validFacilityId);
    } else {
      await clearCurrentFacilityId();
    }
  }

  return {
    facilityId: validFacilityId,
    clubId: validClubId,
    wasRecovered,
  };
}

/**
 * Restores user's last used context on login.
 * Called after successful authentication.
 *
 * If cookies exist and valid, keep them (user returns to where they left off).
 * If cookies missing, auto-detect from first membership.
 */
export async function restoreLastContext(userId: string): Promise<ValidatedContext> {
  // Just run validation - it handles both "keep valid" and "auto-select" cases
  return validateAndRecoverContext(userId);
}
```

This module handles:
- Invalid club cookie -> auto-select first membership
- Facility/club mismatch -> sync facility to club's facility
- No memberships -> return null (onboarding needed)
- Login restoration -> validate existing cookies or auto-select
  </action>
  <verify>
File exists: `ls -la src/lib/auth/context-validator.ts`
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
Context validator provides:
- validateAndRecoverContext() for invalid cookie recovery
- restoreLastContext() for login continuity
- wasRecovered flag for logging/debugging
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate validator into claims helper</name>
  <files>src/lib/auth/claims.ts</files>
  <action>
Update getClaimsForApiRoute to call context validator early in the flow:

After user authentication succeeds and before getting club/facility from cookies:

```typescript
import { validateAndRecoverContext } from './context-validator';

// ... after user is authenticated ...

// Validate and recover context if needed
const { facilityId: validFacilityId, clubId: validClubId, wasRecovered } =
  await validateAndRecoverContext(user.id);

if (wasRecovered) {
  console.log(`Context recovered for user ${user.id}: facility=${validFacilityId}, club=${validClubId}`);
}

// Use validated values instead of raw cookie reads
// Replace: const clubId = await getCurrentClubId();
// With: use validClubId from above

// The rest of the function continues with validated context
```

This ensures:
- Claims always reflect valid membership state
- Invalid cookies are corrected before permission checks
- Roles are fetched for validated club (not stale cookie value)

IMPORTANT: Keep the existing database fallbacks for legacy TeamMember support. The validator only handles ClubMembership path.
  </action>
  <verify>
grep shows validator integration: `grep -n "validateAndRecoverContext" src/lib/auth/claims.ts`
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
getClaimsForApiRoute calls validator:
- Invalid cookies auto-corrected before returning claims
- Roles fetched for validated club
- Console warning logged on recovery
  </done>
</task>

</tasks>

<verification>
- [ ] context-validator.ts created with validateAndRecoverContext and restoreLastContext
- [ ] Claims helper imports and calls validateAndRecoverContext
- [ ] Invalid club cookie results in auto-selection of first membership
- [ ] Recovery updates both facility and club cookies
- [ ] TypeScript compiles without errors
</verification>

<success_criteria>
Context validation provides graceful fallback:
1. Invalid cookies don't cause crashes or permission errors
2. User auto-lands in valid context
3. Login restores last used context when valid
4. No memberships case handled (null returned for onboarding redirect)
</success_criteria>

<output>
After completion, create `.planning/phases/13-facility-auth-integration/13-03-SUMMARY.md`
</output>
