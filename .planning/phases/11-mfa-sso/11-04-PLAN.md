---
phase: 11-mfa-sso
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/auth/permission-grant.ts
  - src/lib/validations/permission-grant.ts
autonomous: true

must_haves:
  truths:
    - "System can create time-bounded permission grants"
    - "System can revoke permission grants before expiration"
    - "System can check if user has active grants"
  artifacts:
    - path: "src/lib/auth/permission-grant.ts"
      provides: "Permission grant helper functions"
      exports: ["createGrant", "revokeGrant", "getActiveGrants", "getUserEffectiveRoles"]
    - path: "src/lib/validations/permission-grant.ts"
      provides: "Permission grant validation schemas"
      exports: ["createGrantSchema", "grantDurations"]
  key_links:
    - from: "src/lib/auth/permission-grant.ts"
      to: "prisma.permissionGrant"
      via: "Database operations"
      pattern: "prisma\\.permissionGrant"
    - from: "src/lib/permissions/ability.ts"
      to: "src/lib/auth/permission-grant.ts"
      via: "Effective roles lookup"
      pattern: "getUserEffectiveRoles"
---

<objective>
Create permission grant helper functions for temporary elevated access.

Purpose: Enable facility admins to grant temporary elevated roles (e.g., coach covering for admin) with automatic expiration. Grants integrate with existing CASL ability system.

Output: Permission grant utilities and validation schemas ready for API and ability integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-mfa-sso/11-CONTEXT.md
@.planning/phases/11-mfa-sso/11-RESEARCH.md
@src/lib/prisma.ts
@src/lib/permissions/ability.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create permission grant validation schemas</name>
  <files>src/lib/validations/permission-grant.ts</files>
  <action>
Create validation schemas and duration presets for permission grants:

```typescript
import { z } from 'zod';

/**
 * Preset durations for temporary access grants.
 * Per CONTEXT.md: "time-based with preset durations"
 */
export const grantDurations = {
  '1_day': { label: '1 day', hours: 24 },
  '3_days': { label: '3 days', hours: 72 },
  '1_week': { label: '1 week', hours: 168 },
  '2_weeks': { label: '2 weeks', hours: 336 },
  '1_month': { label: '1 month', hours: 720 },
} as const;

export type GrantDuration = keyof typeof grantDurations;

/**
 * Valid roles that can be granted temporarily
 */
const grantableRoles = ['CLUB_ADMIN', 'COACH'] as const;

/**
 * Schema for creating a permission grant
 */
export const createGrantSchema = z.object({
  clubId: z.string().uuid(),
  userId: z.string().uuid(),  // Who receives the grant
  roles: z.array(z.enum(grantableRoles)).min(1),
  duration: z.enum(['1_day', '3_days', '1_week', '2_weeks', '1_month']),
  reason: z.string().min(1).max(500).optional(),
});

/**
 * Schema for revoking a grant
 */
export const revokeGrantSchema = z.object({
  grantId: z.string().uuid(),
});

export type CreateGrantInput = z.infer<typeof createGrantSchema>;
export type RevokeGrantInput = z.infer<typeof revokeGrantSchema>;
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>Permission grant validation schemas created with preset durations</done>
</task>

<task type="auto">
  <name>Task 2: Create permission grant helper functions</name>
  <files>src/lib/auth/permission-grant.ts</files>
  <action>
Create permission grant helper functions:

```typescript
import { prisma } from '@/lib/prisma';
import type { Role } from '@/generated/prisma';
import { grantDurations, type GrantDuration } from '@/lib/validations/permission-grant';

/**
 * Permission grant with user details
 */
export interface PermissionGrantWithDetails {
  id: string;
  clubId: string;
  userId: string;
  grantedBy: string;
  roles: Role[];
  reason: string | null;
  expiresAt: Date;
  revokedAt: Date | null;
  notifiedAt: Date | null;
  createdAt: Date;
}

/**
 * Create a new temporary permission grant.
 *
 * @param params - Grant parameters
 * @returns Created grant
 */
export async function createGrant(params: {
  clubId: string;
  userId: string;
  grantedBy: string;
  roles: Role[];
  duration: GrantDuration;
  reason?: string;
}): Promise<PermissionGrantWithDetails> {
  const { clubId, userId, grantedBy, roles, duration, reason } = params;

  const durationConfig = grantDurations[duration];
  const expiresAt = new Date(Date.now() + durationConfig.hours * 60 * 60 * 1000);

  const grant = await prisma.permissionGrant.create({
    data: {
      clubId,
      userId,
      grantedBy,
      roles,
      reason,
      expiresAt,
    },
  });

  return grant as PermissionGrantWithDetails;
}

/**
 * Revoke a permission grant before expiration.
 *
 * @param grantId - Grant ID to revoke
 * @param revokedBy - User ID who is revoking
 * @returns Updated grant
 */
export async function revokeGrant(
  grantId: string,
  revokedBy: string
): Promise<PermissionGrantWithDetails> {
  const grant = await prisma.permissionGrant.update({
    where: { id: grantId },
    data: { revokedAt: new Date() },
  });

  return grant as PermissionGrantWithDetails;
}

/**
 * Get active (non-expired, non-revoked) grants for a user in a club.
 *
 * @param userId - User ID
 * @param clubId - Club ID
 * @returns Active grants
 */
export async function getActiveGrants(
  userId: string,
  clubId: string
): Promise<PermissionGrantWithDetails[]> {
  const grants = await prisma.permissionGrant.findMany({
    where: {
      userId,
      clubId,
      expiresAt: { gt: new Date() },
      revokedAt: null,
    },
    orderBy: { expiresAt: 'asc' },
  });

  return grants as PermissionGrantWithDetails[];
}

/**
 * Get all grants in a club (for admin listing).
 *
 * @param clubId - Club ID
 * @param includeExpired - Include expired grants
 * @returns Grants list
 */
export async function getClubGrants(
  clubId: string,
  includeExpired = false
): Promise<PermissionGrantWithDetails[]> {
  const where = includeExpired
    ? { clubId }
    : {
        clubId,
        expiresAt: { gt: new Date() },
        revokedAt: null,
      };

  const grants = await prisma.permissionGrant.findMany({
    where,
    orderBy: { createdAt: 'desc' },
  });

  return grants as PermissionGrantWithDetails[];
}

/**
 * Get user's effective roles including temporary grants.
 * This should be used by the ability builder to include granted roles.
 *
 * @param userId - User ID
 * @param clubId - Club ID
 * @param baseRoles - Roles from ClubMembership
 * @returns Combined roles array
 */
export async function getUserEffectiveRoles(
  userId: string,
  clubId: string,
  baseRoles: Role[]
): Promise<Role[]> {
  const grants = await getActiveGrants(userId, clubId);

  if (grants.length === 0) {
    return baseRoles;
  }

  // Merge granted roles with base roles
  const grantedRoles = grants.flatMap(g => g.roles);
  return [...new Set([...baseRoles, ...grantedRoles])];
}

/**
 * Check if user has a specific role via grant (not base membership).
 *
 * @param userId - User ID
 * @param clubId - Club ID
 * @param role - Role to check
 * @returns True if role is granted via temporary grant
 */
export async function hasGrantedRole(
  userId: string,
  clubId: string,
  role: Role
): Promise<boolean> {
  const grant = await prisma.permissionGrant.findFirst({
    where: {
      userId,
      clubId,
      roles: { has: role },
      expiresAt: { gt: new Date() },
      revokedAt: null,
    },
  });

  return grant !== null;
}

/**
 * Get grants that are about to expire (for notification job).
 *
 * @param withinHours - Hours until expiration
 * @returns Grants expiring soon that haven't been notified
 */
export async function getExpiringGrants(
  withinHours: number
): Promise<PermissionGrantWithDetails[]> {
  const now = new Date();
  const threshold = new Date(now.getTime() + withinHours * 60 * 60 * 1000);

  const grants = await prisma.permissionGrant.findMany({
    where: {
      expiresAt: {
        gt: now,
        lte: threshold,
      },
      revokedAt: null,
      notifiedAt: null,
    },
  });

  return grants as PermissionGrantWithDetails[];
}

/**
 * Mark grant as notified (expiration warning sent).
 *
 * @param grantId - Grant ID
 */
export async function markGrantNotified(grantId: string): Promise<void> {
  await prisma.permissionGrant.update({
    where: { id: grantId },
    data: { notifiedAt: new Date() },
  });
}

/**
 * Get expired grants that need to be processed (soft-revoked).
 *
 * @returns Expired grants that haven't been revoked yet
 */
export async function getExpiredGrants(): Promise<PermissionGrantWithDetails[]> {
  const grants = await prisma.permissionGrant.findMany({
    where: {
      expiresAt: { lt: new Date() },
      revokedAt: null,
    },
  });

  return grants as PermissionGrantWithDetails[];
}

/**
 * Bulk soft-revoke expired grants.
 *
 * @param grantIds - Grant IDs to revoke
 * @returns Count of updated grants
 */
export async function bulkRevokeExpiredGrants(
  grantIds: string[]
): Promise<number> {
  const result = await prisma.permissionGrant.updateMany({
    where: { id: { in: grantIds } },
    data: { revokedAt: new Date() },
  });

  return result.count;
}
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>Permission grant helper functions created with full lifecycle management</done>
</task>

</tasks>

<verification>
1. All TypeScript files compile without errors
2. Functions properly type PermissionGrant from Prisma
3. `getUserEffectiveRoles` correctly merges base and granted roles
</verification>

<success_criteria>
- `createGrant` creates grants with calculated expiration from duration preset
- `revokeGrant` soft-revokes grants before expiration
- `getActiveGrants` returns only non-expired, non-revoked grants
- `getUserEffectiveRoles` merges base roles with granted roles
- Expiration helpers support cron job processing
</success_criteria>

<output>
After completion, create `.planning/phases/11-mfa-sso/11-04-SUMMARY.md`
</output>
