---
phase: 11-mfa-sso
plan: 03
type: execute
wave: 2
depends_on: ["11-01", "11-02"]
files_modified:
  - src/app/api/mfa/enroll/route.ts
  - src/app/api/mfa/verify/route.ts
  - src/app/api/mfa/factors/route.ts
  - src/app/api/mfa/unenroll/route.ts
  - src/app/api/mfa/backup-codes/route.ts
  - src/lib/audit/actions.ts
autonomous: true

must_haves:
  truths:
    - "User can enroll in MFA via API"
    - "User can verify MFA code via API"
    - "User can list and remove MFA factors via API"
    - "User can regenerate backup codes via API"
    - "All MFA operations are audit logged"
  artifacts:
    - path: "src/app/api/mfa/enroll/route.ts"
      provides: "MFA enrollment endpoint"
      exports: ["POST"]
    - path: "src/app/api/mfa/verify/route.ts"
      provides: "MFA verification endpoint"
      exports: ["POST"]
    - path: "src/app/api/mfa/factors/route.ts"
      provides: "MFA factors listing"
      exports: ["GET"]
    - path: "src/app/api/mfa/unenroll/route.ts"
      provides: "MFA unenrollment endpoint"
      exports: ["POST"]
    - path: "src/app/api/mfa/backup-codes/route.ts"
      provides: "Backup codes endpoint"
      exports: ["GET", "POST"]
  key_links:
    - from: "src/app/api/mfa/enroll/route.ts"
      to: "src/lib/auth/mfa.ts"
      via: "enrollMfa function"
      pattern: "import.*enrollMfa"
    - from: "src/app/api/mfa/*"
      to: "src/lib/audit/logger.ts"
      via: "Audit logging"
      pattern: "logAuditEvent|createAuditLogger"
---

<objective>
Create MFA API endpoints for enrollment, verification, factor management, and backup codes.

Purpose: Expose MFA functionality to frontend with proper authentication, validation, and audit logging.

Output: Complete MFA API surface ready for UI consumption.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-mfa-sso/11-CONTEXT.md
@.planning/phases/11-mfa-sso/11-RESEARCH.md
@src/lib/auth/mfa.ts
@src/lib/auth/claims.ts
@src/lib/audit/logger.ts
@src/lib/audit/actions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MFA audit actions</name>
  <files>src/lib/audit/actions.ts</files>
  <action>
Add new audit action types for MFA operations to the existing AUDITABLE_ACTIONS array:

```typescript
// Add these to the AUDITABLE_ACTIONS array:
{
  action: 'MFA_ENROLLED',
  description: 'User enrolled in multi-factor authentication',
},
{
  action: 'MFA_VERIFIED',
  description: 'User verified MFA code successfully',
},
{
  action: 'MFA_UNENROLLED',
  description: 'User removed multi-factor authentication',
},
{
  action: 'MFA_BACKUP_CODES_REGENERATED',
  description: 'User regenerated MFA backup codes',
},
{
  action: 'MFA_BACKUP_CODE_USED',
  description: 'User used MFA backup code for recovery',
},
{
  action: 'MFA_RESET_BY_ADMIN',
  description: 'Admin reset user MFA settings',
},
```

Also add the corresponding AuditAction type union members if using a type for actions.
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>MFA audit actions added to logging infrastructure</done>
</task>

<task type="auto">
  <name>Task 2: Create MFA enroll endpoint</name>
  <files>src/app/api/mfa/enroll/route.ts</files>
  <action>
Create POST endpoint for MFA enrollment:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { enrollMfa } from '@/lib/auth/mfa';
import { enrollMfaSchema } from '@/lib/validations/mfa';
import { createAuditLogger } from '@/lib/audit/logger';

/**
 * POST /api/mfa/enroll
 * Start MFA enrollment - returns QR code and backup codes
 */
export async function POST(request: NextRequest) {
  try {
    const { user, clubId, error } = await getClaimsForApiRoute();

    if (error || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const parsed = enrollMfaSchema.safeParse(body);

    if (!parsed.success) {
      return NextResponse.json(
        { error: 'Invalid input', details: parsed.error.flatten() },
        { status: 400 }
      );
    }

    const result = await enrollMfa(parsed.data.friendlyName);

    // Audit log (enrollment started - not yet verified)
    const logger = createAuditLogger(request, {
      userId: user.id,
      clubId: clubId || 'system',
    });
    await logger.log({
      action: 'MFA_ENROLLED',
      targetType: 'User',
      targetId: user.id,
      metadata: { factorId: result.id },
    });

    return NextResponse.json({
      id: result.id,
      totp: result.totp,
      backupCodes: result.backupCodes,
    });
  } catch (error) {
    console.error('MFA enrollment failed:', error);
    return NextResponse.json(
      { error: 'Failed to start MFA enrollment' },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>MFA enrollment endpoint created with audit logging</done>
</task>

<task type="auto">
  <name>Task 3: Create remaining MFA endpoints</name>
  <files>
    src/app/api/mfa/verify/route.ts
    src/app/api/mfa/factors/route.ts
    src/app/api/mfa/unenroll/route.ts
    src/app/api/mfa/backup-codes/route.ts
  </files>
  <action>
Create the remaining MFA API endpoints:

**src/app/api/mfa/verify/route.ts:**
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { verifyMfaCode, useBackupCode } from '@/lib/auth/mfa';
import { verifyMfaSchema, backupCodeSchema } from '@/lib/validations/mfa';
import { createAuditLogger } from '@/lib/audit/logger';

/**
 * POST /api/mfa/verify
 * Verify MFA code (TOTP or backup code)
 */
export async function POST(request: NextRequest) {
  try {
    const { user, clubId, error } = await getClaimsForApiRoute();

    if (error || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();

    // Try TOTP verification first
    const totpParsed = verifyMfaSchema.safeParse(body);
    if (totpParsed.success) {
      await verifyMfaCode(totpParsed.data.factorId, totpParsed.data.code);

      const logger = createAuditLogger(request, {
        userId: user.id,
        clubId: clubId || 'system',
      });
      await logger.log({
        action: 'MFA_VERIFIED',
        targetType: 'User',
        targetId: user.id,
        metadata: { method: 'totp' },
      });

      return NextResponse.json({ success: true, method: 'totp' });
    }

    // Try backup code
    const backupParsed = backupCodeSchema.safeParse(body);
    if (backupParsed.success) {
      const valid = await useBackupCode(user.id, backupParsed.data.code);

      if (!valid) {
        return NextResponse.json(
          { error: 'Invalid or already used backup code' },
          { status: 400 }
        );
      }

      const logger = createAuditLogger(request, {
        userId: user.id,
        clubId: clubId || 'system',
      });
      await logger.log({
        action: 'MFA_BACKUP_CODE_USED',
        targetType: 'User',
        targetId: user.id,
        metadata: { method: 'backup_code' },
      });

      return NextResponse.json({ success: true, method: 'backup_code' });
    }

    return NextResponse.json(
      { error: 'Invalid input - provide factorId+code or backup code' },
      { status: 400 }
    );
  } catch (error) {
    console.error('MFA verification failed:', error);
    return NextResponse.json(
      { error: 'Verification failed - invalid code' },
      { status: 400 }
    );
  }
}
```

**src/app/api/mfa/factors/route.ts:**
```typescript
import { NextResponse } from 'next/server';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { getMfaStatus, getRemainingBackupCodesCount } from '@/lib/auth/mfa';

/**
 * GET /api/mfa/factors
 * Get MFA status and enrolled factors
 */
export async function GET() {
  try {
    const { user, error } = await getClaimsForApiRoute();

    if (error || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const status = await getMfaStatus();
    const remainingBackupCodes = await getRemainingBackupCodesCount(user.id);

    return NextResponse.json({
      ...status,
      remainingBackupCodes,
    });
  } catch (error) {
    console.error('Failed to get MFA status:', error);
    return NextResponse.json(
      { error: 'Failed to get MFA status' },
      { status: 500 }
    );
  }
}
```

**src/app/api/mfa/unenroll/route.ts:**
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { unenrollMfa } from '@/lib/auth/mfa';
import { createAuditLogger } from '@/lib/audit/logger';
import { z } from 'zod';

const unenrollSchema = z.object({
  factorId: z.string().uuid(),
});

/**
 * POST /api/mfa/unenroll
 * Remove MFA factor and delete backup codes
 */
export async function POST(request: NextRequest) {
  try {
    const { user, clubId, error } = await getClaimsForApiRoute();

    if (error || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const parsed = unenrollSchema.safeParse(body);

    if (!parsed.success) {
      return NextResponse.json(
        { error: 'Invalid input', details: parsed.error.flatten() },
        { status: 400 }
      );
    }

    await unenrollMfa(parsed.data.factorId);

    const logger = createAuditLogger(request, {
      userId: user.id,
      clubId: clubId || 'system',
    });
    await logger.log({
      action: 'MFA_UNENROLLED',
      targetType: 'User',
      targetId: user.id,
      metadata: { factorId: parsed.data.factorId },
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('MFA unenroll failed:', error);
    return NextResponse.json(
      { error: 'Failed to remove MFA' },
      { status: 500 }
    );
  }
}
```

**src/app/api/mfa/backup-codes/route.ts:**
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { regenerateBackupCodes, getRemainingBackupCodesCount } from '@/lib/auth/mfa';
import { createAuditLogger } from '@/lib/audit/logger';

/**
 * GET /api/mfa/backup-codes
 * Get count of remaining unused backup codes
 */
export async function GET() {
  try {
    const { user, error } = await getClaimsForApiRoute();

    if (error || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const count = await getRemainingBackupCodesCount(user.id);

    return NextResponse.json({ remainingCount: count });
  } catch (error) {
    console.error('Failed to get backup code count:', error);
    return NextResponse.json(
      { error: 'Failed to get backup codes' },
      { status: 500 }
    );
  }
}

/**
 * POST /api/mfa/backup-codes
 * Regenerate backup codes (deletes old, creates new)
 */
export async function POST(request: NextRequest) {
  try {
    const { user, clubId, error } = await getClaimsForApiRoute();

    if (error || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const codes = await regenerateBackupCodes();

    const logger = createAuditLogger(request, {
      userId: user.id,
      clubId: clubId || 'system',
    });
    await logger.log({
      action: 'MFA_BACKUP_CODES_REGENERATED',
      targetType: 'User',
      targetId: user.id,
      metadata: { codesGenerated: codes.length },
    });

    return NextResponse.json({ backupCodes: codes });
  } catch (error) {
    console.error('Failed to regenerate backup codes:', error);
    return NextResponse.json(
      { error: 'Failed to regenerate backup codes' },
      { status: 500 }
    );
  }
}
```

Create necessary directories: `src/app/api/mfa/enroll/`, `src/app/api/mfa/verify/`, etc.
  </action>
  <verify>All TypeScript files compile without errors. API routes accessible at /api/mfa/*</verify>
  <done>All MFA API endpoints created with proper auth, validation, and audit logging</done>
</task>

</tasks>

<verification>
1. All TypeScript files compile without errors
2. `curl -X GET /api/mfa/factors` returns 401 without auth
3. All endpoints follow existing API route patterns
4. Audit actions are properly defined and used
</verification>

<success_criteria>
- POST /api/mfa/enroll returns QR code and backup codes
- POST /api/mfa/verify accepts TOTP or backup code
- GET /api/mfa/factors returns enrolled factors and status
- POST /api/mfa/unenroll removes MFA factor
- GET/POST /api/mfa/backup-codes manages backup codes
- All operations are audit logged
</success_criteria>

<output>
After completion, create `.planning/phases/11-mfa-sso/11-03-SUMMARY.md`
</output>
