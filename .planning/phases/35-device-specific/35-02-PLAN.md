---
phase: 35-device-specific
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/use-dnd-sensors.ts
  - src/components/lineups/draggable-athlete.tsx
  - src/components/lineups/athlete-card.tsx
  - src/components/lineups/water-lineup-builder.tsx
autonomous: true

must_haves:
  truths:
    - "User on touch device can initiate drag by holding for 250ms"
    - "Accidental scrolls do not trigger drag"
    - "User dragging lineup item sees visual feedback (elevation, color change)"
  artifacts:
    - path: "src/hooks/use-dnd-sensors.ts"
      provides: "Pre-configured sensors with TouchSensor 250ms delay"
      exports: ["useDndSensors"]
    - path: "src/components/lineups/draggable-athlete.tsx"
      provides: "Drag handle with touch-action: none"
      contains: "touch-none"
    - path: "src/components/lineups/water-lineup-builder.tsx"
      provides: "Uses new sensors and enhanced DragOverlay"
      contains: "useDndSensors"
  key_links:
    - from: "src/components/lineups/water-lineup-builder.tsx"
      to: "src/hooks/use-dnd-sensors.ts"
      via: "useDndSensors import"
      pattern: "import.*useDndSensors"
    - from: "src/components/lineups/draggable-athlete.tsx"
      to: "touch-none class"
      via: "CSS class on drag handle"
      pattern: "touch-none"
---

<objective>
Make drag-drop interactions work reliably on touch devices with hold-to-drag and explicit drag handles.

Purpose: Current PointerSensor-only setup causes accidental drags during scrolling on mobile. The 250ms hold delay with explicit drag handles prevents scroll interference while providing clear visual feedback during drag operations.

Output: useDndSensors hook with TouchSensor + PointerSensor, updated DraggableAthlete with GripVertical drag handle, and enhanced DragOverlay with visual feedback.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-device-specific/35-RESEARCH.md

# Existing patterns to follow
@src/components/lineups/water-lineup-builder.tsx
@src/components/lineups/draggable-athlete.tsx
@src/components/lineups/athlete-card.tsx
@src/components/lineups/athlete-roster-panel.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useDndSensors hook with TouchSensor</name>
  <files>src/hooks/use-dnd-sensors.ts</files>
  <action>
Create a new custom hook that returns pre-configured dnd-kit sensors optimized for both mouse and touch.

```typescript
'use client';

import {
  PointerSensor,
  TouchSensor,
  useSensor,
  useSensors,
} from '@dnd-kit/core';

/**
 * Pre-configured dnd-kit sensors for mouse and touch devices.
 *
 * - PointerSensor: 8px distance threshold for mouse (prevents accidental drags)
 * - TouchSensor: 250ms hold delay with 5px tolerance (prevents scroll interference)
 *
 * @example
 * ```tsx
 * function MyDndContext() {
 *   const sensors = useDndSensors();
 *   return <DndContext sensors={sensors}>...</DndContext>;
 * }
 * ```
 */
export function useDndSensors() {
  const pointerSensor = useSensor(PointerSensor, {
    activationConstraint: {
      distance: 8, // 8px movement threshold for mouse
    },
  });

  const touchSensor = useSensor(TouchSensor, {
    activationConstraint: {
      delay: 250,     // 250ms hold before drag activates
      tolerance: 5,   // 5px movement tolerance during delay
    },
  });

  return useSensors(pointerSensor, touchSensor);
}
```

This follows the dnd-kit documentation pattern for combining sensors with different activation constraints.
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Run `grep -n "delay: 250" src/hooks/use-dnd-sensors.ts` - should find the delay configuration.
  </verify>
  <done>
useDndSensors hook exists with PointerSensor (8px distance) and TouchSensor (250ms delay, 5px tolerance).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add drag handle to DraggableAthlete</name>
  <files>
src/components/lineups/draggable-athlete.tsx
src/components/lineups/athlete-card.tsx
  </files>
  <action>
Update DraggableAthlete to use an explicit drag handle instead of the entire card being draggable.

**In draggable-athlete.tsx:**

1. Import GripVertical from lucide-react
2. Change the component structure to have a flex container with:
   - Drag handle button (receives attributes + listeners)
   - AthleteCard (no longer draggable directly)

Updated component:
```tsx
'use client';

import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { GripVertical } from 'lucide-react';
import { AthleteCard } from './athlete-card';

interface DraggableAthleteProps {
  athlete: {
    id: string;
    displayName: string | null;
    sidePreference?: 'PORT' | 'STARBOARD' | 'BOTH' | null;
  };
  disabled?: boolean;
}

export function DraggableAthlete({ athlete, disabled = false }: DraggableAthleteProps) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: athlete.id, disabled });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={`flex items-center gap-2 ${isDragging ? 'opacity-50' : ''}`}
    >
      {/* Drag handle - only this triggers drag on touch */}
      <button
        type="button"
        {...attributes}
        {...listeners}
        disabled={disabled}
        className={`
          touch-none p-2 rounded-lg
          ${disabled
            ? 'text-zinc-600 cursor-not-allowed'
            : 'text-zinc-500 hover:text-zinc-300 hover:bg-zinc-800 cursor-grab active:cursor-grabbing'
          }
          transition-colors
        `}
        aria-label={`Drag ${athlete.displayName || 'athlete'} to reorder`}
      >
        <GripVertical className="h-5 w-5" />
      </button>

      {/* Card content - scrollable, not draggable */}
      <div className="flex-1 min-w-0">
        <AthleteCard athlete={athlete} isDragging={isDragging} />
      </div>
    </div>
  );
}
```

Key points:
- `touch-none` class on the button (Tailwind for touch-action: none)
- Button has aria-label for accessibility
- attributes and listeners ONLY on the drag handle button
- Rest of card is scrollable (no touch-action restriction)
  </action>
  <verify>
Run `grep -n "touch-none" src/components/lineups/draggable-athlete.tsx` - should find the CSS class.
Run `grep -n "GripVertical" src/components/lineups/draggable-athlete.tsx` - should find the icon import and usage.
Run `npx tsc --noEmit` - no type errors.
  </verify>
  <done>
DraggableAthlete has explicit drag handle with GripVertical icon and touch-none CSS class.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update WaterLineupBuilder with sensors and visual feedback</name>
  <files>src/components/lineups/water-lineup-builder.tsx</files>
  <action>
Update WaterLineupBuilder to use the new useDndSensors hook and enhance DragOverlay visual feedback.

Changes:

1. **Import useDndSensors:**
   Replace the existing sensor setup with the new hook.
   - Remove: `import { PointerSensor, KeyboardSensor, useSensors, useSensor } from '@dnd-kit/core';`
   - Add: `import { useDndSensors } from '@/hooks/use-dnd-sensors';`
   - Keep: `import { DndContext, DragOverlay, closestCorners, DragStartEvent, DragEndEvent } from '@dnd-kit/core';`
   - Also keep KeyboardSensor import if still using keyboard support

2. **Update sensors setup:**
   Replace the existing sensors definition:
   ```tsx
   // OLD (remove):
   const sensors = useSensors(
     useSensor(PointerSensor),
     useSensor(KeyboardSensor, {
       coordinateGetter: sortableKeyboardCoordinates,
     })
   );

   // NEW (add):
   const sensors = useDndSensors();
   ```

   Note: If keyboard support is needed, add it to the useDndSensors hook later. For now, focus on touch.

3. **Enhance DragOverlay visual feedback:**
   Update the DragOverlay to show clear visual feedback during drag:
   ```tsx
   <DragOverlay dropAnimation={{ duration: 200 }}>
     {activeAthlete ? (
       <div className="transform scale-105 shadow-xl shadow-black/25 ring-2 ring-teal-500 rounded-lg bg-zinc-900">
         <AthleteCard athlete={activeAthlete} isDragging />
       </div>
     ) : null}
   </DragOverlay>
   ```

   Visual feedback classes:
   - `scale-105` - Slight enlargement
   - `shadow-xl shadow-black/25` - Elevation shadow
   - `ring-2 ring-teal-500` - Colored ring to show active state
   - `bg-zinc-900` - Solid background (not transparent)
   - `rounded-lg` - Consistent border radius
  </action>
  <verify>
Run `grep -n "useDndSensors" src/components/lineups/water-lineup-builder.tsx` - should find import and usage.
Run `grep -n "scale-105" src/components/lineups/water-lineup-builder.tsx` - should find visual feedback classes.
Run `grep -n "ring-teal-500" src/components/lineups/water-lineup-builder.tsx` - should find the ring color.
Run `npx tsc --noEmit` - no type errors.
  </verify>
  <done>
WaterLineupBuilder uses useDndSensors hook with 250ms touch delay and has enhanced DragOverlay with scale, shadow, and ring visual feedback.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. useDndSensors hook exports correctly with TouchSensor configuration
3. DraggableAthlete has touch-none drag handle with GripVertical icon
4. WaterLineupBuilder uses new sensors and has visual feedback on DragOverlay
5. Build succeeds: `npm run build` (if CI-like verification needed)
</verification>

<success_criteria>
- DRAG-01: TouchSensor configured with 250ms delay (verified in useDndSensors)
- DRAG-02: Explicit drag handles with touch-action: none (verified in DraggableAthlete)
- DRAG-03: Visual feedback during drag (scale-105, shadow-xl, ring-teal-500 on DragOverlay)
- No TypeScript errors
- Follows dnd-kit best practices
</success_criteria>

<output>
After completion, create `.planning/phases/35-device-specific/35-02-SUMMARY.md`
</output>
