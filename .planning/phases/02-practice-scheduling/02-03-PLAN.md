---
phase: 02-practice-scheduling
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/app/api/equipment/route.ts
  - src/app/api/equipment/[id]/route.ts
  - src/lib/equipment/readiness.ts
autonomous: true

must_haves:
  truths:
    - "Equipment list includes derived availability status"
    - "Equipment shows unavailable reasons (damage reports, manual override)"
    - "Coach can manually mark equipment as unavailable"
    - "Availability is computed at query time, not stored"
  artifacts:
    - path: "src/lib/equipment/readiness.ts"
      provides: "Equipment readiness computation helper"
      exports: ["computeEquipmentReadiness", "EquipmentWithReadiness"]
    - path: "src/app/api/equipment/route.ts"
      provides: "Updated GET with readiness data"
      exports: ["GET", "POST"]
    - path: "src/app/api/equipment/[id]/route.ts"
      provides: "Updated PATCH supporting manual unavailability"
      exports: ["GET", "PATCH", "DELETE"]
  key_links:
    - from: "src/lib/equipment/readiness.ts"
      to: "DamageReport model"
      via: "include in query"
      pattern: "damageReports.*where.*OPEN"
    - from: "src/app/api/equipment/route.ts"
      to: "computeEquipmentReadiness"
      via: "import and use"
      pattern: "computeEquipmentReadiness"
---

<objective>
Implement equipment readiness state by deriving availability from damage reports and manual override flags.

Purpose: Coaches need to see which equipment is available when planning practices. This enables EQUIP-02 (readiness state) and prepares for EQUIP-03 (availability enforcement).
Output: Equipment API returns availability status with reasons, coach can set manual unavailability.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/02-practice-scheduling/02-CONTEXT.md
@.planning/phases/02-practice-scheduling/02-RESEARCH.md
@.planning/phases/02-practice-scheduling/02-01-SUMMARY.md

# Existing equipment API
@src/app/api/equipment/route.ts
@src/app/api/equipment/[id]/route.ts
@src/lib/validations/equipment.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create equipment readiness computation helper</name>
  <files>src/lib/equipment/readiness.ts</files>
  <action>
Create src/lib/equipment/readiness.ts:

1. Define EquipmentWithReadiness type:
```typescript
import type { Equipment, DamageReport } from '@/generated/prisma';

export interface EquipmentWithReadiness extends Equipment {
  damageReports: Pick<DamageReport, 'id' | 'description' | 'location'>[];
  isAvailable: boolean;
  unavailableReasons: string[];
}
```

2. Create computeEquipmentReadiness function:
```typescript
export function computeEquipmentReadiness(
  equipment: Equipment & {
    damageReports: Pick<DamageReport, 'id' | 'description' | 'location'>[]
  }
): EquipmentWithReadiness {
  const unavailableReasons: string[] = [];

  // Check manual unavailability
  if (equipment.manualUnavailable) {
    unavailableReasons.push(
      equipment.manualUnavailableNote || 'Marked unavailable by coach'
    );
  }

  // Check open damage reports
  for (const report of equipment.damageReports) {
    unavailableReasons.push(
      `Damage: ${report.location} - ${report.description.slice(0, 50)}${report.description.length > 50 ? '...' : ''}`
    );
  }

  return {
    ...equipment,
    isAvailable: unavailableReasons.length === 0,
    unavailableReasons,
  };
}
```

3. Create computeMultipleEquipmentReadiness for batch processing:
```typescript
export function computeMultipleEquipmentReadiness(
  equipmentList: Array<Equipment & {
    damageReports: Pick<DamageReport, 'id' | 'description' | 'location'>[]
  }>
): EquipmentWithReadiness[] {
  return equipmentList.map(computeEquipmentReadiness);
}
```

Export all types and functions.
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>Readiness computation helper exists with proper types</done>
</task>

<task type="auto">
  <name>Task 2: Update equipment list API to include readiness</name>
  <files>src/app/api/equipment/route.ts</files>
  <action>
Update src/app/api/equipment/route.ts GET handler:

1. Add import:
```typescript
import { computeMultipleEquipmentReadiness } from '@/lib/equipment/readiness';
```

2. Modify the Prisma query to include open damage reports:
```typescript
const equipment = await prisma.equipment.findMany({
  where: { teamId: claims.team_id, ...filters },
  include: {
    damageReports: {
      where: { status: 'OPEN' },
      select: { id: true, description: true, location: true }
    }
  },
  orderBy: [{ type: 'asc' }, { name: 'asc' }],
});
```

3. Compute readiness before returning:
```typescript
const equipmentWithReadiness = computeMultipleEquipmentReadiness(equipment);
return NextResponse.json({ equipment: equipmentWithReadiness });
```

4. Add optional query param `?available=true` to filter to only available equipment:
```typescript
const availableOnly = searchParams.get('available') === 'true';

// After computing readiness:
const result = availableOnly
  ? equipmentWithReadiness.filter(e => e.isAvailable)
  : equipmentWithReadiness;
```

Keep the POST handler unchanged (creating equipment doesn't need readiness).
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>Equipment list includes isAvailable and unavailableReasons</done>
</task>

<task type="auto">
  <name>Task 3: Update equipment detail API for manual unavailability</name>
  <files>src/app/api/equipment/[id]/route.ts, src/lib/validations/equipment.ts</files>
  <action>
Update src/lib/validations/equipment.ts:

Add to updateEquipmentSchema:
```typescript
export const updateEquipmentSchema = equipmentBaseSchema.partial().extend({
  status: equipmentStatusSchema.optional(),
  manualUnavailable: z.boolean().optional(),
  manualUnavailableNote: z.string().max(500).optional().nullable(),
});
```

Update src/app/api/equipment/[id]/route.ts:

1. GET handler - include readiness:
```typescript
import { computeEquipmentReadiness } from '@/lib/equipment/readiness';

// In GET handler:
const equipment = await prisma.equipment.findUnique({
  where: { id },
  include: {
    damageReports: {
      where: { status: 'OPEN' },
      select: { id: true, description: true, location: true }
    }
  },
});

// Verify ownership...

const equipmentWithReadiness = computeEquipmentReadiness(equipment);
return NextResponse.json({ equipment: equipmentWithReadiness });
```

2. PATCH handler - allow setting manual unavailability:
- Validation already handles manualUnavailable and manualUnavailableNote
- Ensure only COACH can modify (existing role check)
- When setting manualUnavailable to false, also clear manualUnavailableNote:
```typescript
const updateData = { ...validationResult.data };
if (updateData.manualUnavailable === false) {
  updateData.manualUnavailableNote = null;
}
```

3. Return updated equipment with readiness computed:
```typescript
const updated = await prisma.equipment.update({
  where: { id },
  data: updateData,
  include: {
    damageReports: {
      where: { status: 'OPEN' },
      select: { id: true, description: true, location: true }
    }
  },
});
const equipmentWithReadiness = computeEquipmentReadiness(updated);
return NextResponse.json({ equipment: equipmentWithReadiness });
```
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>Equipment detail includes readiness, PATCH supports manual unavailability</done>
</task>

</tasks>

<verification>
All checks must pass:
1. `npx tsc --noEmit` - all files compile
2. GET /api/equipment returns isAvailable and unavailableReasons for each item
3. GET /api/equipment?available=true filters to available only
4. PATCH /api/equipment/[id] accepts manualUnavailable and manualUnavailableNote
5. Readiness combines damage reports + manual override
</verification>

<success_criteria>
- Equipment list shows availability status (EQUIP-02)
- Unavailable reasons visible (damage reports, manual override)
- Coach can mark equipment manually unavailable
- Availability computed at query time (not stored)
- Filter available-only equipment for practice planning
</success_criteria>

<output>
After completion, create `.planning/phases/02-practice-scheduling/02-03-SUMMARY.md`
</output>
