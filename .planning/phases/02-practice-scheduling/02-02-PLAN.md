---
phase: 02-practice-scheduling
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/app/api/practices/route.ts
  - src/app/api/practices/[id]/route.ts
  - src/app/api/practices/[id]/publish/route.ts
  - src/app/api/practices/[id]/blocks/route.ts
  - src/app/api/practices/[id]/blocks/reorder/route.ts
autonomous: true

must_haves:
  truths:
    - "Coach can create a practice with date, time, and blocks"
    - "Coach can update practice details and status"
    - "Coach can add, update, remove, and reorder blocks"
    - "Athletes only see published practices"
    - "Practices are team-scoped and season-filtered"
  artifacts:
    - path: "src/app/api/practices/route.ts"
      provides: "GET list and POST create endpoints"
      exports: ["GET", "POST"]
    - path: "src/app/api/practices/[id]/route.ts"
      provides: "GET single, PATCH update, DELETE endpoints"
      exports: ["GET", "PATCH", "DELETE"]
    - path: "src/app/api/practices/[id]/publish/route.ts"
      provides: "POST publish endpoint"
      exports: ["POST"]
    - path: "src/app/api/practices/[id]/blocks/route.ts"
      provides: "POST add block, DELETE remove block"
      exports: ["POST", "DELETE"]
    - path: "src/app/api/practices/[id]/blocks/reorder/route.ts"
      provides: "POST reorder blocks"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/practices/route.ts"
      to: "prisma.practice"
      via: "database queries"
      pattern: "prisma\\.practice\\.(findMany|create)"
    - from: "src/app/api/practices/route.ts"
      to: "getClaimsForApiRoute"
      via: "auth import"
      pattern: "getClaimsForApiRoute"
---

<objective>
Build the complete Practice CRUD API with block management, following established codebase patterns.

Purpose: This API enables coaches to create and manage practices with time blocks - the core scheduling functionality.
Output: Fully functional practice API with create, read, update, delete, publish, and block management.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/02-practice-scheduling/02-CONTEXT.md
@.planning/phases/02-practice-scheduling/02-RESEARCH.md
@.planning/phases/02-practice-scheduling/02-01-SUMMARY.md

# Established API patterns
@src/app/api/seasons/route.ts
@src/app/api/seasons/[id]/route.ts
@src/lib/auth/claims.ts
@src/lib/errors/index.ts
@src/lib/validations/practice.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create practice list and create API</name>
  <files>src/app/api/practices/route.ts</files>
  <action>
Create src/app/api/practices/route.ts following the seasons/route.ts pattern:

GET /api/practices:
- Auth: getClaimsForApiRoute(), require team_id
- Query params: seasonId (optional filter), startDate, endDate (date range filter)
- Athletes only see PUBLISHED practices (filter by status if user_role !== 'COACH')
- Include blocks ordered by position
- Order by date ASC, startTime ASC
- Return { practices: Practice[] }

POST /api/practices:
- Auth: require COACH role
- Validate body with createPracticeSchema
- Create practice with nested blocks (use Prisma create with blocks.create)
- Assign position to each block based on array index
- Return { practice } with status 201

Imports:
- NextRequest, NextResponse from 'next/server'
- prisma from '@/lib/prisma'
- getClaimsForApiRoute from '@/lib/auth/claims'
- unauthorizedResponse, forbiddenResponse, serverErrorResponse from '@/lib/errors'
- createPracticeSchema from '@/lib/validations/practice'
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors
Test manually or note for later testing
  </verify>
  <done>GET /api/practices returns team practices, POST creates practice with blocks</done>
</task>

<task type="auto">
  <name>Task 2: Create single practice operations API</name>
  <files>src/app/api/practices/[id]/route.ts, src/app/api/practices/[id]/publish/route.ts</files>
  <action>
Create src/app/api/practices/[id]/route.ts:

GET /api/practices/[id]:
- Auth: require team_id
- Fetch practice by ID with blocks (ordered by position)
- Verify practice.teamId matches claims.team_id (multi-tenant isolation)
- Athletes can only view PUBLISHED practices
- Return { practice } or 404

PATCH /api/practices/[id]:
- Auth: require COACH role
- Validate body with updatePracticeSchema
- Verify ownership (teamId match)
- Update practice fields (not blocks - separate endpoint)
- Return { practice }

DELETE /api/practices/[id]:
- Auth: require COACH role
- Verify ownership
- Delete practice (blocks cascade delete)
- Return 204 No Content

Create src/app/api/practices/[id]/publish/route.ts:

POST /api/practices/[id]/publish:
- Auth: require COACH role
- Verify ownership
- Update status to PUBLISHED
- Return { practice }

Use the same patterns as seasons/[id]/route.ts for parameter extraction and error handling.
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>Single practice CRUD and publish endpoints functional</done>
</task>

<task type="auto">
  <name>Task 3: Create block management API</name>
  <files>src/app/api/practices/[id]/blocks/route.ts, src/app/api/practices/[id]/blocks/reorder/route.ts</files>
  <action>
Create src/app/api/practices/[id]/blocks/route.ts:

POST /api/practices/[id]/blocks:
- Auth: require COACH role
- Verify practice ownership
- Validate body with createBlockSchema
- Find max position of existing blocks, add new block at position + 1
- Return { block } with status 201

DELETE /api/practices/[id]/blocks (with blockId in body or query):
- Auth: require COACH role
- Verify practice ownership
- Delete block by ID (verify it belongs to this practice)
- Recompute positions for remaining blocks (fill gap)
- Return 204

Create src/app/api/practices/[id]/blocks/reorder/route.ts:

POST /api/practices/[id]/blocks/reorder:
- Auth: require COACH role
- Verify practice ownership
- Validate body with reorderBlocksSchema (array of { blockId, position })
- Use transaction to update all block positions atomically
- Validate: all blockIds belong to this practice, positions are contiguous (0, 1, 2...)
- Return { blocks } with new order

Use Prisma transactions for atomic updates:
```typescript
await prisma.$transaction(async (tx) => {
  for (const { blockId, position } of positions) {
    await tx.practiceBlock.update({
      where: { id: blockId },
      data: { position }
    });
  }
});
```
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>Block add, remove, and reorder endpoints functional</done>
</task>

</tasks>

<verification>
All checks must pass:
1. `npx tsc --noEmit` - all files compile
2. API routes exist at expected paths
3. Auth pattern consistent: getClaimsForApiRoute() -> team check -> role check where needed
4. Multi-tenant isolation: all queries filter by claims.team_id
5. Draft/published visibility: athletes only see PUBLISHED practices
</verification>

<success_criteria>
- Coach can create practice with blocks via POST /api/practices
- Coach can update practice via PATCH /api/practices/[id]
- Coach can publish practice via POST /api/practices/[id]/publish
- Coach can add, remove, reorder blocks
- Athletes can list/view only PUBLISHED practices
- All endpoints enforce team isolation
</success_criteria>

<output>
After completion, create `.planning/phases/02-practice-scheduling/02-02-SUMMARY.md`
</output>
