---
phase: 27-secrets-logging-rate-limiting
plan: 03
type: execute
wave: 2
depends_on: ["27-02"]
files_modified:
  - src/app/api/auth/login/route.ts
  - src/app/api/auth/signup/route.ts
  - src/app/api/auth/forgot-password/route.ts
  - src/app/api/auth/logout/route.ts
  - src/lib/rate-limit/index.ts
  - src/app/(auth)/login/page.tsx
  - src/app/(auth)/signup/page.tsx
  - .planning/phases/27-secrets-logging-rate-limiting/27-03-SUMMARY.md
autonomous: true

must_haves:
  truths:
    - "Login attempts are rate limited (5 per 15 minutes per IP)"
    - "Signup attempts are rate limited (3 per hour per IP)"
    - "Password reset requests are rate limited (3 per hour per IP)"
    - "Rate limit responses include Retry-After and X-RateLimit-* headers"
    - "Successful and failed auth events are logged to AuditLog"
    - "Logout events are logged to AuditLog"
  artifacts:
    - path: "src/app/api/auth/login/route.ts"
      provides: "Rate-limited login endpoint"
      exports: ["POST"]
    - path: "src/app/api/auth/signup/route.ts"
      provides: "Rate-limited signup endpoint"
      exports: ["POST"]
    - path: "src/app/api/auth/forgot-password/route.ts"
      provides: "Rate-limited password reset endpoint"
      exports: ["POST"]
    - path: "src/lib/rate-limit/index.ts"
      provides: "Auth-specific rate limit configs"
      contains: "authLimits"
  key_links:
    - from: "src/app/(auth)/login/page.tsx"
      to: "src/app/api/auth/login/route.ts"
      via: "fetch POST"
      pattern: "fetch.*api/auth/login"
    - from: "src/app/api/auth/login/route.ts"
      to: "src/lib/audit/logger.ts"
      via: "logAuditEvent"
      pattern: "LOGIN_SUCCESS|LOGIN_FAILED"
    - from: "src/app/api/auth/login/route.ts"
      to: "src/lib/rate-limit/index.ts"
      via: "checkRateLimit"
      pattern: "checkRateLimit"
---

<objective>
Create rate-limited API routes for authentication that enable server-side rate limiting and audit logging.

Purpose: RATE-01 through RATE-05 require rate limiting on auth endpoints. Current login/signup use client-side Supabase directly, bypassing all server-side controls. This plan creates API routes that wrap Supabase auth with rate limiting and logging.

Output:
- Rate-limited POST /api/auth/login endpoint
- Rate-limited POST /api/auth/signup endpoint
- Rate-limited POST /api/auth/forgot-password endpoint
- Updated logout route with audit logging
- Auth-specific rate limit configurations
- Updated login/signup pages to use API routes
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-secrets-logging-rate-limiting/27-RESEARCH.md
@.planning/phases/27-secrets-logging-rate-limiting/27-02-SUMMARY.md

# Existing infrastructure
@src/lib/rate-limit/index.ts
@src/lib/audit/logger.ts
@src/lib/audit/actions.ts
@src/app/(auth)/login/page.tsx
@src/app/(auth)/signup/page.tsx
@src/app/api/auth/logout/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend rate limiter with auth-specific configurations</name>
  <files>src/lib/rate-limit/index.ts</files>
  <action>
Add auth-specific rate limit configurations to `src/lib/rate-limit/index.ts`:

1. Define auth rate limit windows (after existing constants):

```typescript
/**
 * Rate limit configurations by action type.
 * Auth endpoints use stricter limits to prevent brute force.
 */
export const authLimits = {
  login: { requests: 5, window: '15 m' },      // 5 attempts per 15 minutes
  signup: { requests: 3, window: '1 h' },      // 3 signups per hour per IP
  'forgot-password': { requests: 3, window: '1 h' }, // 3 reset requests per hour
} as const;

type AuthAction = keyof typeof authLimits;
```

2. Create auth-specific rate limiter factory (after existing getRateLimiter):

```typescript
// Auth-specific rate limiters with different windows
const authRateLimiters: Map<AuthAction, Ratelimit> = new Map();

function getAuthRateLimiter(action: AuthAction): Ratelimit | null {
  const url = process.env.UPSTASH_REDIS_REST_URL;
  const token = process.env.UPSTASH_REDIS_REST_TOKEN;

  if (!url || !token) {
    console.warn('Auth rate limiting disabled: Upstash not configured');
    return null;
  }

  if (!authRateLimiters.has(action)) {
    const config = authLimits[action];
    authRateLimiters.set(action, new Ratelimit({
      redis: new Redis({ url, token }),
      limiter: Ratelimit.slidingWindow(config.requests, config.window),
      analytics: true,
      prefix: `rowops:auth:${action}`,
    }));
  }

  return authRateLimiters.get(action)!;
}
```

3. Add checkAuthRateLimit function:

```typescript
/**
 * Check auth-specific rate limit with stricter windows.
 * Returns rate limit result with headers for 429 responses.
 */
export async function checkAuthRateLimit(
  identifier: string,
  action: AuthAction
): Promise<RateLimitResult> {
  const limiter = getAuthRateLimiter(action);

  if (!limiter) {
    return { success: true, limit: Infinity, remaining: Infinity, reset: 0 };
  }

  const { success, limit, remaining, reset } = await limiter.limit(identifier);
  return { success, limit, remaining, reset };
}

/**
 * Build rate limit headers for 429 responses.
 */
export function rateLimitHeaders(result: RateLimitResult): HeadersInit {
  return {
    'Retry-After': String(Math.ceil((result.reset - Date.now()) / 1000)),
    'X-RateLimit-Limit': String(result.limit),
    'X-RateLimit-Remaining': String(result.remaining),
    'X-RateLimit-Reset': String(result.reset),
  };
}
```

Export `checkAuthRateLimit`, `rateLimitHeaders`, and `authLimits`.
  </action>
  <verify>
- `grep "authLimits" src/lib/rate-limit/index.ts` shows config object
- `grep "checkAuthRateLimit" src/lib/rate-limit/index.ts` shows function
- `grep "rateLimitHeaders" src/lib/rate-limit/index.ts` shows function
- `npx tsc --noEmit` passes
  </verify>
  <done>
- Auth-specific rate limit configs defined (5/15min login, 3/hr signup, 3/hr reset)
- checkAuthRateLimit function exported
- rateLimitHeaders helper exported for 429 responses
  </done>
</task>

<task type="auto">
  <name>Task 2: Create rate-limited auth API routes with logging</name>
  <files>src/app/api/auth/login/route.ts, src/app/api/auth/signup/route.ts, src/app/api/auth/forgot-password/route.ts, src/app/api/auth/logout/route.ts</files>
  <action>
**Create POST /api/auth/login/route.ts:**

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { checkAuthRateLimit, getClientIp, rateLimitHeaders } from '@/lib/rate-limit';
import { logAuditEvent } from '@/lib/audit/logger';
import { z } from 'zod';

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(1),
});

export async function POST(request: NextRequest) {
  const clientIp = getClientIp(request);

  // Rate limit check FIRST
  const rateLimit = await checkAuthRateLimit(clientIp, 'login');
  if (!rateLimit.success) {
    return NextResponse.json(
      { error: 'Too many login attempts. Please try again later.' },
      { status: 429, headers: rateLimitHeaders(rateLimit) }
    );
  }

  // Parse and validate body
  const body = await request.json().catch(() => null);
  const parsed = loginSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json({ error: 'Invalid request' }, { status: 400 });
  }

  const { email, password } = parsed.data;
  const supabase = await createClient();

  const { data, error } = await supabase.auth.signInWithPassword({
    email,
    password,
  });

  // Log event (fire and forget for performance)
  if (data.user) {
    logAuditEvent(
      { clubId: 'system', userId: data.user.id, ipAddress: clientIp },
      { action: 'LOGIN_SUCCESS', targetType: 'Auth', metadata: { email } }
    ).catch(console.error);
  } else {
    logAuditEvent(
      { clubId: 'system', userId: 'anonymous', ipAddress: clientIp },
      { action: 'LOGIN_FAILED', targetType: 'Auth', metadata: { email, error: error?.message } }
    ).catch(console.error);
  }

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 401 });
  }

  return NextResponse.json({ user: data.user, session: data.session });
}
```

**Create POST /api/auth/signup/route.ts:**

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { checkAuthRateLimit, getClientIp, rateLimitHeaders } from '@/lib/rate-limit';
import { logAuditEvent } from '@/lib/audit/logger';
import { z } from 'zod';

const signupSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
});

export async function POST(request: NextRequest) {
  const clientIp = getClientIp(request);

  // Rate limit check FIRST
  const rateLimit = await checkAuthRateLimit(clientIp, 'signup');
  if (!rateLimit.success) {
    return NextResponse.json(
      { error: 'Too many signup attempts. Please try again later.' },
      { status: 429, headers: rateLimitHeaders(rateLimit) }
    );
  }

  const body = await request.json().catch(() => null);
  const parsed = signupSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json({ error: 'Invalid request' }, { status: 400 });
  }

  const { email, password } = parsed.data;
  const supabase = await createClient();

  const { data, error } = await supabase.auth.signUp({
    email,
    password,
  });

  // Log event
  if (data.user) {
    logAuditEvent(
      { clubId: 'system', userId: data.user.id, ipAddress: clientIp },
      { action: 'SIGNUP_SUCCESS', targetType: 'Auth', metadata: { email } }
    ).catch(console.error);
  } else if (error) {
    logAuditEvent(
      { clubId: 'system', userId: 'anonymous', ipAddress: clientIp },
      { action: 'SIGNUP_FAILED', targetType: 'Auth', metadata: { email, error: error?.message } }
    ).catch(console.error);
  }

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }

  return NextResponse.json({ user: data.user, message: 'Check your email to confirm your account' });
}
```

**Create POST /api/auth/forgot-password/route.ts:**

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { checkAuthRateLimit, getClientIp, rateLimitHeaders } from '@/lib/rate-limit';
import { logAuditEvent } from '@/lib/audit/logger';
import { z } from 'zod';

const forgotPasswordSchema = z.object({
  email: z.string().email(),
});

export async function POST(request: NextRequest) {
  const clientIp = getClientIp(request);

  // Rate limit check FIRST
  const rateLimit = await checkAuthRateLimit(clientIp, 'forgot-password');
  if (!rateLimit.success) {
    return NextResponse.json(
      { error: 'Too many password reset requests. Please try again later.' },
      { status: 429, headers: rateLimitHeaders(rateLimit) }
    );
  }

  const body = await request.json().catch(() => null);
  const parsed = forgotPasswordSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json({ error: 'Invalid request' }, { status: 400 });
  }

  const { email } = parsed.data;
  const supabase = await createClient();

  // Always return success to prevent email enumeration
  const { error } = await supabase.auth.resetPasswordForEmail(email, {
    redirectTo: `${process.env.NEXT_PUBLIC_APP_URL}/reset-password`,
  });

  // Log event (fire and forget)
  logAuditEvent(
    { clubId: 'system', userId: 'anonymous', ipAddress: clientIp },
    { action: 'PASSWORD_RESET_REQUESTED', targetType: 'Auth', metadata: { email, success: !error } }
  ).catch(console.error);

  // Always return success to prevent email enumeration
  return NextResponse.json({ message: 'If an account exists, a reset link has been sent.' });
}
```

**Update src/app/api/auth/logout/route.ts** to add audit logging:

Add after successful signOut:
```typescript
// Add import at top
import { logAuditEvent } from '@/lib/audit/logger';
import { getClientIp } from '@/lib/rate-limit';

// Inside POST handler, after successful signOut and before clearCurrentClubId:
const { data: { user } } = await supabase.auth.getUser();
if (user) {
  const clientIp = getClientIp(request);
  logAuditEvent(
    { clubId: 'system', userId: user.id, ipAddress: clientIp },
    { action: 'LOGOUT', targetType: 'Auth' }
  ).catch(console.error);
}
```

Note: The logout route needs to get user BEFORE signOut since signOut clears the session. Adjust ordering: get user first, then signOut, then log.
  </action>
  <verify>
- All 4 route files exist
- `grep "checkAuthRateLimit" src/app/api/auth/login/route.ts` shows rate limiting
- `grep "LOGIN_SUCCESS" src/app/api/auth/login/route.ts` shows audit logging
- `grep "LOGOUT" src/app/api/auth/logout/route.ts` shows audit logging
- `npx tsc --noEmit` passes
  </verify>
  <done>
- POST /api/auth/login with rate limiting (5/15min) and logging
- POST /api/auth/signup with rate limiting (3/hr) and logging
- POST /api/auth/forgot-password with rate limiting (3/hr) and logging
- POST /api/auth/logout with audit logging
  </done>
</task>

<task type="auto">
  <name>Task 3: Update login/signup pages to use API routes</name>
  <files>src/app/(auth)/login/page.tsx, src/app/(auth)/signup/page.tsx</files>
  <action>
**Update src/app/(auth)/login/page.tsx:**

Replace the `onSubmit` function to call the API route instead of direct Supabase:

```typescript
const onSubmit = async (data: LoginInput) => {
  setError(null);

  try {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email: data.email, password: data.password }),
    });

    const result = await response.json();

    if (!response.ok) {
      // Handle rate limit
      if (response.status === 429) {
        const retryAfter = response.headers.get('Retry-After');
        setError(`Too many attempts. Please try again in ${retryAfter || '15'} seconds.`);
        return;
      }
      setError(result.error || 'Login failed');
      return;
    }

    router.push('/');
    router.refresh();
  } catch {
    setError('An unexpected error occurred');
  }
};
```

Remove unused `supabase` client initialization (keep import if needed for other features, otherwise remove).

**Update src/app/(auth)/signup/page.tsx:**

Replace the `onSubmit` function:

```typescript
const onSubmit = async (data: SignupInput) => {
  setError(null);
  setSuccess(false);

  try {
    const response = await fetch('/api/auth/signup', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email: data.email, password: data.password }),
    });

    const result = await response.json();

    if (!response.ok) {
      if (response.status === 429) {
        const retryAfter = response.headers.get('Retry-After');
        setError(`Too many attempts. Please try again in ${retryAfter || '60'} seconds.`);
        return;
      }
      setError(result.error || 'Signup failed');
      return;
    }

    setSuccess(true);
  } catch {
    setError('An unexpected error occurred');
  }
};
```

Remove direct Supabase client usage from both pages.
  </action>
  <verify>
- `grep "fetch.*api/auth/login" src/app/(auth)/login/page.tsx` shows API call
- `grep "fetch.*api/auth/signup" src/app/(auth)/signup/page.tsx` shows API call
- `grep -c "supabase.auth.signInWithPassword" src/app/(auth)/login/page.tsx` returns 0
- `grep -c "supabase.auth.signUp" src/app/(auth)/signup/page.tsx` returns 0
- `npm run build` succeeds
  </verify>
  <done>
- Login page calls /api/auth/login instead of direct Supabase
- Signup page calls /api/auth/signup instead of direct Supabase
- Rate limit errors displayed to users with retry timing
- Direct Supabase auth calls removed from client pages
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `npm run build` succeeds
2. Rate limiting works: Multiple rapid requests to /api/auth/login return 429
3. Audit logging works: Check AuditLog table after login attempt
4. Headers present: 429 responses include Retry-After and X-RateLimit-* headers
</verification>

<success_criteria>
- RATE-01: Login endpoint rate limited (5 per 15 minutes per IP)
- RATE-02: Signup endpoint rate limited (3 per hour per IP)
- RATE-03: Password reset endpoint rate limited (3 per hour per IP)
- RATE-04: Rate limit responses include proper headers
- RATE-05: Rate limiting is per-IP (via getClientIp)
- AUDIT-01: Auth events logged (LOGIN_SUCCESS, LOGIN_FAILED, LOGOUT, SIGNUP_*, PASSWORD_RESET_*)
- AUDIT-02: Covered by existing infrastructure + auth events
</success_criteria>

<output>
After completion, create `.planning/phases/27-secrets-logging-rate-limiting/27-03-SUMMARY.md`
</output>
