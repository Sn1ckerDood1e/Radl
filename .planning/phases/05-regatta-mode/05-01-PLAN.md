---
phase: 05-regatta-mode
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/validations/regatta.ts
  - src/generated/prisma/
autonomous: true

must_haves:
  truths:
    - "Regatta, Entry, EntryLineup, EntrySeat models exist in database"
    - "NotificationConfig model supports scheduled race notifications"
    - "RegattaCentralConnection model stores encrypted OAuth tokens"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Regatta mode data models"
      contains: "model Entry"
    - path: "src/lib/validations/regatta.ts"
      provides: "Zod validation schemas for regatta API"
      exports: ["createRegattaSchema", "createEntrySchema", "entryLineupSchema"]
  key_links:
    - from: "Entry"
      to: "Regatta"
      via: "regattaId foreign key"
      pattern: "regatta.*Regatta.*onDelete: Cascade"
    - from: "EntryLineup"
      to: "Entry"
      via: "entryId foreign key"
      pattern: "entry.*Entry.*onDelete: Cascade"
---

<objective>
Create data models for regatta mode including Regatta extensions, Entry (race), EntryLineup, EntrySeat, NotificationConfig, and RegattaCentralConnection.

Purpose: Foundation for all regatta features - manual entry, RC import, lineup assignment, and scheduled notifications.
Output: Extended Prisma schema with all regatta models, validation schemas matching API contracts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-regatta-mode/05-RESEARCH.md

# Existing patterns
@prisma/schema.prisma
@src/lib/validations/lineup.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Prisma schema with regatta data models</name>
  <files>prisma/schema.prisma</files>
  <action>
Add the following models and enums to prisma/schema.prisma:

1. **New enums:**
```prisma
enum RegattaSource {
  REGATTA_CENTRAL
  MANUAL
}

enum EntryStatus {
  SCHEDULED
  SCRATCHED
  COMPLETED
}
```

2. **Extend existing Regatta model** (replace the placeholder):
```prisma
model Regatta {
  id                String        @id @default(uuid())
  teamId            String
  seasonId          String
  name              String
  location          String?
  venue             String?       // Specific venue/course name
  timezone          String?       // IANA timezone (e.g., 'America/New_York')
  startDate         DateTime
  endDate           DateTime?
  source            RegattaSource @default(MANUAL)
  rcRegattaId       String?       // Regatta Central ID if imported
  lastSyncAt        DateTime?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  team    Team    @relation(fields: [teamId], references: [id], onDelete: Cascade)
  season  Season  @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  entries Entry[]

  @@unique([teamId, rcRegattaId])
  @@index([teamId])
  @@index([teamId, seasonId])
  @@index([teamId, startDate])
}
```

3. **Add Entry model:**
```prisma
model Entry {
  id              String      @id @default(uuid())
  regattaId       String
  eventName       String      // e.g., "Women's Varsity 8+"
  eventCode       String?     // RC event code
  rcEntryId       String?     // Regatta Central entry ID
  scheduledTime   DateTime    // Race time (UTC)
  meetingLocation String?     // Where to rig/meet (REG-06)
  meetingTime     DateTime?   // When to meet
  notes           String?     // Special instructions (REG-07)
  status          EntryStatus @default(SCHEDULED)
  heat            String?     // e.g., "Heat 1", "Final"
  lane            Int?
  placement       Int?        // Result after race
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  regatta            Regatta              @relation(fields: [regattaId], references: [id], onDelete: Cascade)
  entryLineup        EntryLineup?
  notificationConfig NotificationConfig?

  @@unique([regattaId, rcEntryId])
  @@index([regattaId])
  @@index([regattaId, scheduledTime])
}
```

4. **Add EntryLineup model:**
```prisma
model EntryLineup {
  id        String   @id @default(uuid())
  entryId   String   @unique
  boatId    String?
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  entry Entry          @relation(fields: [entryId], references: [id], onDelete: Cascade)
  boat  Equipment?     @relation(fields: [boatId], references: [id])
  seats EntrySeat[]

  @@index([entryId])
}
```

5. **Add EntrySeat model:**
```prisma
model EntrySeat {
  id            String   @id @default(uuid())
  entryLineupId String
  athleteId     String
  position      Int      // 1=Bow, etc.
  side          SeatSide

  entryLineup EntryLineup    @relation(fields: [entryLineupId], references: [id], onDelete: Cascade)
  athlete     AthleteProfile @relation(fields: [athleteId], references: [id])

  @@unique([entryLineupId, position])
  @@unique([entryLineupId, athleteId])
  @@index([entryLineupId])
}
```

6. **Add NotificationConfig model:**
```prisma
model NotificationConfig {
  id                String   @id @default(uuid())
  entryId           String   @unique
  leadTimeMinutes   Int      @default(60)  // Default 1 hour before
  notificationSent  Boolean  @default(false)
  scheduledFor      DateTime?
  sentAt            DateTime?

  entry Entry @relation(fields: [entryId], references: [id], onDelete: Cascade)

  @@index([scheduledFor, notificationSent])
}
```

7. **Add RegattaCentralConnection model:**
```prisma
model RegattaCentralConnection {
  id             String    @id @default(uuid())
  teamId         String    @unique
  rcClubId       String    // Regatta Central organization ID
  encryptedToken String    // AES-256 encrypted access token
  refreshToken   String    // AES-256 encrypted refresh token
  expiresAt      DateTime
  lastSyncAt     DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@index([teamId])
}
```

8. **Update Team model** - add relation:
```prisma
// Add to Team model relations:
rcConnection RegattaCentralConnection?
```

9. **Update Equipment model** - add relation for EntryLineup:
```prisma
// Add to Equipment model relations:
entryLineups EntryLineup[]
```

10. **Update AthleteProfile model** - add relation for EntrySeat:
```prisma
// Add to AthleteProfile model relations:
entrySeats EntrySeat[]
```
  </action>
  <verify>Run `npx prisma validate` - should pass with no errors</verify>
  <done>All regatta models defined with proper relations and indexes</done>
</task>

<task type="auto">
  <name>Task 2: Generate Prisma client and create validation schemas</name>
  <files>src/generated/prisma/, src/lib/validations/regatta.ts</files>
  <action>
1. Run `npx prisma generate` to update Prisma client

2. Create src/lib/validations/regatta.ts with Zod schemas:

```typescript
import { z } from 'zod';

// Enums matching Prisma schema
export const regattaSourceSchema = z.enum(['REGATTA_CENTRAL', 'MANUAL']);
export const entryStatusSchema = z.enum(['SCHEDULED', 'SCRATCHED', 'COMPLETED']);
export const seatSideSchema = z.enum(['PORT', 'STARBOARD', 'NONE']);

// Create regatta schema (manual creation)
export const createRegattaSchema = z.object({
  seasonId: z.string().uuid(),
  name: z.string().min(1, 'Name is required').max(200),
  location: z.string().max(200).optional(),
  venue: z.string().max(200).optional(),
  timezone: z.string().max(50).optional(), // IANA timezone
  startDate: z.string().datetime(), // ISO string
  endDate: z.string().datetime().optional(),
});

// Update regatta schema
export const updateRegattaSchema = z.object({
  name: z.string().min(1).max(200).optional(),
  location: z.string().max(200).nullable().optional(),
  venue: z.string().max(200).nullable().optional(),
  timezone: z.string().max(50).nullable().optional(),
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().nullable().optional(),
});

// Create entry schema (manual race entry)
export const createEntrySchema = z.object({
  regattaId: z.string().uuid(),
  eventName: z.string().min(1, 'Event name is required').max(200),
  eventCode: z.string().max(50).optional(),
  scheduledTime: z.string().datetime(),
  meetingLocation: z.string().max(200).optional(),
  meetingTime: z.string().datetime().optional(),
  notes: z.string().max(1000).optional(),
  heat: z.string().max(50).optional(),
  lane: z.number().int().min(1).max(20).optional(),
});

// Update entry schema
export const updateEntrySchema = z.object({
  eventName: z.string().min(1).max(200).optional(),
  eventCode: z.string().max(50).nullable().optional(),
  scheduledTime: z.string().datetime().optional(),
  meetingLocation: z.string().max(200).nullable().optional(),
  meetingTime: z.string().datetime().nullable().optional(),
  notes: z.string().max(1000).nullable().optional(),
  status: entryStatusSchema.optional(),
  heat: z.string().max(50).nullable().optional(),
  lane: z.number().int().min(1).max(20).nullable().optional(),
  placement: z.number().int().min(1).nullable().optional(),
});

// Entry seat schema (for lineup assignment)
export const entrySeatSchema = z.object({
  athleteId: z.string().uuid(),
  position: z.number().int().min(1).max(9),
  side: seatSideSchema,
});

// Entry lineup schema (assign lineup to entry)
export const entryLineupSchema = z.object({
  entryId: z.string().uuid(),
  boatId: z.string().uuid().optional(),
  notes: z.string().max(500).optional(),
  seats: z.array(entrySeatSchema),
}).refine(
  (data) => {
    const athleteIds = data.seats.map((s) => s.athleteId);
    return athleteIds.length === new Set(athleteIds).size;
  },
  { message: 'Each athlete can only be assigned to one seat', path: ['seats'] }
).refine(
  (data) => {
    const positions = data.seats.map((s) => s.position);
    return positions.length === new Set(positions).size;
  },
  { message: 'Each position can only have one athlete', path: ['seats'] }
);

// Update entry lineup schema
export const updateEntryLineupSchema = z.object({
  boatId: z.string().uuid().nullable().optional(),
  notes: z.string().max(500).nullable().optional(),
  seats: z.array(entrySeatSchema).optional(),
}).refine(
  (data) => {
    if (!data.seats) return true;
    const athleteIds = data.seats.map((s) => s.athleteId);
    return athleteIds.length === new Set(athleteIds).size;
  },
  { message: 'Each athlete can only be assigned to one seat', path: ['seats'] }
).refine(
  (data) => {
    if (!data.seats) return true;
    const positions = data.seats.map((s) => s.position);
    return positions.length === new Set(positions).size;
  },
  { message: 'Each position can only have one athlete', path: ['seats'] }
);

// Notification config schema
export const notificationConfigSchema = z.object({
  entryId: z.string().uuid(),
  leadTimeMinutes: z.number().int().min(5).max(480).default(60), // 5 min to 8 hours
});

// Update notification config schema
export const updateNotificationConfigSchema = z.object({
  leadTimeMinutes: z.number().int().min(5).max(480).optional(),
});

// Type exports
export type RegattaSource = z.infer<typeof regattaSourceSchema>;
export type EntryStatus = z.infer<typeof entryStatusSchema>;
export type CreateRegattaInput = z.infer<typeof createRegattaSchema>;
export type UpdateRegattaInput = z.infer<typeof updateRegattaSchema>;
export type CreateEntryInput = z.infer<typeof createEntrySchema>;
export type UpdateEntryInput = z.infer<typeof updateEntrySchema>;
export type EntrySeat = z.infer<typeof entrySeatSchema>;
export type EntryLineupInput = z.infer<typeof entryLineupSchema>;
export type UpdateEntryLineupInput = z.infer<typeof updateEntryLineupSchema>;
export type NotificationConfigInput = z.infer<typeof notificationConfigSchema>;
export type UpdateNotificationConfigInput = z.infer<typeof updateNotificationConfigSchema>;
```
  </action>
  <verify>Run `npx tsc --noEmit` - should pass with no type errors</verify>
  <done>Prisma client regenerated, validation schemas created with proper types</done>
</task>

<task type="auto">
  <name>Task 3: Run database migration</name>
  <files>prisma/migrations/</files>
  <action>
Run database migration to apply schema changes:

```bash
npx prisma db push
```

Note: Using `db push` for development. In production, use `prisma migrate dev --name add-regatta-models`.

Verify migration applied by checking that tables exist in database.
  </action>
  <verify>Run `npx prisma db push` - should complete without errors. Then run `npx prisma studio` briefly to confirm Entry, EntryLineup, EntrySeat, NotificationConfig, RegattaCentralConnection tables exist.</verify>
  <done>Database schema updated with all regatta models</done>
</task>

</tasks>

<verification>
1. `npx prisma validate` passes
2. `npx tsc --noEmit` passes
3. `npx prisma db push` completes successfully
4. All models visible in Prisma Studio
</verification>

<success_criteria>
- Regatta model extended with source, rcRegattaId, venue, timezone fields
- Entry model created with eventName, scheduledTime, meetingLocation, notes, status
- EntryLineup and EntrySeat models support lineup assignment per entry
- NotificationConfig model supports scheduled notifications with configurable lead time
- RegattaCentralConnection model stores encrypted OAuth tokens per team
- Validation schemas match API contracts with proper refinements
</success_criteria>

<output>
After completion, create `.planning/phases/05-regatta-mode/05-01-SUMMARY.md`
</output>
