---
phase: 05-regatta-mode
plan: 08
type: execute
wave: 5
depends_on: ["05-07"]
files_modified:
  - src/app/(dashboard)/[teamSlug]/regattas/[id]/page.tsx
  - src/app/(dashboard)/[teamSlug]/regattas/[id]/regatta-detail-client.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Regatta detail page loads data via useOfflineRegatta hook"
    - "Data is automatically cached to IndexedDB when online"
    - "Data is served from IndexedDB cache when offline"
    - "StalenessIndicator reflects actual cache state"
  artifacts:
    - path: "src/app/(dashboard)/[teamSlug]/regattas/[id]/regatta-detail-client.tsx"
      provides: "Client component using useOfflineRegatta hook"
      imports: ["useOfflineRegatta"]
    - path: "src/app/(dashboard)/[teamSlug]/regattas/[id]/page.tsx"
      provides: "Server page passing regattaId to client"
      does_not_pass: "regatta prop with full data"
  key_links:
    - from: "regatta-detail-client.tsx"
      to: "useOfflineRegatta"
      via: "hook import and call"
      pattern: "useOfflineRegatta\\(regattaId\\)"
    - from: "useOfflineRegatta"
      to: "cacheRegatta"
      via: "automatic caching on fetch"
      pattern: "cacheRegatta\\("
---

<objective>
Wire offline regatta infrastructure to UI components

Purpose: Close the gap identified in Phase 5 verification where offline infrastructure exists but is not connected to the UI. The useOfflineRegatta hook and regatta-cache.ts are fully implemented but the client component receives data as props from the server instead of using the hook.

Output: Regatta detail page that fetches data client-side via hook, automatically caches to IndexedDB when online, and falls back to cache when offline.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing offline hook (the main piece to wire)
@src/hooks/use-offline-regatta.ts

# Files to modify
@src/app/(dashboard)/[teamSlug]/regattas/[id]/page.tsx
@src/app/(dashboard)/[teamSlug]/regattas/[id]/regatta-detail-client.tsx

# Pattern reference (how unified-calendar wires offline data)
@src/components/calendar/unified-calendar.tsx

# Cache manager (already implemented, called by hook)
@src/lib/db/regatta-cache.ts

# API endpoint the hook will call
@src/app/api/regattas/[id]/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update server page to pass only identifiers</name>
  <files>src/app/(dashboard)/[teamSlug]/regattas/[id]/page.tsx</files>
  <action>
Modify the server component to pass minimal props to the client component:

1. Keep the server-side auth check and team verification (lines 23-37)

2. Keep the metadata generation using prisma.regatta.findUnique (lines 10-17)

3. REMOVE the large prisma.regatta.findFirst query with all includes (lines 39-63). The client will fetch this data via the hook.

4. REMOVE fetching athletes and boats (lines 67-95). These are only needed for lineup editing which requires being online anyway.

5. Keep the notFound() check but change it to a simpler existence check:
```typescript
const regattaExists = await prisma.regatta.findFirst({
  where: { id, teamId: team.id },
  select: { id: true, name: true, timezone: true },
});

if (!regattaExists) notFound();
```

6. Simplify the RegattaDetailClient props:
```typescript
<RegattaDetailClient
  teamSlug={teamSlug}
  regattaId={id}
  regattaName={regattaExists.name}
  timezone={regattaExists.timezone || 'America/New_York'}
  isCoach={isCoach}
/>
```

7. KEEP the header section (lines 100-149) in the server component since it shows static regatta info. But simplify it to use regattaExists data instead of full regatta object.

The server page should now be ~100 lines instead of 189, with minimal data passed to client.
  </action>
  <verify>
- `grep -n "regattaId" src/app/(dashboard)/[teamSlug]/regattas/[id]/page.tsx` shows regattaId prop
- `grep -c "entries:" src/app/(dashboard)/[teamSlug]/regattas/[id]/page.tsx` returns 0 (no entries prop)
- TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>Server page passes regattaId (not full regatta object) to client component</done>
</task>

<task type="auto">
  <name>Task 2: Wire useOfflineRegatta hook to client component</name>
  <files>src/app/(dashboard)/[teamSlug]/regattas/[id]/regatta-detail-client.tsx</files>
  <action>
Refactor the client component to use the useOfflineRegatta hook:

1. Update imports:
```typescript
import { useOfflineRegatta } from '@/hooks/use-offline-regatta';
// Remove useOnlineStatus import - hook provides isOffline
```

2. Update the props interface to match new server props:
```typescript
interface RegattaDetailClientProps {
  teamSlug: string;
  regattaId: string;
  regattaName: string;
  timezone: string;
  isCoach: boolean;
}
```

3. Use the hook at the top of the component:
```typescript
export function RegattaDetailClient({
  teamSlug,
  regattaId,
  regattaName,
  timezone,
  isCoach,
}: RegattaDetailClientProps) {
  const router = useRouter();
  const {
    data: regatta,
    isLoading,
    isOffline,
    isStale,
    cachedAt,
    error,
    refresh,
  } = useOfflineRegatta(regattaId);
```

4. Remove the old state variables:
- Remove `const isOnline = useOnlineStatus();`
- Remove `const [isRefreshing, setIsRefreshing] = useState(false);`
- Remove `const [cachedAt] = useState(initialCachedAt);`
- Remove the STALE_THRESHOLD_MS calculation (hook provides isStale)

5. Update handleRefresh to use the hook's refresh:
```typescript
async function handleRefresh() {
  if (isOffline) return;
  await refresh();
}
```

6. Add loading state handling:
```typescript
if (isLoading && !regatta) {
  return (
    <div className="flex justify-center py-8">
      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-emerald-500" />
    </div>
  );
}

if (error && !regatta) {
  return (
    <div className="text-center py-8 text-red-400">
      <p>{error}</p>
      {!isOffline && (
        <button onClick={refresh} className="mt-4 text-emerald-400 hover:underline">
          Try again
        </button>
      )}
    </div>
  );
}
```

7. Update StalenessIndicator to use hook values:
```typescript
<StalenessIndicator
  lastUpdated={cachedAt ? new Date(cachedAt) : null}
  isStale={isStale}
  isOffline={isOffline}
/>
```

8. Update the offline indicator banner to use isOffline from hook (same UI, different source)

9. Guard the timeline rendering with regatta check:
```typescript
{regatta && (
  <RaceTimeline
    entries={regatta.entries}
    timezone={timezone}
    onEntryClick={handleEntryClick}
  />
)}
```

10. Update the "Add Entry" and "Edit" buttons to be disabled when offline (they already check isOnline, change to !isOffline)

The key change is that data now flows:
- Online: hook fetches from /api/regattas/[id] -> caches to IndexedDB -> returns data
- Offline: hook reads from IndexedDB cache -> returns cached data with isStale flag
  </action>
  <verify>
- `grep -n "useOfflineRegatta" src/app/(dashboard)/[teamSlug]/regattas/[id]/regatta-detail-client.tsx` shows import and usage
- `grep -n "regattaId" src/app/(dashboard)/[teamSlug]/regattas/[id]/regatta-detail-client.tsx` shows regattaId prop
- TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>Client component uses useOfflineRegatta hook, data automatically cached when online</done>
</task>

<task type="auto">
  <name>Task 3: Verify offline flow end-to-end</name>
  <files>
    src/app/(dashboard)/[teamSlug]/regattas/[id]/page.tsx
    src/app/(dashboard)/[teamSlug]/regattas/[id]/regatta-detail-client.tsx
    src/hooks/use-offline-regatta.ts
  </files>
  <action>
Verify the complete wiring by tracing the data flow:

1. Verify the hook import path is correct:
```bash
grep -rn "from '@/hooks/use-offline-regatta'" src/
```
Should show regatta-detail-client.tsx importing it.

2. Verify the hook calls cacheRegatta:
```bash
grep -n "cacheRegatta" src/hooks/use-offline-regatta.ts
```
Should show cacheRegatta called after successful API fetch (around line 154).

3. Verify the API endpoint exists and returns correct shape:
```bash
grep -n "entries:" src/app/api/regattas/\[id\]/route.ts
```
Should show entries included in response.

4. Trace the complete flow:
- Server page: passes regattaId to client
- Client: calls useOfflineRegatta(regattaId)
- Hook: fetches /api/regattas/[id] -> caches via cacheRegatta() -> returns data
- Offline: hook calls getCachedRegatta() -> returns cached data

5. Run TypeScript check to ensure no type mismatches:
```bash
npx tsc --noEmit
```

6. Verify no orphaned imports:
```bash
grep -n "initialCachedAt" src/app/
```
Should return nothing (removed prop).
  </action>
  <verify>
- TypeScript compiles without errors
- `grep -c "useOfflineRegatta" src/app/(dashboard)/[teamSlug]/regattas/[id]/regatta-detail-client.tsx` returns 1
- `grep -c "initialCachedAt" src/app/(dashboard)/[teamSlug]/regattas/[id]/page.tsx` returns 0
  </verify>
  <done>Complete data flow verified: server -> client -> hook -> cache -> IndexedDB</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **TypeScript validation:**
```bash
npx tsc --noEmit
```
Must pass with no errors.

2. **Hook is wired:**
```bash
grep -rn "useOfflineRegatta" src/app/
```
Must show import in regatta-detail-client.tsx.

3. **Old prop pattern removed:**
```bash
grep -n "entries:" src/app/(dashboard)/[teamSlug]/regattas/[id]/page.tsx
```
Must return nothing (entries no longer passed from server).

4. **Cache manager imported by hook:**
```bash
grep -n "import.*cacheRegatta" src/hooks/use-offline-regatta.ts
```
Must show import of cacheRegatta.
</verification>

<success_criteria>
- [ ] Server page passes regattaId (not full regatta object) to client
- [ ] Client component imports and uses useOfflineRegatta hook
- [ ] Hook fetches from API when online and caches automatically
- [ ] Hook returns cached data when offline
- [ ] StalenessIndicator uses hook's isStale and cachedAt values
- [ ] TypeScript compiles without errors
- [ ] No orphaned imports or props from old pattern
</success_criteria>

<output>
After completion, create `.planning/phases/05-regatta-mode/05-08-SUMMARY.md` using the template at `@~/.claude/get-shit-done/templates/summary.md`
</output>
