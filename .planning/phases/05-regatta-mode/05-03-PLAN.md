---
phase: 05-regatta-mode
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/lib/regatta-central/encryption.ts
  - src/lib/regatta-central/client.ts
  - src/lib/regatta-central/types.ts
  - src/app/api/regatta-central/connect/route.ts
  - src/app/api/regatta-central/disconnect/route.ts
  - src/app/api/regatta-central/import/route.ts
  - src/app/api/regatta-central/status/route.ts
autonomous: true
user_setup:
  - service: regatta-central
    why: "OAuth2 API integration for race schedule import"
    env_vars:
      - name: RC_CLIENT_ID
        source: "Regatta Central API application registration"
      - name: RC_CLIENT_SECRET
        source: "Regatta Central API application registration"
      - name: RC_TOKEN_ENCRYPTION_KEY
        source: "Generate with: openssl rand -hex 32"

must_haves:
  truths:
    - "Coach can connect Regatta Central account with username/password"
    - "OAuth tokens are encrypted before database storage"
    - "Coach can import team's race schedule from RC"
    - "Imported entries have source=REGATTA_CENTRAL and rcEntryId"
  artifacts:
    - path: "src/lib/regatta-central/client.ts"
      provides: "RC API client with token refresh"
      exports: ["RegattaCentralClient"]
    - path: "src/lib/regatta-central/encryption.ts"
      provides: "AES-256 token encryption"
      exports: ["encryptToken", "decryptToken"]
    - path: "src/app/api/regatta-central/connect/route.ts"
      provides: "OAuth connection endpoint"
      exports: ["POST"]
    - path: "src/app/api/regatta-central/import/route.ts"
      provides: "Schedule import endpoint"
      exports: ["POST"]
  key_links:
    - from: "POST /api/regatta-central/connect"
      to: "RC OAuth token endpoint"
      via: "password grant flow"
      pattern: "oauth2/api/token"
    - from: "RegattaCentralClient.fetch"
      to: "decryptToken"
      via: "token decryption before API call"
      pattern: "decryptToken.*encryptedToken"
---

<objective>
Integrate Regatta Central API with OAuth2 password grant flow and encrypted token storage.

Purpose: Enables REG-01 (integrate Regatta Central API) for importing race schedules.
Output: RC API client with token management, connect/disconnect/import endpoints.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-regatta-mode/05-RESEARCH.md

# Prior plan output
@.planning/phases/05-regatta-mode/05-01-SUMMARY.md

# Existing patterns
@src/lib/auth/claims.ts
@src/lib/prisma.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create token encryption utilities and RC types</name>
  <files>src/lib/regatta-central/encryption.ts, src/lib/regatta-central/types.ts</files>
  <action>
1. Create src/lib/regatta-central/encryption.ts:

```typescript
/**
 * AES-256-CBC encryption for Regatta Central OAuth tokens.
 * Tokens are stored encrypted in database to protect user credentials.
 */

import { createCipheriv, createDecipheriv, randomBytes } from 'crypto';

const ENCRYPTION_KEY = process.env.RC_TOKEN_ENCRYPTION_KEY;

/**
 * Encrypt a token using AES-256-CBC.
 * Returns format: iv:encryptedData (hex encoded)
 */
export function encryptToken(token: string): string {
  if (!ENCRYPTION_KEY) {
    throw new Error('RC_TOKEN_ENCRYPTION_KEY not configured');
  }

  const iv = randomBytes(16);
  const cipher = createCipheriv(
    'aes-256-cbc',
    Buffer.from(ENCRYPTION_KEY, 'hex'),
    iv
  );

  let encrypted = cipher.update(token, 'utf8', 'hex');
  encrypted += cipher.final('hex');

  return iv.toString('hex') + ':' + encrypted;
}

/**
 * Decrypt a token encrypted with encryptToken.
 * Input format: iv:encryptedData (hex encoded)
 */
export function decryptToken(encrypted: string): string {
  if (!ENCRYPTION_KEY) {
    throw new Error('RC_TOKEN_ENCRYPTION_KEY not configured');
  }

  const [ivHex, encryptedHex] = encrypted.split(':');

  if (!ivHex || !encryptedHex) {
    throw new Error('Invalid encrypted token format');
  }

  const decipher = createDecipheriv(
    'aes-256-cbc',
    Buffer.from(ENCRYPTION_KEY, 'hex'),
    Buffer.from(ivHex, 'hex')
  );

  let decrypted = decipher.update(encryptedHex, 'hex', 'utf8');
  decrypted += decipher.final('utf8');

  return decrypted;
}
```

2. Create src/lib/regatta-central/types.ts:

```typescript
/**
 * TypeScript types for Regatta Central API responses.
 * Based on RC API v4 documentation.
 */

// OAuth token response
export interface RCTokenResponse {
  access_token: string;
  refresh_token: string;
  expires_in: number; // seconds
  token_type: string;
}

// Regatta list item
export interface RCRegatta {
  id: string;
  name: string;
  location?: string;
  startDate: number; // Unix timestamp ms
  endDate?: number;
  status: string;
}

// Event (race type) at regatta
export interface RCEvent {
  eventId: string;
  uuid: string;
  sequence: number;
  label: string;
  title: string;
  code: string;
  gender?: string;
  athleteClass?: string;
  equipment?: string;
  sweep?: boolean;
  coxed?: boolean;
  status: string;
}

// Team's entry (registration) for an event
export interface RCTeamEntry {
  entryId: string;
  eventId: string;
  eventTitle: string;
  eventCode: string;
  raceTime?: number; // Unix timestamp ms
  heat?: string;
  lane?: number;
  status: string;
}

// Club/team info
export interface RCClub {
  clubId: string;
  name: string;
  abbreviation?: string;
  country?: string;
}

// API response wrappers
export interface RCRegattasResponse {
  regattas: RCRegatta[];
}

export interface RCEventsResponse {
  events: RCEvent[];
}

export interface RCTeamEntriesResponse {
  entries: RCTeamEntry[];
}

export interface RCClubResponse {
  club: RCClub;
}
```
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>Encryption utilities and RC API types created</done>
</task>

<task type="auto">
  <name>Task 2: Create Regatta Central API client</name>
  <files>src/lib/regatta-central/client.ts</files>
  <action>
Create src/lib/regatta-central/client.ts:

```typescript
/**
 * Regatta Central API client with automatic token refresh.
 * Handles OAuth2 password grant flow and encrypted token storage.
 */

import { prisma } from '@/lib/prisma';
import { encryptToken, decryptToken } from './encryption';
import type { RCTokenResponse, RCRegattasResponse, RCTeamEntriesResponse } from './types';

const RC_BASE_URL = 'https://api.regattacentral.com';
const RC_API_URL = `${RC_BASE_URL}/v4.0`;

const RC_CLIENT_ID = process.env.RC_CLIENT_ID;
const RC_CLIENT_SECRET = process.env.RC_CLIENT_SECRET;

export class RegattaCentralClient {
  private teamId: string;

  constructor(teamId: string) {
    this.teamId = teamId;
  }

  /**
   * Get the team's RC connection from database.
   */
  private async getConnection() {
    const conn = await prisma.regattaCentralConnection.findUnique({
      where: { teamId: this.teamId },
    });

    if (!conn) {
      throw new Error('Regatta Central not connected for this team');
    }

    return conn;
  }

  /**
   * Refresh the OAuth token if it's expiring soon (within 10 minutes).
   */
  private async refreshTokenIfNeeded() {
    const conn = await this.getConnection();
    const tenMinutesFromNow = Date.now() + 10 * 60 * 1000;

    if (conn.expiresAt.getTime() > tenMinutesFromNow) {
      return; // Token still valid
    }

    if (!RC_CLIENT_ID || !RC_CLIENT_SECRET) {
      throw new Error('Regatta Central API credentials not configured');
    }

    const refreshToken = decryptToken(conn.refreshToken);

    const response = await fetch(`${RC_BASE_URL}/oauth2/api/token`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        client_id: RC_CLIENT_ID,
        client_secret: RC_CLIENT_SECRET,
        refresh_token: refreshToken,
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      console.error('RC token refresh failed:', error);
      throw new Error('Failed to refresh Regatta Central token. Please reconnect.');
    }

    const data: RCTokenResponse = await response.json();

    await prisma.regattaCentralConnection.update({
      where: { teamId: this.teamId },
      data: {
        encryptedToken: encryptToken(data.access_token),
        refreshToken: encryptToken(data.refresh_token),
        expiresAt: new Date(Date.now() + data.expires_in * 1000),
      },
    });
  }

  /**
   * Make an authenticated request to the RC API.
   */
  async fetch<T>(endpoint: string): Promise<T> {
    await this.refreshTokenIfNeeded();

    const conn = await this.getConnection();
    const token = decryptToken(conn.encryptedToken);

    const response = await fetch(`${RC_API_URL}${endpoint}`, {
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: 'application/json',
      },
    });

    if (!response.ok) {
      if (response.status === 401) {
        throw new Error('Regatta Central authentication failed. Please reconnect.');
      }
      throw new Error(`RC API error: ${response.status} ${response.statusText}`);
    }

    return response.json();
  }

  /**
   * Get the team's RC club ID.
   */
  async getClubId(): Promise<string> {
    const conn = await this.getConnection();
    return conn.rcClubId;
  }

  /**
   * Get upcoming regattas (country defaults to US).
   */
  async getUpcomingRegattas(country = 'US'): Promise<RCRegattasResponse> {
    return this.fetch(`/regattas/${country}/upcoming`);
  }

  /**
   * Get team's entries for a specific regatta.
   */
  async getTeamEntries(regattaId: string): Promise<RCTeamEntriesResponse> {
    const clubId = await this.getClubId();
    return this.fetch(`/regattas/${regattaId}/club/${clubId}/events`);
  }

  /**
   * Get regatta details.
   */
  async getRegattaDetails(regattaId: string): Promise<{ regatta: { id: string; name: string; location?: string; startDate: number; endDate?: number } }> {
    return this.fetch(`/regattas/${regattaId}`);
  }
}

/**
 * Authenticate with RC and store encrypted tokens.
 * Used for initial connection only.
 */
export async function connectRegattaCentral(
  teamId: string,
  username: string,
  password: string,
  rcClubId: string
): Promise<void> {
  if (!RC_CLIENT_ID || !RC_CLIENT_SECRET) {
    throw new Error('Regatta Central API credentials not configured');
  }

  // Request access token using password grant
  const response = await fetch(`${RC_BASE_URL}/oauth2/api/token`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      grant_type: 'password',
      client_id: RC_CLIENT_ID,
      client_secret: RC_CLIENT_SECRET,
      username,
      password,
    }),
  });

  if (!response.ok) {
    const error = await response.text();
    console.error('RC OAuth failed:', error);

    if (response.status === 401 || response.status === 400) {
      throw new Error('Invalid Regatta Central credentials');
    }
    throw new Error('Failed to connect to Regatta Central');
  }

  const data: RCTokenResponse = await response.json();

  // Upsert connection with encrypted tokens
  await prisma.regattaCentralConnection.upsert({
    where: { teamId },
    create: {
      teamId,
      rcClubId,
      encryptedToken: encryptToken(data.access_token),
      refreshToken: encryptToken(data.refresh_token),
      expiresAt: new Date(Date.now() + data.expires_in * 1000),
    },
    update: {
      rcClubId,
      encryptedToken: encryptToken(data.access_token),
      refreshToken: encryptToken(data.refresh_token),
      expiresAt: new Date(Date.now() + data.expires_in * 1000),
      lastSyncAt: null,
    },
  });
}

/**
 * Disconnect RC by removing stored tokens.
 */
export async function disconnectRegattaCentral(teamId: string): Promise<void> {
  await prisma.regattaCentralConnection.delete({
    where: { teamId },
  }).catch(() => {
    // Ignore if not found
  });
}

/**
 * Check if team has RC connected.
 */
export async function isRegattaCentralConnected(teamId: string): Promise<boolean> {
  const conn = await prisma.regattaCentralConnection.findUnique({
    where: { teamId },
  });
  return !!conn;
}
```
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>RC API client with token refresh and connection management created</done>
</task>

<task type="auto">
  <name>Task 3: Create RC API endpoints (connect, disconnect, import, status)</name>
  <files>src/app/api/regatta-central/connect/route.ts, src/app/api/regatta-central/disconnect/route.ts, src/app/api/regatta-central/import/route.ts, src/app/api/regatta-central/status/route.ts</files>
  <action>
1. Create src/app/api/regatta-central/connect/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { unauthorizedResponse, forbiddenResponse, serverErrorResponse } from '@/lib/errors';
import { connectRegattaCentral } from '@/lib/regatta-central/client';
import { z } from 'zod';

const connectSchema = z.object({
  username: z.string().min(1, 'Username required'),
  password: z.string().min(1, 'Password required'),
  rcClubId: z.string().min(1, 'Club ID required'),
});

// POST: Connect Regatta Central account
export async function POST(request: NextRequest) {
  try {
    const { user, claims, error } = await getClaimsForApiRoute();
    if (error || !user) return unauthorizedResponse();
    if (!claims?.team_id) return forbiddenResponse('No team associated with user');
    if (claims.user_role !== 'COACH') return forbiddenResponse('Only coaches can connect Regatta Central');

    const body = await request.json();
    const validationResult = connectSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: validationResult.error.flatten() },
        { status: 400 }
      );
    }

    const { username, password, rcClubId } = validationResult.data;

    await connectRegattaCentral(claims.team_id, username, password, rcClubId);

    return NextResponse.json({ success: true, message: 'Regatta Central connected' });
  } catch (error) {
    if (error instanceof Error && error.message.includes('Invalid')) {
      return NextResponse.json({ error: error.message }, { status: 401 });
    }
    return serverErrorResponse(error, 'regatta-central/connect:POST');
  }
}
```

2. Create src/app/api/regatta-central/disconnect/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { unauthorizedResponse, forbiddenResponse, serverErrorResponse } from '@/lib/errors';
import { disconnectRegattaCentral } from '@/lib/regatta-central/client';

// POST: Disconnect Regatta Central account
export async function POST(request: NextRequest) {
  try {
    const { user, claims, error } = await getClaimsForApiRoute();
    if (error || !user) return unauthorizedResponse();
    if (!claims?.team_id) return forbiddenResponse('No team associated with user');
    if (claims.user_role !== 'COACH') return forbiddenResponse('Only coaches can disconnect Regatta Central');

    await disconnectRegattaCentral(claims.team_id);

    return NextResponse.json({ success: true, message: 'Regatta Central disconnected' });
  } catch (error) {
    return serverErrorResponse(error, 'regatta-central/disconnect:POST');
  }
}
```

3. Create src/app/api/regatta-central/status/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { unauthorizedResponse, forbiddenResponse, serverErrorResponse } from '@/lib/errors';

// GET: Check RC connection status
export async function GET(request: NextRequest) {
  try {
    const { user, claims, error } = await getClaimsForApiRoute();
    if (error || !user) return unauthorizedResponse();
    if (!claims?.team_id) return forbiddenResponse('No team associated with user');

    const connection = await prisma.regattaCentralConnection.findUnique({
      where: { teamId: claims.team_id },
      select: {
        rcClubId: true,
        expiresAt: true,
        lastSyncAt: true,
        createdAt: true,
      },
    });

    if (!connection) {
      return NextResponse.json({
        connected: false,
      });
    }

    return NextResponse.json({
      connected: true,
      rcClubId: connection.rcClubId,
      lastSyncAt: connection.lastSyncAt,
      tokenExpiresAt: connection.expiresAt,
      connectedAt: connection.createdAt,
    });
  } catch (error) {
    return serverErrorResponse(error, 'regatta-central/status:GET');
  }
}
```

4. Create src/app/api/regatta-central/import/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getClaimsForApiRoute } from '@/lib/auth/claims';
import { unauthorizedResponse, forbiddenResponse, notFoundResponse, serverErrorResponse } from '@/lib/errors';
import { RegattaCentralClient } from '@/lib/regatta-central/client';
import { z } from 'zod';

const importSchema = z.object({
  rcRegattaId: z.string().min(1, 'Regatta ID required'),
  seasonId: z.string().uuid(),
});

// POST: Import regatta and entries from Regatta Central
export async function POST(request: NextRequest) {
  try {
    const { user, claims, error } = await getClaimsForApiRoute();
    if (error || !user) return unauthorizedResponse();
    if (!claims?.team_id) return forbiddenResponse('No team associated with user');
    if (claims.user_role !== 'COACH') return forbiddenResponse('Only coaches can import regattas');

    const body = await request.json();
    const validationResult = importSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: validationResult.error.flatten() },
        { status: 400 }
      );
    }

    const { rcRegattaId, seasonId } = validationResult.data;

    // Verify season belongs to team
    const season = await prisma.season.findFirst({
      where: { id: seasonId, teamId: claims.team_id },
    });

    if (!season) return notFoundResponse('Season');

    // Initialize RC client
    const client = new RegattaCentralClient(claims.team_id);

    // Fetch regatta details and team entries in parallel
    const [regattaData, entriesData] = await Promise.all([
      client.getRegattaDetails(rcRegattaId),
      client.getTeamEntries(rcRegattaId),
    ]);

    const rcRegatta = regattaData.regatta;

    // Upsert regatta (update if re-importing)
    const regatta = await prisma.regatta.upsert({
      where: {
        teamId_rcRegattaId: {
          teamId: claims.team_id,
          rcRegattaId: rcRegattaId,
        },
      },
      create: {
        teamId: claims.team_id,
        seasonId,
        name: rcRegatta.name,
        location: rcRegatta.location || null,
        startDate: new Date(rcRegatta.startDate),
        endDate: rcRegatta.endDate ? new Date(rcRegatta.endDate) : null,
        source: 'REGATTA_CENTRAL',
        rcRegattaId,
        lastSyncAt: new Date(),
      },
      update: {
        name: rcRegatta.name,
        location: rcRegatta.location || null,
        startDate: new Date(rcRegatta.startDate),
        endDate: rcRegatta.endDate ? new Date(rcRegatta.endDate) : null,
        lastSyncAt: new Date(),
      },
    });

    // Import/update entries
    let importedCount = 0;
    let updatedCount = 0;

    for (const rcEntry of entriesData.entries || []) {
      const existingEntry = await prisma.entry.findFirst({
        where: {
          regattaId: regatta.id,
          rcEntryId: rcEntry.entryId,
        },
      });

      if (existingEntry) {
        // Update existing entry
        await prisma.entry.update({
          where: { id: existingEntry.id },
          data: {
            eventName: rcEntry.eventTitle,
            eventCode: rcEntry.eventCode || null,
            scheduledTime: rcEntry.raceTime ? new Date(rcEntry.raceTime) : existingEntry.scheduledTime,
            heat: rcEntry.heat || null,
            lane: rcEntry.lane || null,
          },
        });
        updatedCount++;
      } else {
        // Create new entry
        await prisma.entry.create({
          data: {
            regattaId: regatta.id,
            eventName: rcEntry.eventTitle,
            eventCode: rcEntry.eventCode || null,
            rcEntryId: rcEntry.entryId,
            scheduledTime: rcEntry.raceTime
              ? new Date(rcEntry.raceTime)
              : new Date(rcRegatta.startDate), // Fallback to regatta start
            heat: rcEntry.heat || null,
            lane: rcEntry.lane || null,
            status: 'SCHEDULED',
          },
        });
        importedCount++;
      }
    }

    // Update connection's lastSyncAt
    await prisma.regattaCentralConnection.update({
      where: { teamId: claims.team_id },
      data: { lastSyncAt: new Date() },
    });

    return NextResponse.json({
      regatta,
      imported: importedCount,
      updated: updatedCount,
      total: entriesData.entries?.length || 0,
    });
  } catch (error) {
    if (error instanceof Error && error.message.includes('not connected')) {
      return NextResponse.json({ error: 'Regatta Central not connected' }, { status: 400 });
    }
    if (error instanceof Error && error.message.includes('authentication')) {
      return NextResponse.json({ error: error.message }, { status: 401 });
    }
    return serverErrorResponse(error, 'regatta-central/import:POST');
  }
}
```
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>RC API endpoints created for connect, disconnect, status check, and import</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. POST /api/regatta-central/connect accepts username/password/clubId
3. GET /api/regatta-central/status returns connection info
4. POST /api/regatta-central/import creates/updates regatta and entries
5. Tokens are encrypted before database storage
</verification>

<success_criteria>
- Coach can connect RC with POST /api/regatta-central/connect
- OAuth tokens encrypted with AES-256 before storage
- Token refresh happens automatically when expiring
- Coach can import regatta with POST /api/regatta-central/import
- Import upserts (creates or updates) regatta and entries
- Imported entries have source=REGATTA_CENTRAL and rcEntryId set
- REG-01 requirement satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/05-regatta-mode/05-03-SUMMARY.md`
</output>
