---
phase: 05-regatta-mode
plan: 07
type: execute
wave: 4
depends_on: ["05-05"]
files_modified:
  - src/lib/db/schema.ts
  - src/lib/db/regatta-cache.ts
  - src/hooks/use-offline-regatta.ts
  - src/app/(dashboard)/[teamSlug]/regattas/[id]/regatta-detail-client.tsx
autonomous: true

must_haves:
  truths:
    - "Regatta and entry data cached in IndexedDB"
    - "Offline users can view regatta schedule"
    - "Staleness indicator shows when data is from cache"
    - "Data syncs when connection restored"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "OfflineRegatta and OfflineEntry tables"
      contains: "regattas!: Table<OfflineRegatta>"
    - path: "src/lib/db/regatta-cache.ts"
      provides: "Cache manager for regatta data"
      exports: ["cacheRegatta", "getCachedRegatta", "clearRegattaCache"]
    - path: "src/hooks/use-offline-regatta.ts"
      provides: "React hook for offline regatta data"
      exports: ["useOfflineRegatta"]
  key_links:
    - from: "useOfflineRegatta"
      to: "regatta-cache.ts"
      via: "getCachedRegatta fallback"
      pattern: "getCachedRegatta.*offline"
    - from: "regatta-detail-client.tsx"
      to: "useOfflineRegatta"
      via: "hook usage for offline support"
      pattern: "useOfflineRegatta"
---

<objective>
Extend offline infrastructure to support regatta and entry caching.

Purpose: Enables REG-08 (offline capability) for viewing regattas without network at venue.
Output: Extended Dexie schema, cache manager, offline-aware hook, UI integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-regatta-mode/05-RESEARCH.md

# Prior plan output
@.planning/phases/05-regatta-mode/05-05-SUMMARY.md

# Existing offline infrastructure (from Phase 4)
@src/lib/db/schema.ts
@src/lib/db/cache-manager.ts
@src/hooks/use-offline-data.ts

# Phase 4 PWA components (dependencies)
@src/components/pwa/staleness-indicator.tsx
@src/hooks/use-online-status.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Dexie schema with regatta tables</name>
  <files>src/lib/db/schema.ts</files>
  <action>
Update src/lib/db/schema.ts to add regatta offline support. Add the following interfaces and update the AppDB class:

1. Add new interfaces after existing ones:

```typescript
// Offline regatta data
export interface OfflineRegatta {
  id: string;
  teamId: string;
  name: string;
  location?: string;
  venue?: string;
  timezone?: string;
  startDate: string;      // ISO date string
  endDate?: string;
  source: 'REGATTA_CENTRAL' | 'MANUAL';
  cachedAt: number;       // Timestamp when cached
  syncStatus: 'synced' | 'pending' | 'error';
}

// Offline entry (race) data with denormalized lineup
export interface OfflineEntry {
  id: string;
  regattaId: string;
  eventName: string;
  scheduledTime: string;  // ISO datetime string
  meetingLocation?: string;
  meetingTime?: string;
  notes?: string;
  status: 'SCHEDULED' | 'SCRATCHED' | 'COMPLETED';
  heat?: string;
  lane?: number;
  placement?: number;
  // Denormalized lineup for offline display
  lineup?: {
    boatId?: string;
    boatName?: string;
    seats: {
      position: number;
      athleteId: string;
      athleteName: string;
      side: 'PORT' | 'STARBOARD' | 'NONE';
    }[];
  };
  // Notification config
  notificationConfig?: {
    leadTimeMinutes: number;
    notificationSent: boolean;
  };
  cachedAt: number;
  syncStatus: 'synced' | 'pending' | 'error';
}
```

2. Update the AppDB class to include new tables:

```typescript
export class AppDB extends Dexie {
  schedules!: Table<OfflineSchedule>;
  lineups!: Table<OfflineLineup>;
  syncQueue!: Table<SyncQueueItem>;
  cacheMeta!: Table<CacheMeta>;
  // New tables for regatta mode
  regattas!: Table<OfflineRegatta>;
  entries!: Table<OfflineEntry>;

  constructor() {
    super('rowops-offline');

    // Version 1: Initial schema (keep for migration)
    this.version(1).stores({
      schedules: 'id, teamId, date, cachedAt, [teamId+date]',
      lineups: 'id, practiceId, blockId, cachedAt, [practiceId+blockId]',
      syncQueue: '++id, timestamp, entity',
      cacheMeta: 'key',
    });

    // Version 2: Add regatta tables
    this.version(2).stores({
      schedules: 'id, teamId, date, cachedAt, [teamId+date]',
      lineups: 'id, practiceId, blockId, cachedAt, [practiceId+blockId]',
      syncQueue: '++id, timestamp, entity',
      cacheMeta: 'key',
      regattas: 'id, teamId, startDate, cachedAt, [teamId+startDate]',
      entries: 'id, regattaId, scheduledTime, cachedAt, [regattaId+scheduledTime]',
    });
  }
}
```

The full updated file should include both the new interfaces and the updated class.
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>Dexie schema extended with regatta and entry tables</done>
</task>

<task type="auto">
  <name>Task 2: Create regatta cache manager</name>
  <files>src/lib/db/regatta-cache.ts</files>
  <action>
Create src/lib/db/regatta-cache.ts:

```typescript
/**
 * Cache manager for regatta and entry data.
 * Provides functions to cache and retrieve regatta data for offline access.
 */

import { db, OfflineRegatta, OfflineEntry } from './schema';

const CACHE_TTL_MS = 24 * 60 * 60 * 1000; // 24 hours

/**
 * Cache a regatta with its entries for offline access.
 */
export async function cacheRegatta(
  regatta: {
    id: string;
    teamId: string;
    name: string;
    location?: string | null;
    venue?: string | null;
    timezone?: string | null;
    startDate: string;
    endDate?: string | null;
    source: 'REGATTA_CENTRAL' | 'MANUAL';
  },
  entries: Array<{
    id: string;
    eventName: string;
    scheduledTime: string;
    meetingLocation?: string | null;
    meetingTime?: string | null;
    notes?: string | null;
    status: 'SCHEDULED' | 'SCRATCHED' | 'COMPLETED';
    heat?: string | null;
    lane?: number | null;
    placement?: number | null;
    entryLineup?: {
      boat?: { id: string; name: string } | null;
      seats: Array<{
        position: number;
        side: 'PORT' | 'STARBOARD' | 'NONE';
        athlete: { id: string; displayName: string | null };
      }>;
    } | null;
    notificationConfig?: {
      leadTimeMinutes: number;
      notificationSent: boolean;
    } | null;
  }>
): Promise<void> {
  const now = Date.now();

  const offlineRegatta: OfflineRegatta = {
    id: regatta.id,
    teamId: regatta.teamId,
    name: regatta.name,
    location: regatta.location || undefined,
    venue: regatta.venue || undefined,
    timezone: regatta.timezone || undefined,
    startDate: regatta.startDate,
    endDate: regatta.endDate || undefined,
    source: regatta.source,
    cachedAt: now,
    syncStatus: 'synced',
  };

  const offlineEntries: OfflineEntry[] = entries.map((e) => ({
    id: e.id,
    regattaId: regatta.id,
    eventName: e.eventName,
    scheduledTime: e.scheduledTime,
    meetingLocation: e.meetingLocation || undefined,
    meetingTime: e.meetingTime || undefined,
    notes: e.notes || undefined,
    status: e.status,
    heat: e.heat || undefined,
    lane: e.lane || undefined,
    placement: e.placement || undefined,
    lineup: e.entryLineup
      ? {
          boatId: e.entryLineup.boat?.id,
          boatName: e.entryLineup.boat?.name,
          seats: e.entryLineup.seats.map((s) => ({
            position: s.position,
            athleteId: s.athlete.id,
            athleteName: s.athlete.displayName || 'Unknown',
            side: s.side,
          })),
        }
      : undefined,
    notificationConfig: e.notificationConfig
      ? {
          leadTimeMinutes: e.notificationConfig.leadTimeMinutes,
          notificationSent: e.notificationConfig.notificationSent,
        }
      : undefined,
    cachedAt: now,
    syncStatus: 'synced',
  }));

  await db.transaction('rw', [db.regattas, db.entries, db.cacheMeta], async () => {
    // Upsert regatta
    await db.regattas.put(offlineRegatta);

    // Delete old entries for this regatta and insert new ones
    await db.entries.where('regattaId').equals(regatta.id).delete();
    await db.entries.bulkPut(offlineEntries);

    // Update cache metadata
    await db.cacheMeta.put({
      key: `regatta:${regatta.id}`,
      lastUpdated: now,
      expiresAt: now + CACHE_TTL_MS,
    });
  });
}

/**
 * Get cached regatta with entries.
 * Returns null if not cached.
 */
export async function getCachedRegatta(regattaId: string): Promise<{
  regatta: OfflineRegatta;
  entries: OfflineEntry[];
  isStale: boolean;
} | null> {
  const regatta = await db.regattas.get(regattaId);
  if (!regatta) return null;

  const entries = await db.entries
    .where('regattaId')
    .equals(regattaId)
    .sortBy('scheduledTime');

  const meta = await db.cacheMeta.get(`regatta:${regattaId}`);
  const isStale = !meta || Date.now() > meta.expiresAt;

  return { regatta, entries, isStale };
}

/**
 * Get all cached regattas for a team.
 */
export async function getCachedRegattas(teamId: string): Promise<{
  regattas: OfflineRegatta[];
  isStale: boolean;
}> {
  const regattas = await db.regattas
    .where('teamId')
    .equals(teamId)
    .sortBy('startDate');

  // Check staleness based on oldest cached regatta
  const oldestCache = regattas.length > 0
    ? Math.min(...regattas.map((r) => r.cachedAt))
    : 0;
  const isStale = oldestCache === 0 || Date.now() - oldestCache > CACHE_TTL_MS;

  return { regattas, isStale };
}

/**
 * Clear cached data for a specific regatta.
 */
export async function clearRegattaCache(regattaId: string): Promise<void> {
  await db.transaction('rw', [db.regattas, db.entries, db.cacheMeta], async () => {
    await db.regattas.delete(regattaId);
    await db.entries.where('regattaId').equals(regattaId).delete();
    await db.cacheMeta.delete(`regatta:${regattaId}`);
  });
}

/**
 * Clear all cached regattas for a team.
 */
export async function clearTeamRegattaCache(teamId: string): Promise<void> {
  const regattas = await db.regattas.where('teamId').equals(teamId).toArray();
  const regattaIds = regattas.map((r) => r.id);

  await db.transaction('rw', [db.regattas, db.entries, db.cacheMeta], async () => {
    await db.regattas.where('teamId').equals(teamId).delete();
    await db.entries.where('regattaId').anyOf(regattaIds).delete();
    for (const id of regattaIds) {
      await db.cacheMeta.delete(`regatta:${id}`);
    }
  });
}

/**
 * Clean up old regatta cache (regattas ended more than 7 days ago).
 */
export async function cleanupOldRegattaCache(): Promise<number> {
  const sevenDaysAgo = new Date();
  sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
  const cutoffDate = sevenDaysAgo.toISOString();

  const oldRegattas = await db.regattas
    .filter((r) => {
      const endDate = r.endDate || r.startDate;
      return endDate < cutoffDate;
    })
    .toArray();

  if (oldRegattas.length === 0) return 0;

  const regattaIds = oldRegattas.map((r) => r.id);

  await db.transaction('rw', [db.regattas, db.entries, db.cacheMeta], async () => {
    for (const id of regattaIds) {
      await db.regattas.delete(id);
      await db.entries.where('regattaId').equals(id).delete();
      await db.cacheMeta.delete(`regatta:${id}`);
    }
  });

  return oldRegattas.length;
}
```
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>Regatta cache manager created with CRUD operations</done>
</task>

<task type="auto">
  <name>Task 3: Create offline regatta hook and integrate with UI</name>
  <files>src/hooks/use-offline-regatta.ts, src/app/(dashboard)/[teamSlug]/regattas/[id]/regatta-detail-client.tsx</files>
  <action>
1. Create src/hooks/use-offline-regatta.ts:

```typescript
'use client';

import { useState, useEffect, useCallback } from 'react';
import { useOnlineStatus } from './use-online-status';
import { getCachedRegatta, cacheRegatta } from '@/lib/db/regatta-cache';
import type { OfflineRegatta, OfflineEntry } from '@/lib/db/schema';

interface RegattaData {
  id: string;
  teamId: string;
  name: string;
  location?: string | null;
  venue?: string | null;
  timezone?: string | null;
  startDate: string;
  endDate?: string | null;
  source: 'REGATTA_CENTRAL' | 'MANUAL';
  entries: Array<{
    id: string;
    eventName: string;
    scheduledTime: string;
    meetingLocation?: string | null;
    meetingTime?: string | null;
    notes?: string | null;
    status: 'SCHEDULED' | 'SCRATCHED' | 'COMPLETED';
    heat?: string | null;
    lane?: number | null;
    placement?: number | null;
    entryLineup?: {
      boat?: { id: string; name: string } | null;
      seats: Array<{
        position: number;
        side: 'PORT' | 'STARBOARD' | 'NONE';
        athlete: { id: string; displayName: string | null };
      }>;
    } | null;
    notificationConfig?: {
      leadTimeMinutes: number;
      notificationSent: boolean;
    } | null;
  }>;
}

interface UseOfflineRegattaResult {
  data: RegattaData | null;
  isLoading: boolean;
  isOffline: boolean;
  isStale: boolean;
  error: string | null;
  refresh: () => Promise<void>;
}

/**
 * Hook for fetching regatta data with offline fallback.
 * Caches data in IndexedDB and falls back to cache when offline.
 */
export function useOfflineRegatta(regattaId: string): UseOfflineRegattaResult {
  const isOnline = useOnlineStatus();
  const [data, setData] = useState<RegattaData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isStale, setIsStale] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchFromApi = useCallback(async (): Promise<RegattaData | null> => {
    const response = await fetch(`/api/regattas/${regattaId}`);
    if (!response.ok) {
      throw new Error('Failed to fetch regatta');
    }
    const { regatta } = await response.json();
    return {
      id: regatta.id,
      teamId: regatta.teamId,
      name: regatta.name,
      location: regatta.location,
      venue: regatta.venue,
      timezone: regatta.timezone,
      startDate: regatta.startDate,
      endDate: regatta.endDate,
      source: regatta.source,
      entries: regatta.entries.map((e: Record<string, unknown>) => ({
        id: e.id,
        eventName: e.eventName,
        scheduledTime: e.scheduledTime,
        meetingLocation: e.meetingLocation,
        meetingTime: e.meetingTime,
        notes: e.notes,
        status: e.status,
        heat: e.heat,
        lane: e.lane,
        placement: e.placement,
        entryLineup: e.entryLineup,
        notificationConfig: e.notificationConfig,
      })),
    };
  }, [regattaId]);

  const convertCacheToData = useCallback(
    (regatta: OfflineRegatta, entries: OfflineEntry[]): RegattaData => ({
      id: regatta.id,
      teamId: regatta.teamId,
      name: regatta.name,
      location: regatta.location,
      venue: regatta.venue,
      timezone: regatta.timezone,
      startDate: regatta.startDate,
      endDate: regatta.endDate,
      source: regatta.source,
      entries: entries.map((e) => ({
        id: e.id,
        eventName: e.eventName,
        scheduledTime: e.scheduledTime,
        meetingLocation: e.meetingLocation,
        meetingTime: e.meetingTime,
        notes: e.notes,
        status: e.status,
        heat: e.heat,
        lane: e.lane,
        placement: e.placement,
        entryLineup: e.lineup
          ? {
              boat: e.lineup.boatId
                ? { id: e.lineup.boatId, name: e.lineup.boatName || '' }
                : null,
              seats: e.lineup.seats.map((s) => ({
                position: s.position,
                side: s.side,
                athlete: { id: s.athleteId, displayName: s.athleteName },
              })),
            }
          : null,
        notificationConfig: e.notificationConfig,
      })),
    }),
    []
  );

  const loadData = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    try {
      if (isOnline) {
        // Try to fetch from API
        try {
          const apiData = await fetchFromApi();
          if (apiData) {
            setData(apiData);
            setIsStale(false);

            // Cache for offline use
            await cacheRegatta(
              {
                id: apiData.id,
                teamId: apiData.teamId,
                name: apiData.name,
                location: apiData.location,
                venue: apiData.venue,
                timezone: apiData.timezone,
                startDate: apiData.startDate,
                endDate: apiData.endDate,
                source: apiData.source,
              },
              apiData.entries
            );
          }
        } catch (apiError) {
          // API failed, try cache
          console.warn('API fetch failed, falling back to cache:', apiError);
          const cached = await getCachedRegatta(regattaId);
          if (cached) {
            setData(convertCacheToData(cached.regatta, cached.entries));
            setIsStale(true);
            setError('Could not refresh data. Showing cached version.');
          } else {
            throw apiError;
          }
        }
      } else {
        // Offline - use cache only
        const cached = await getCachedRegatta(regattaId);
        if (cached) {
          setData(convertCacheToData(cached.regatta, cached.entries));
          setIsStale(cached.isStale);
        } else {
          setError('No offline data available. Connect to load regatta.');
        }
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load regatta');
    } finally {
      setIsLoading(false);
    }
  }, [regattaId, isOnline, fetchFromApi, convertCacheToData]);

  // Initial load and refresh on online status change
  useEffect(() => {
    loadData();
  }, [loadData]);

  // Refresh when coming back online
  useEffect(() => {
    if (isOnline && isStale) {
      loadData();
    }
  }, [isOnline, isStale, loadData]);

  return {
    data,
    isLoading,
    isOffline: !isOnline,
    isStale,
    error,
    refresh: loadData,
  };
}
```

2. Update src/app/(dashboard)/[teamSlug]/regattas/[id]/regatta-detail-client.tsx to use the hook:

Add imports at the top:
```typescript
import { useOfflineRegatta } from '@/hooks/use-offline-regatta';
import { StalenessIndicator } from '@/components/pwa/staleness-indicator';
```

Update the component to show staleness and handle offline state:

```typescript
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { RaceTimeline } from '@/components/regatta/race-timeline';
import { StalenessIndicator } from '@/components/pwa/staleness-indicator';
import { useOnlineStatus } from '@/hooks/use-online-status';
import { Plus, Settings, WifiOff, RefreshCw } from 'lucide-react';

interface Entry {
  id: string;
  eventName: string;
  scheduledTime: string;
  meetingLocation?: string | null;
  meetingTime?: string | null;
  notes?: string | null;
  status: 'SCHEDULED' | 'SCRATCHED' | 'COMPLETED';
  heat?: string | null;
  lane?: number | null;
  placement?: number | null;
  entryLineup?: {
    boat?: { id: string; name: string } | null;
    seats: { position: number; athlete: { id: string; displayName: string | null } }[];
  } | null;
  notificationConfig?: {
    leadTimeMinutes: number;
    notificationSent: boolean;
  } | null;
}

interface RegattaDetailClientProps {
  teamSlug: string;
  regatta: {
    id: string;
    name: string;
    timezone: string;
    source: string;
    entries: Entry[];
  };
  athletes: { id: string; displayName: string | null; sidePreference?: string | null; canBow: boolean; canCox: boolean }[];
  boats: { id: string; name: string; boatClass: string | null }[];
  initialCachedAt?: number;
}

export function RegattaDetailClient({
  teamSlug,
  regatta,
  athletes,
  boats,
  initialCachedAt,
}: RegattaDetailClientProps) {
  const router = useRouter();
  const isOnline = useOnlineStatus();
  const [entries, setEntries] = useState<Entry[]>(regatta.entries);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [cachedAt] = useState(initialCachedAt);

  function handleEntryClick(entry: Entry) {
    router.push(`/${teamSlug}/regattas/${regatta.id}/entries/${entry.id}`);
  }

  async function handleRefresh() {
    if (!isOnline || isRefreshing) return;
    setIsRefreshing(true);
    try {
      router.refresh();
    } finally {
      setIsRefreshing(false);
    }
  }

  return (
    <div>
      {/* Offline indicator */}
      {!isOnline && (
        <div className="flex items-center gap-2 mb-4 px-3 py-2 bg-amber-50 border border-amber-200 rounded-lg text-amber-700 text-sm">
          <WifiOff className="h-4 w-4" />
          <span>You are offline. Showing cached data.</span>
        </div>
      )}

      {/* Actions bar */}
      <div className="flex justify-between items-center mb-6">
        <div className="flex items-center gap-3">
          <h2 className="text-lg font-semibold">Race Schedule</h2>
          {cachedAt && (
            <StalenessIndicator
              cachedAt={cachedAt}
              staleThresholdHours={24}
            />
          )}
        </div>
        <div className="flex gap-2">
          {isOnline && (
            <button
              onClick={handleRefresh}
              disabled={isRefreshing}
              className="flex items-center gap-2 px-3 py-1.5 border rounded-lg hover:bg-gray-50 text-sm disabled:opacity-50"
            >
              <RefreshCw className={`h-4 w-4 ${isRefreshing ? 'animate-spin' : ''}`} />
              Refresh
            </button>
          )}
          {isOnline && (
            <button
              onClick={() => router.push(`/${teamSlug}/regattas/${regatta.id}/entries/new`)}
              className="flex items-center gap-2 px-3 py-1.5 bg-blue-600 text-white rounded-lg hover:bg-blue-700 text-sm"
            >
              <Plus className="h-4 w-4" />
              Add Entry
            </button>
          )}
          <button
            onClick={() => router.push(`/${teamSlug}/regattas/${regatta.id}/settings`)}
            className="flex items-center gap-2 px-3 py-1.5 border rounded-lg hover:bg-gray-50 text-sm"
          >
            <Settings className="h-4 w-4" />
            Settings
          </button>
        </div>
      </div>

      {/* Timeline */}
      <RaceTimeline
        entries={entries}
        timezone={regatta.timezone}
        onEntryClick={handleEntryClick}
      />
    </div>
  );
}
```
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>Offline regatta hook created and integrated with UI</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Dexie schema version 2 includes regattas and entries tables
3. Cache manager handles caching and retrieval
4. useOfflineRegatta hook fetches from API when online, falls back to cache when offline
5. UI shows offline indicator and staleness when applicable
</verification>

<success_criteria>
- OfflineRegatta and OfflineEntry interfaces defined
- Dexie schema upgraded to version 2 with new tables
- cacheRegatta stores regatta with denormalized entries
- getCachedRegatta retrieves with staleness check
- cleanupOldRegattaCache removes regattas older than 7 days
- useOfflineRegatta hook provides online/offline data access
- UI shows offline indicator when not connected
- StalenessIndicator shows when data is from cache
- REG-08 requirement satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/05-regatta-mode/05-07-SUMMARY.md`
</output>
