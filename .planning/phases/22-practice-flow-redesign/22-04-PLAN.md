---
phase: 22-practice-flow-redesign
plan: 04
type: execute
wave: 2
depends_on: ["22-02"]
files_modified:
  - src/components/practices/inline-block-editor.tsx
  - src/components/practices/block-type-buttons.tsx
  - src/components/practices/sortable-block-list.tsx
autonomous: true
must_haves:
  truths:
    - "Blocks display with inline editable title and notes"
    - "Type buttons are visible directly (+Water, +Erg, +Land, +Meeting)"
    - "Blocks can be reordered via drag handle AND up/down arrows"
    - "Each block type has distinct color styling"
  artifacts:
    - path: "src/components/practices/inline-block-editor.tsx"
      provides: "Inline block editing component"
      exports: ["InlineBlockEditor"]
    - path: "src/components/practices/block-type-buttons.tsx"
      provides: "Direct type buttons for adding blocks"
      exports: ["BlockTypeButtons"]
    - path: "src/components/practices/sortable-block-list.tsx"
      provides: "Drag-drop block list with reordering"
      exports: ["SortableBlockList"]
  key_links:
    - from: "src/components/practices/inline-block-editor.tsx"
      to: "src/components/shared/inline-text-field.tsx"
      via: "InlineTextField for title"
      pattern: "InlineTextField"
    - from: "src/components/practices/sortable-block-list.tsx"
      to: "@dnd-kit/sortable"
      via: "DndContext for drag reorder"
      pattern: "DndContext"
---

<objective>
Create inline block editing components: InlineBlockEditor for editing block details in-place, BlockTypeButtons for direct block type selection, and SortableBlockList for drag-drop reordering.

Purpose: Blocks are the core structure of practices. This plan implements the CONTEXT.md decisions: type buttons visible directly, blocks as content containers with titles, and flexible reordering with both drag and arrows.

Output: Block editing components ready for integration in the practice detail page.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/intel/summary.md

# Phase context
@.planning/phases/22-practice-flow-redesign/22-CONTEXT.md
@.planning/phases/22-practice-flow-redesign/22-RESEARCH.md

# Existing block components
@src/components/practices/block-editor.tsx
@src/components/practices/block-card.tsx

# Inline editing components (from 22-02)
@src/components/shared/inline-text-field.tsx
@src/components/shared/inline-textarea.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BlockTypeButtons component</name>
  <files>src/components/practices/block-type-buttons.tsx</files>
  <action>
Create component with visible type buttons per CONTEXT.md "Type buttons visible directly (+Water, +Erg, +Land, +Meeting)":

```typescript
'use client';

import { Waves, Dumbbell, Activity, Users } from 'lucide-react';
import { cn } from '@/lib/utils';
import type { BlockType } from '@/generated/prisma';

interface BlockTypeButtonsProps {
  /** Called when a type is selected */
  onSelect: (type: BlockType) => void;
  /** Whether buttons are disabled */
  disabled?: boolean;
  /** Additional class names */
  className?: string;
}

const blockTypes: {
  value: BlockType;
  label: string;
  icon: typeof Waves;
  bgColor: string;
  textColor: string;
  borderColor: string;
  hoverBg: string;
}[] = [
  {
    value: 'WATER',
    label: 'Water',
    icon: Waves,
    bgColor: 'bg-blue-500/10',
    textColor: 'text-blue-400',
    borderColor: 'border-blue-500/30',
    hoverBg: 'hover:bg-blue-500/20',
  },
  {
    value: 'ERG',
    label: 'Erg',
    icon: Activity,
    bgColor: 'bg-orange-500/10',
    textColor: 'text-orange-400',
    borderColor: 'border-orange-500/30',
    hoverBg: 'hover:bg-orange-500/20',
  },
  {
    value: 'LAND',
    label: 'Land',
    icon: Dumbbell,
    bgColor: 'bg-green-500/10',
    textColor: 'text-green-400',
    borderColor: 'border-green-500/30',
    hoverBg: 'hover:bg-green-500/20',
  },
  {
    value: 'MEETING',
    label: 'Meeting',
    icon: Users,
    bgColor: 'bg-purple-500/10',
    textColor: 'text-purple-400',
    borderColor: 'border-purple-500/30',
    hoverBg: 'hover:bg-purple-500/20',
  },
];

/**
 * Direct type buttons for adding blocks.
 * Always visible per CONTEXT.md, no dropdown needed.
 *
 * @example
 * <BlockTypeButtons onSelect={(type) => addBlock(type)} />
 */
export function BlockTypeButtons({
  onSelect,
  disabled = false,
  className,
}: BlockTypeButtonsProps) {
  return (
    <div className={cn('flex flex-wrap gap-2', className)}>
      {blockTypes.map((type) => {
        const Icon = type.icon;
        return (
          <button
            key={type.value}
            type="button"
            onClick={() => onSelect(type.value)}
            disabled={disabled}
            className={cn(
              'flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-medium',
              'border transition-colors',
              type.bgColor,
              type.textColor,
              type.borderColor,
              type.hoverBg,
              'disabled:opacity-50 disabled:cursor-not-allowed'
            )}
          >
            <Icon className="h-4 w-4" />
            <span>+ {type.label}</span>
          </button>
        );
      })}
    </div>
  );
}

/**
 * Helper to get block type config for styling.
 */
export function getBlockTypeConfig(type: BlockType) {
  return blockTypes.find(t => t.value === type) || blockTypes[0];
}
```

Key features:
- All four types visible directly (no dropdown)
- Each type has icon + color scheme
- Export helper for consistent styling elsewhere
- "+Water", "+Erg" format per CONTEXT.md
  </action>
  <verify>Visually inspect: All four buttons render with distinct colors</verify>
  <done>BlockTypeButtons component created with direct visibility, icons, and type-specific colors</done>
</task>

<task type="auto">
  <name>Task 2: Create InlineBlockEditor component</name>
  <files>src/components/practices/inline-block-editor.tsx</files>
  <action>
Create inline block editor with autosave fields:

```typescript
'use client';

import { useState } from 'react';
import { GripVertical, ChevronUp, ChevronDown, Trash2, ChevronRight, ChevronDown as ChevronExpand } from 'lucide-react';
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { cn } from '@/lib/utils';
import { InlineTextField } from '@/components/shared/inline-text-field';
import { InlineTextarea } from '@/components/shared/inline-textarea';
import { useAutosave } from '@/lib/hooks/use-autosave';
import { getBlockTypeConfig } from './block-type-buttons';
import type { BlockType } from '@/generated/prisma';

interface Block {
  id: string;
  type: BlockType;
  title: string | null;
  notes: string | null;
  durationMinutes: number | null;
  category: string | null;
}

interface InlineBlockEditorProps {
  /** Block data */
  block: Block;
  /** Position in list (1-based) */
  position: number;
  /** Save handler for field updates */
  onSave: (blockId: string, updates: Partial<Block>) => Promise<void>;
  /** Delete handler */
  onDelete: (blockId: string) => void;
  /** Move up handler */
  onMoveUp?: () => void;
  /** Move down handler */
  onMoveDown?: () => void;
  /** Whether this block can move up */
  canMoveUp?: boolean;
  /** Whether this block can move down */
  canMoveDown?: boolean;
  /** Whether user is coach (can edit) */
  isCoach?: boolean;
  /** Expanded content (lineup, workout, etc.) */
  children?: React.ReactNode;
}

/**
 * Inline block editor with drag handle, arrows, and autosave fields.
 *
 * Layout:
 * - Drag handle on left (coaches only)
 * - Type badge + position number
 * - Title (inline editable)
 * - Up/down arrows + delete (coaches only)
 * - Expandable section for lineup/workout
 */
export function InlineBlockEditor({
  block,
  position,
  onSave,
  onDelete,
  onMoveUp,
  onMoveDown,
  canMoveUp = false,
  canMoveDown = false,
  isCoach = false,
  children,
}: InlineBlockEditorProps) {
  const [isExpanded, setIsExpanded] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const typeConfig = getBlockTypeConfig(block.type);
  const Icon = typeConfig.icon;

  // Sortable hook for drag-drop
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: block.id, disabled: !isCoach });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  };

  // Save wrapper that tracks saving state
  const handleSave = async (updates: Partial<Block>) => {
    setIsSaving(true);
    try {
      await onSave(block.id, updates);
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={cn(
        'rounded-lg border transition-all',
        typeConfig.bgColor,
        typeConfig.borderColor,
        isDragging && 'opacity-50 shadow-lg ring-2 ring-emerald-500'
      )}
    >
      {/* Header row */}
      <div className="flex items-center gap-2 p-3">
        {/* Drag handle (coaches only) */}
        {isCoach && (
          <button
            {...attributes}
            {...listeners}
            className="p-1 text-zinc-500 hover:text-zinc-300 cursor-grab active:cursor-grabbing"
            aria-label="Drag to reorder"
          >
            <GripVertical className="h-4 w-4" />
          </button>
        )}

        {/* Position number */}
        <span className="text-sm font-medium text-zinc-500 w-5">
          {position}
        </span>

        {/* Type badge */}
        <span className={cn(
          'inline-flex items-center gap-1.5 px-2 py-0.5 rounded-full text-xs font-medium',
          typeConfig.bgColor,
          typeConfig.textColor,
          'border',
          typeConfig.borderColor
        )}>
          <Icon className="h-3 w-3" />
          {typeConfig.label}
        </span>

        {/* Title (inline editable) */}
        <div className="flex-1 min-w-0">
          {isCoach ? (
            <InlineTextField
              value={block.title || ''}
              onSave={(title) => handleSave({ title: title || null })}
              placeholder={`${typeConfig.label} block...`}
              isPending={isSaving}
              className="text-sm font-medium"
              aria-label="Block title"
            />
          ) : (
            <span className="text-sm font-medium text-zinc-200 truncate">
              {block.title || `${typeConfig.label} block`}
            </span>
          )}
        </div>

        {/* Actions (coaches only) */}
        {isCoach && (
          <div className="flex items-center gap-1">
            {/* Expand/collapse toggle */}
            {children && (
              <button
                type="button"
                onClick={() => setIsExpanded(!isExpanded)}
                className="p-1 text-zinc-400 hover:text-zinc-200 transition-colors"
                aria-label={isExpanded ? 'Collapse' : 'Expand'}
              >
                {isExpanded ? (
                  <ChevronExpand className="h-4 w-4" />
                ) : (
                  <ChevronRight className="h-4 w-4" />
                )}
              </button>
            )}

            {/* Up arrow */}
            <button
              type="button"
              onClick={onMoveUp}
              disabled={!canMoveUp}
              className="p-1 text-zinc-500 hover:text-zinc-300 disabled:opacity-30 disabled:cursor-not-allowed transition-colors"
              aria-label="Move up"
            >
              <ChevronUp className="h-4 w-4" />
            </button>

            {/* Down arrow */}
            <button
              type="button"
              onClick={onMoveDown}
              disabled={!canMoveDown}
              className="p-1 text-zinc-500 hover:text-zinc-300 disabled:opacity-30 disabled:cursor-not-allowed transition-colors"
              aria-label="Move down"
            >
              <ChevronDown className="h-4 w-4" />
            </button>

            {/* Delete */}
            <button
              type="button"
              onClick={() => onDelete(block.id)}
              className="p-1 text-zinc-500 hover:text-red-400 transition-colors"
              aria-label="Delete block"
            >
              <Trash2 className="h-4 w-4" />
            </button>
          </div>
        )}
      </div>

      {/* Notes field (always visible if has notes, expandable for coaches) */}
      {(block.notes || isCoach) && (
        <div className="px-3 pb-3 border-t border-zinc-700/30">
          {isCoach ? (
            <InlineTextarea
              value={block.notes || ''}
              onSave={(notes) => handleSave({ notes: notes || null })}
              placeholder="Add notes..."
              isPending={isSaving}
              rows={1}
              autoResize
              className="text-sm mt-2"
              aria-label="Block notes"
            />
          ) : block.notes ? (
            <p className="text-sm text-zinc-400 mt-2 whitespace-pre-wrap">
              {block.notes}
            </p>
          ) : null}
        </div>
      )}

      {/* Expanded content (lineup, workout, etc.) */}
      {isExpanded && children && (
        <div className="border-t border-zinc-700/30 p-3">
          {children}
        </div>
      )}
    </div>
  );
}
```

Key features:
- Drag handle + up/down arrows per CONTEXT.md
- Inline editable title and notes
- Type badge with icon and color
- Expandable section for lineup/workout content
- Position number visible
- Non-coach view shows read-only content
  </action>
  <verify>Run `npx tsc --noEmit` to verify types compile</verify>
  <done>InlineBlockEditor component created with drag handle, arrows, inline fields, and expandable content</done>
</task>

<task type="auto">
  <name>Task 3: Create SortableBlockList component</name>
  <files>src/components/practices/sortable-block-list.tsx</files>
  <action>
Create the sortable block list container using @dnd-kit:

```typescript
'use client';

import { useState, useCallback } from 'react';
import {
  DndContext,
  DragOverlay,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragStartEvent,
  DragEndEvent,
} from '@dnd-kit/core';
import {
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
  arrayMove,
} from '@dnd-kit/sortable';
import { InlineBlockEditor } from './inline-block-editor';
import { BlockTypeButtons, getBlockTypeConfig } from './block-type-buttons';
import type { BlockType } from '@/generated/prisma';

interface Block {
  id: string;
  type: BlockType;
  title: string | null;
  notes: string | null;
  durationMinutes: number | null;
  category: string | null;
}

interface SortableBlockListProps {
  /** Array of blocks */
  blocks: Block[];
  /** Called when block order changes (drag or arrow) */
  onReorder: (blockIds: string[]) => void;
  /** Called to save block field updates */
  onSaveBlock: (blockId: string, updates: Partial<Block>) => Promise<void>;
  /** Called to delete a block */
  onDeleteBlock: (blockId: string) => void;
  /** Called to add a new block */
  onAddBlock: (type: BlockType) => void;
  /** Whether user is coach */
  isCoach?: boolean;
  /** Render function for block content (lineup, workout, etc.) */
  renderBlockContent?: (block: Block) => React.ReactNode;
}

/**
 * Sortable block list with drag-drop reordering.
 *
 * Features:
 * - Drag-drop via @dnd-kit
 * - Keyboard accessible (arrow keys)
 * - Up/down arrow buttons as alternative
 * - Empty state with helpful message
 */
export function SortableBlockList({
  blocks,
  onReorder,
  onSaveBlock,
  onDeleteBlock,
  onAddBlock,
  isCoach = false,
  renderBlockContent,
}: SortableBlockListProps) {
  const [activeId, setActiveId] = useState<string | null>(null);

  // Sensors for drag
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8, // 8px movement before drag starts (prevents accidental)
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  // Move block via arrow buttons
  const handleMoveBlock = useCallback((index: number, direction: 'up' | 'down') => {
    const newIndex = direction === 'up' ? index - 1 : index + 1;
    if (newIndex < 0 || newIndex >= blocks.length) return;

    const newOrder = arrayMove(blocks, index, newIndex);
    onReorder(newOrder.map(b => b.id));
  }, [blocks, onReorder]);

  // Drag handlers
  const handleDragStart = (event: DragStartEvent) => {
    setActiveId(event.active.id as string);
  };

  const handleDragEnd = (event: DragEndEvent) => {
    setActiveId(null);

    const { active, over } = event;
    if (!over || active.id === over.id) return;

    const oldIndex = blocks.findIndex(b => b.id === active.id);
    const newIndex = blocks.findIndex(b => b.id === over.id);

    if (oldIndex !== newIndex) {
      const newOrder = arrayMove(blocks, oldIndex, newIndex);
      onReorder(newOrder.map(b => b.id));
    }
  };

  // Find active block for overlay
  const activeBlock = activeId ? blocks.find(b => b.id === activeId) : null;

  return (
    <div className="space-y-4">
      {/* Block type buttons (coaches only) */}
      {isCoach && (
        <BlockTypeButtons onSelect={onAddBlock} />
      )}

      {/* Block list */}
      {blocks.length > 0 ? (
        <DndContext
          sensors={sensors}
          collisionDetection={closestCenter}
          onDragStart={handleDragStart}
          onDragEnd={handleDragEnd}
        >
          <SortableContext
            items={blocks.map(b => b.id)}
            strategy={verticalListSortingStrategy}
          >
            <div className="space-y-2">
              {blocks.map((block, index) => (
                <InlineBlockEditor
                  key={block.id}
                  block={block}
                  position={index + 1}
                  onSave={onSaveBlock}
                  onDelete={onDeleteBlock}
                  onMoveUp={() => handleMoveBlock(index, 'up')}
                  onMoveDown={() => handleMoveBlock(index, 'down')}
                  canMoveUp={index > 0}
                  canMoveDown={index < blocks.length - 1}
                  isCoach={isCoach}
                >
                  {renderBlockContent?.(block)}
                </InlineBlockEditor>
              ))}
            </div>
          </SortableContext>

          {/* Drag overlay */}
          <DragOverlay>
            {activeBlock && (
              <div className="opacity-80">
                <InlineBlockEditor
                  block={activeBlock}
                  position={blocks.findIndex(b => b.id === activeBlock.id) + 1}
                  onSave={async () => {}}
                  onDelete={() => {}}
                  isCoach={false}
                />
              </div>
            )}
          </DragOverlay>
        </DndContext>
      ) : (
        <div className="text-center py-8 border border-dashed border-zinc-700 rounded-lg">
          <p className="text-zinc-500 text-sm">No blocks yet</p>
          {isCoach && (
            <p className="text-zinc-600 text-xs mt-1">
              Add a block to start planning this practice
            </p>
          )}
        </div>
      )}
    </div>
  );
}
```

Key features:
- DndContext wraps entire list
- SortableContext provides sorting behavior
- verticalListSortingStrategy for vertical drag
- Both drag and arrow buttons trigger same reorder callback
- PointerSensor has 8px activation distance to prevent accidental drags
- KeyboardSensor for accessibility
- DragOverlay shows preview during drag
- Empty state guidance for coaches
  </action>
  <verify>Run `npx tsc --noEmit` to verify types compile</verify>
  <done>SortableBlockList component created with drag-drop reordering, arrow buttons, and empty state</done>
</task>

</tasks>

<verification>
- [ ] `npx tsc --noEmit` passes
- [ ] BlockTypeButtons shows all four types with distinct colors
- [ ] InlineBlockEditor has drag handle, arrows, inline fields
- [ ] SortableBlockList supports drag reordering
- [ ] SortableBlockList supports arrow button reordering
- [ ] Empty state shows when no blocks
- [ ] Non-coach view hides editing controls
</verification>

<success_criteria>
- Type buttons visible directly (+Water, +Erg, +Land, +Meeting) per CONTEXT.md
- Blocks show inline editable title and notes
- Reordering works via both drag handle AND up/down arrows per CONTEXT.md
- Each block type has distinct color styling
- Coach vs non-coach views properly separated
</success_criteria>

<output>
After completion, create `.planning/phases/22-practice-flow-redesign/22-04-SUMMARY.md`
</output>
