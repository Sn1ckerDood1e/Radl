---
phase: 22-practice-flow-redesign
plan: 03
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - src/app/api/practices/[id]/route.ts
  - src/app/api/practices/[id]/blocks/[blockId]/route.ts
  - src/app/api/practices/[id]/blocks/[blockId]/workout/route.ts
  - src/app/api/practices/[id]/blocks/[blockId]/lineups/route.ts
  - src/app/api/workout-templates/route.ts
  - src/app/api/workout-templates/[id]/route.ts
autonomous: true
must_haves:
  truths:
    - "Practice fields can be updated individually via PATCH"
    - "Block fields can be updated individually via PATCH"
    - "Workouts can be created and updated on blocks"
    - "Workout templates can be saved and retrieved"
    - "Multiple lineups can be saved to a water block"
  artifacts:
    - path: "src/app/api/practices/[id]/route.ts"
      provides: "Practice PATCH endpoint for inline editing"
      exports: ["PATCH"]
    - path: "src/app/api/practices/[id]/blocks/[blockId]/route.ts"
      provides: "Block PATCH/DELETE endpoints"
      exports: ["PATCH", "DELETE"]
    - path: "src/app/api/practices/[id]/blocks/[blockId]/workout/route.ts"
      provides: "Workout CRUD for blocks"
      exports: ["GET", "PUT", "DELETE"]
    - path: "src/app/api/practices/[id]/blocks/[blockId]/lineups/route.ts"
      provides: "Multi-lineup bulk save endpoint"
      exports: ["GET", "PUT"]
    - path: "src/app/api/workout-templates/route.ts"
      provides: "Workout template list and create"
      exports: ["GET", "POST"]
  key_links:
    - from: "src/app/api/practices/[id]/blocks/[blockId]/workout/route.ts"
      to: "prisma.workout"
      via: "Workout model operations"
      pattern: "prisma\\.workout"
    - from: "src/app/api/practices/[id]/blocks/[blockId]/lineups/route.ts"
      to: "prisma.lineup"
      via: "Lineup model operations"
      pattern: "prisma\\.lineup"
---

<objective>
Extend the API layer to support inline editing: PATCH endpoints for partial practice/block updates, workout CRUD for blocks, and workout template management.

Purpose: Inline editing requires individual field updates without full-form submission. This plan creates the API endpoints that autosave components call on blur.

Output: PATCH endpoints for practices and blocks, workout CRUD API, workout template API.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/intel/summary.md

# Phase context
@.planning/phases/22-practice-flow-redesign/22-CONTEXT.md
@.planning/phases/22-practice-flow-redesign/22-RESEARCH.md

# Existing API routes
@src/app/api/practices/[id]/route.ts
@src/app/api/practices/[id]/blocks/route.ts

# Validation schemas
@src/lib/validations/practice.ts
@src/lib/validations/workout.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance practice and block PATCH endpoints</name>
  <files>src/app/api/practices/[id]/route.ts, src/app/api/practices/[id]/blocks/[blockId]/route.ts</files>
  <action>
Update the practice PATCH endpoint to support partial field updates for inline editing:

In `src/app/api/practices/[id]/route.ts`, ensure PATCH accepts single-field updates:
- Accept any subset of: name, date, startTime, endTime, notes, status
- Each field is optional - only update fields that are present
- Return updated practice data

Ensure validation allows partial updates:
```typescript
const updatePracticeSchema = z.object({
  name: z.string().min(1).max(100).optional(),
  date: z.string().datetime().optional(),
  startTime: z.string().datetime().optional(),
  endTime: z.string().datetime().optional(),
  notes: z.string().max(1000).optional().nullable(),
  status: z.enum(['DRAFT', 'PUBLISHED']).optional(),
}).refine(
  (data) => {
    // Only validate time order if both are provided
    if (data.startTime && data.endTime) {
      return new Date(data.endTime) > new Date(data.startTime);
    }
    return true;
  },
  { message: 'End time must be after start time', path: ['endTime'] }
);
```

Create `src/app/api/practices/[id]/blocks/[blockId]/route.ts` for individual block updates:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireTeamBySlug } from '@/lib/auth/require-team-by-slug';
import { buildAbility } from '@/lib/permissions/ability';
import { z } from 'zod';

const updateBlockSchema = z.object({
  title: z.string().max(100).optional().nullable(),
  durationMinutes: z.number().int().min(5).max(480).optional().nullable(),
  category: z.string().max(50).optional().nullable(),
  notes: z.string().max(500).optional().nullable(),
});

// GET single block
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; blockId: string }> }
) {
  try {
    const { id: practiceId, blockId } = await params;

    const block = await prisma.practiceBlock.findUnique({
      where: { id: blockId },
      include: {
        lineup: {
          include: {
            boat: true,
            seats: {
              include: { athlete: true },
              orderBy: { position: 'asc' },
            },
          },
        },
        landAssignments: {
          include: { athlete: true },
        },
        workout: {
          include: {
            intervals: { orderBy: { position: 'asc' } },
          },
        },
      },
    });

    if (!block || block.practiceId !== practiceId) {
      return NextResponse.json({ error: 'Block not found' }, { status: 404 });
    }

    return NextResponse.json({ block });
  } catch (error) {
    console.error('Error fetching block:', error);
    return NextResponse.json({ error: 'Failed to fetch block' }, { status: 500 });
  }
}

// PATCH single block field(s)
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; blockId: string }> }
) {
  try {
    const { id: practiceId, blockId } = await params;
    const { teamSlug, userId } = await requireTeamBySlug(request);
    const ability = await buildAbility(userId, teamSlug);

    if (!ability.can('update', 'Practice')) {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // Verify block belongs to practice
    const existingBlock = await prisma.practiceBlock.findUnique({
      where: { id: blockId },
      select: { practiceId: true },
    });

    if (!existingBlock || existingBlock.practiceId !== practiceId) {
      return NextResponse.json({ error: 'Block not found' }, { status: 404 });
    }

    const body = await request.json();
    const validated = updateBlockSchema.parse(body);

    const block = await prisma.practiceBlock.update({
      where: { id: blockId },
      data: validated,
    });

    return NextResponse.json({ block });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: error.errors[0].message }, { status: 400 });
    }
    console.error('Error updating block:', error);
    return NextResponse.json({ error: 'Failed to update block' }, { status: 500 });
  }
}

// DELETE block
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; blockId: string }> }
) {
  try {
    const { id: practiceId, blockId } = await params;
    const { teamSlug, userId } = await requireTeamBySlug(request);
    const ability = await buildAbility(userId, teamSlug);

    if (!ability.can('update', 'Practice')) {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // Verify block belongs to practice
    const existingBlock = await prisma.practiceBlock.findUnique({
      where: { id: blockId },
      select: { practiceId: true },
    });

    if (!existingBlock || existingBlock.practiceId !== practiceId) {
      return NextResponse.json({ error: 'Block not found' }, { status: 404 });
    }

    await prisma.practiceBlock.delete({
      where: { id: blockId },
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error deleting block:', error);
    return NextResponse.json({ error: 'Failed to delete block' }, { status: 500 });
  }
}
```
  </action>
  <verify>Test with curl: `curl -X PATCH /api/practices/{id} -d '{"name":"New Name"}'` returns updated practice</verify>
  <done>Practice and block PATCH endpoints support partial field updates for inline editing</done>
</task>

<task type="auto">
  <name>Task 2: Create workout CRUD endpoint for blocks</name>
  <files>src/app/api/practices/[id]/blocks/[blockId]/workout/route.ts</files>
  <action>
Create workout API endpoint for creating, updating, and deleting workouts on blocks:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireTeamBySlug } from '@/lib/auth/require-team-by-slug';
import { buildAbility } from '@/lib/permissions/ability';
import { createWorkoutSchema, updateWorkoutSchema } from '@/lib/validations/workout';
import { z } from 'zod';

// GET workout for block
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; blockId: string }> }
) {
  try {
    const { blockId } = await params;

    const workout = await prisma.workout.findUnique({
      where: { blockId },
      include: {
        intervals: { orderBy: { position: 'asc' } },
      },
    });

    if (!workout) {
      return NextResponse.json({ workout: null });
    }

    return NextResponse.json({ workout });
  } catch (error) {
    console.error('Error fetching workout:', error);
    return NextResponse.json({ error: 'Failed to fetch workout' }, { status: 500 });
  }
}

// PUT (create or update) workout for block
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; blockId: string }> }
) {
  try {
    const { id: practiceId, blockId } = await params;
    const { teamSlug, userId } = await requireTeamBySlug(request);
    const ability = await buildAbility(userId, teamSlug);

    if (!ability.can('update', 'Practice')) {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // Verify block belongs to practice and is ERG or WATER type
    const block = await prisma.practiceBlock.findUnique({
      where: { id: blockId },
      select: { practiceId: true, type: true },
    });

    if (!block || block.practiceId !== practiceId) {
      return NextResponse.json({ error: 'Block not found' }, { status: 404 });
    }

    if (block.type !== 'ERG' && block.type !== 'WATER') {
      return NextResponse.json(
        { error: 'Workouts only supported for ERG and WATER blocks' },
        { status: 400 }
      );
    }

    const body = await request.json();
    const validated = createWorkoutSchema.parse(body);

    // Upsert workout (create or update)
    const workout = await prisma.$transaction(async (tx) => {
      // Delete existing workout and intervals if exists
      await tx.workout.deleteMany({ where: { blockId } });

      // Create new workout with intervals
      return tx.workout.create({
        data: {
          blockId,
          type: validated.type,
          notes: validated.notes,
          visibleToAthletes: validated.visibleToAthletes,
          intervals: {
            create: validated.intervals.map((interval, index) => ({
              position: index,
              durationType: interval.durationType,
              duration: interval.duration,
              targetSplit: interval.targetSplit,
              targetStrokeRate: interval.targetStrokeRate,
              restDuration: interval.restDuration,
              restType: interval.restType,
            })),
          },
        },
        include: {
          intervals: { orderBy: { position: 'asc' } },
        },
      });
    });

    return NextResponse.json({ workout });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: error.errors[0].message }, { status: 400 });
    }
    console.error('Error saving workout:', error);
    return NextResponse.json({ error: 'Failed to save workout' }, { status: 500 });
  }
}

// DELETE workout from block
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; blockId: string }> }
) {
  try {
    const { id: practiceId, blockId } = await params;
    const { teamSlug, userId } = await requireTeamBySlug(request);
    const ability = await buildAbility(userId, teamSlug);

    if (!ability.can('update', 'Practice')) {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // Verify block belongs to practice
    const block = await prisma.practiceBlock.findUnique({
      where: { id: blockId },
      select: { practiceId: true },
    });

    if (!block || block.practiceId !== practiceId) {
      return NextResponse.json({ error: 'Block not found' }, { status: 404 });
    }

    await prisma.workout.deleteMany({ where: { blockId } });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error deleting workout:', error);
    return NextResponse.json({ error: 'Failed to delete workout' }, { status: 500 });
  }
}
```

Key implementation notes:
- PUT uses upsert pattern: deletes existing workout if any, creates new one
- Workouts only valid on ERG and WATER blocks (not LAND/MEETING)
- Intervals created with position index from array order
- Transaction ensures atomic workout+intervals creation
  </action>
  <verify>Test with curl: Create workout then GET to verify intervals stored correctly</verify>
  <done>Workout CRUD endpoint created for blocks with interval support</done>
</task>

<task type="auto">
  <name>Task 3: Create workout template API</name>
  <files>src/app/api/workout-templates/route.ts, src/app/api/workout-templates/[id]/route.ts</files>
  <action>
Create workout template list and create endpoint:

`src/app/api/workout-templates/route.ts`:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireTeamBySlug } from '@/lib/auth/require-team-by-slug';
import { buildAbility } from '@/lib/permissions/ability';
import { createWorkoutTemplateSchema } from '@/lib/validations/workout';
import { z } from 'zod';

// GET list of workout templates for team
export async function GET(request: NextRequest) {
  try {
    const { teamId, teamSlug } = await requireTeamBySlug(request);

    const templates = await prisma.workoutTemplate.findMany({
      where: { teamId },
      include: {
        intervals: { orderBy: { position: 'asc' } },
      },
      orderBy: { name: 'asc' },
    });

    return NextResponse.json({ templates });
  } catch (error) {
    console.error('Error fetching workout templates:', error);
    return NextResponse.json({ error: 'Failed to fetch templates' }, { status: 500 });
  }
}

// POST create new workout template
export async function POST(request: NextRequest) {
  try {
    const { teamId, teamSlug, userId } = await requireTeamBySlug(request);
    const ability = await buildAbility(userId, teamSlug);

    if (!ability.can('create', 'Practice')) {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    const body = await request.json();
    const validated = createWorkoutTemplateSchema.parse(body);

    const template = await prisma.workoutTemplate.create({
      data: {
        teamId,
        name: validated.name,
        type: validated.type,
        notes: validated.notes,
        intervals: {
          create: validated.intervals.map((interval, index) => ({
            position: index,
            durationType: interval.durationType,
            duration: interval.duration,
            targetSplit: interval.targetSplit,
            targetStrokeRate: interval.targetStrokeRate,
            restDuration: interval.restDuration,
            restType: interval.restType,
          })),
        },
      },
      include: {
        intervals: { orderBy: { position: 'asc' } },
      },
    });

    return NextResponse.json({ template }, { status: 201 });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: error.errors[0].message }, { status: 400 });
    }
    console.error('Error creating workout template:', error);
    return NextResponse.json({ error: 'Failed to create template' }, { status: 500 });
  }
}
```

`src/app/api/workout-templates/[id]/route.ts`:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireTeamBySlug } from '@/lib/auth/require-team-by-slug';
import { buildAbility } from '@/lib/permissions/ability';
import { updateWorkoutTemplateSchema } from '@/lib/validations/workout';
import { z } from 'zod';

// GET single template
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const { teamId } = await requireTeamBySlug(request);

    const template = await prisma.workoutTemplate.findFirst({
      where: { id, teamId },
      include: {
        intervals: { orderBy: { position: 'asc' } },
      },
    });

    if (!template) {
      return NextResponse.json({ error: 'Template not found' }, { status: 404 });
    }

    return NextResponse.json({ template });
  } catch (error) {
    console.error('Error fetching template:', error);
    return NextResponse.json({ error: 'Failed to fetch template' }, { status: 500 });
  }
}

// PATCH update template
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const { teamId, teamSlug, userId } = await requireTeamBySlug(request);
    const ability = await buildAbility(userId, teamSlug);

    if (!ability.can('update', 'Practice')) {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // Verify template belongs to team
    const existing = await prisma.workoutTemplate.findFirst({
      where: { id, teamId },
    });

    if (!existing) {
      return NextResponse.json({ error: 'Template not found' }, { status: 404 });
    }

    const body = await request.json();
    const validated = updateWorkoutTemplateSchema.parse(body);

    // Update with optional intervals replacement
    const template = await prisma.$transaction(async (tx) => {
      // If intervals provided, replace all
      if (validated.intervals) {
        await tx.workoutTemplateInterval.deleteMany({
          where: { templateId: id },
        });
      }

      return tx.workoutTemplate.update({
        where: { id },
        data: {
          name: validated.name,
          type: validated.type,
          notes: validated.notes,
          ...(validated.intervals && {
            intervals: {
              create: validated.intervals.map((interval, index) => ({
                position: index,
                durationType: interval.durationType,
                duration: interval.duration,
                targetSplit: interval.targetSplit,
                targetStrokeRate: interval.targetStrokeRate,
                restDuration: interval.restDuration,
                restType: interval.restType,
              })),
            },
          }),
        },
        include: {
          intervals: { orderBy: { position: 'asc' } },
        },
      });
    });

    return NextResponse.json({ template });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: error.errors[0].message }, { status: 400 });
    }
    console.error('Error updating template:', error);
    return NextResponse.json({ error: 'Failed to update template' }, { status: 500 });
  }
}

// DELETE template
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const { teamId, teamSlug, userId } = await requireTeamBySlug(request);
    const ability = await buildAbility(userId, teamSlug);

    if (!ability.can('delete', 'Practice')) {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // Verify template belongs to team
    const existing = await prisma.workoutTemplate.findFirst({
      where: { id, teamId },
    });

    if (!existing) {
      return NextResponse.json({ error: 'Template not found' }, { status: 404 });
    }

    await prisma.workoutTemplate.delete({ where: { id } });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error deleting template:', error);
    return NextResponse.json({ error: 'Failed to delete template' }, { status: 500 });
  }
}
```
  </action>
  <verify>Test with curl: Create template, list templates, update template, delete template</verify>
  <done>Workout template CRUD API created with team scoping</done>
</task>

<task type="auto">
  <name>Task 4: Create multi-lineup bulk save endpoint</name>
  <files>src/app/api/practices/[id]/blocks/[blockId]/lineups/route.ts</files>
  <action>
Create the bulk lineup save endpoint for multi-boat water blocks:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireTeamBySlug } from '@/lib/auth/require-team-by-slug';
import { buildAbility } from '@/lib/permissions/ability';
import { z } from 'zod';

const seatSchema = z.object({
  position: z.number().int().min(1),
  side: z.enum(['PORT', 'STARBOARD', 'NONE']),
  athleteId: z.string().uuid().nullable(),
});

const lineupSchema = z.object({
  id: z.string(), // Can be UUID or "new-{timestamp}" for new lineups
  boatId: z.string().uuid().nullable(),
  seats: z.array(seatSchema),
});

const bulkLineupsSchema = z.object({
  lineups: z.array(lineupSchema).max(10), // Max 10 boats per block
});

// PUT: Bulk save lineups for a block
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; blockId: string }> }
) {
  try {
    const { id: practiceId, blockId } = await params;
    const { teamSlug, userId } = await requireTeamBySlug(request);
    const ability = await buildAbility(userId, teamSlug);

    if (!ability.can('update', 'Practice')) {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // Verify block belongs to practice and is WATER type
    const block = await prisma.practiceBlock.findUnique({
      where: { id: blockId },
      select: { practiceId: true, type: true },
    });

    if (!block || block.practiceId !== practiceId) {
      return NextResponse.json({ error: 'Block not found' }, { status: 404 });
    }

    if (block.type !== 'WATER') {
      return NextResponse.json(
        { error: 'Lineups only supported for WATER blocks' },
        { status: 400 }
      );
    }

    const body = await request.json();
    const validated = bulkLineupsSchema.parse(body);

    // Process lineups in transaction
    await prisma.$transaction(async (tx) => {
      // Get existing lineups for this block
      const existingLineups = await tx.lineup.findMany({
        where: { blockId },
        select: { id: true },
      });
      const existingIds = new Set(existingLineups.map(l => l.id));

      // Determine which lineups to create, update, or delete
      const submittedIds = new Set<string>();
      const isNewId = (id: string) => id.startsWith('new-');

      for (const lineup of validated.lineups) {
        if (isNewId(lineup.id)) {
          // Create new lineup
          await tx.lineup.create({
            data: {
              blockId,
              boatId: lineup.boatId,
              seats: {
                create: lineup.seats
                  .filter(s => s.athleteId)
                  .map(s => ({
                    position: s.position,
                    side: s.side,
                    athleteId: s.athleteId!,
                  })),
              },
            },
          });
        } else {
          // Update existing lineup
          submittedIds.add(lineup.id);

          // Update lineup itself
          await tx.lineup.update({
            where: { id: lineup.id },
            data: { boatId: lineup.boatId },
          });

          // Delete all existing seats
          await tx.seatAssignment.deleteMany({
            where: { lineupId: lineup.id },
          });

          // Create new seats
          await tx.seatAssignment.createMany({
            data: lineup.seats
              .filter(s => s.athleteId)
              .map(s => ({
                lineupId: lineup.id,
                position: s.position,
                side: s.side,
                athleteId: s.athleteId!,
              })),
          });
        }
      }

      // Delete lineups that weren't submitted (removed by user)
      const lineupsToDelete = [...existingIds].filter(id => !submittedIds.has(id));
      if (lineupsToDelete.length > 0) {
        await tx.lineup.deleteMany({
          where: { id: { in: lineupsToDelete } },
        });
      }
    });

    // Fetch updated lineups
    const lineups = await prisma.lineup.findMany({
      where: { blockId },
      include: {
        boat: true,
        seats: {
          orderBy: { position: 'asc' },
          include: {
            athlete: {
              select: { id: true, displayName: true, sidePreference: true },
            },
          },
        },
      },
    });

    return NextResponse.json({ lineups });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: error.errors[0].message }, { status: 400 });
    }
    console.error('Error saving lineups:', error);
    return NextResponse.json({ error: 'Failed to save lineups' }, { status: 500 });
  }
}

// GET: Fetch lineups for a block
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; blockId: string }> }
) {
  try {
    const { blockId } = await params;

    const lineups = await prisma.lineup.findMany({
      where: { blockId },
      include: {
        boat: true,
        seats: {
          orderBy: { position: 'asc' },
          include: {
            athlete: {
              select: { id: true, displayName: true, sidePreference: true },
            },
          },
        },
      },
    });

    return NextResponse.json({ lineups });
  } catch (error) {
    console.error('Error fetching lineups:', error);
    return NextResponse.json({ error: 'Failed to fetch lineups' }, { status: 500 });
  }
}
```

Key features:
- Bulk save all lineups for a block in one request
- Creates new lineups (id starts with "new-")
- Updates existing lineups
- Deletes removed lineups
- Transaction ensures consistency
- Max 10 boats per block
  </action>
  <verify>Test with curl: Save multiple lineups to a block, verify they persist</verify>
  <done>Multi-lineup bulk save endpoint created with create/update/delete support</done>
</task>

</tasks>

<verification>
- [ ] Practice PATCH accepts single-field updates
- [ ] Block PATCH updates individual fields
- [ ] Block DELETE removes block
- [ ] Workout PUT creates workout with intervals
- [ ] Workout GET returns workout with intervals
- [ ] Workout DELETE removes workout
- [ ] Workout template CRUD all work
- [ ] Multi-lineup PUT saves multiple lineups
- [ ] Multi-lineup GET returns all block lineups
- [ ] Authorization checks on all endpoints
</verification>

<success_criteria>
- Inline editing has API support: PATCH any single field
- Workouts can be created on ERG/WATER blocks
- Workout templates can be saved and retrieved
- Multi-lineup bulk save for water blocks
- All endpoints enforce CASL permissions
- Partial updates don't require sending all fields
</success_criteria>

<output>
After completion, create `.planning/phases/22-practice-flow-redesign/22-03-SUMMARY.md`
</output>
