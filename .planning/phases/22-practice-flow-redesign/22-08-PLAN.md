---
phase: 22-practice-flow-redesign
plan: 08
type: execute
wave: 4
depends_on: ["22-01", "22-03"]
files_modified:
  - src/app/api/practices/bulk/route.ts
  - src/components/practices/bulk-practice-creator.tsx
  - src/app/(dashboard)/[teamSlug]/practices/page.tsx
  - src/app/(dashboard)/[teamSlug]/practices/bulk-create/page.tsx
autonomous: true
must_haves:
  truths:
    - "Coach can select date range and days of week"
    - "Practices are generated for matching dates within range"
    - "Optional template can be applied to all created practices"
    - "Bulk delete allows selecting multiple practices"
  artifacts:
    - path: "src/app/api/practices/bulk/route.ts"
      provides: "Bulk practice creation API"
      exports: ["POST"]
    - path: "src/components/practices/bulk-practice-creator.tsx"
      provides: "Bulk practice creator UI"
      exports: ["BulkPracticeCreator"]
    - path: "src/app/(dashboard)/[teamSlug]/practices/bulk-create/page.tsx"
      provides: "Bulk create page"
  key_links:
    - from: "src/components/practices/bulk-practice-creator.tsx"
      to: "react-day-picker"
      via: "DayPicker for date range"
      pattern: "DayPicker"
    - from: "src/components/practices/bulk-practice-creator.tsx"
      to: "date-fns"
      via: "eachDayOfInterval for date generation"
      pattern: "eachDayOfInterval"
---

<objective>
Create bulk practice creation and deletion: date range picker with day selection, optional template application, and multi-select delete from practice list.

Purpose: CONTEXT.md specifies bulk practice creation with "Date range picker (start/end dates)" and "Day + time picker (Mon, Wed, Fri at 6:00 AM)" and "Bulk delete - Checkbox selection on practice list".

Output: Bulk practice creator page, bulk API endpoint, and enhanced practice list with multi-select delete.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/intel/summary.md

# Phase context
@.planning/phases/22-practice-flow-redesign/22-CONTEXT.md
@.planning/phases/22-practice-flow-redesign/22-RESEARCH.md

# Existing practice pages
@src/app/(dashboard)/[teamSlug]/practices/page.tsx

# Date utilities
@src/lib/utils/date-time-helpers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create bulk practice API endpoint</name>
  <files>src/app/api/practices/bulk/route.ts</files>
  <action>
Create the bulk practice creation and deletion API:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireTeamBySlug } from '@/lib/auth/require-team-by-slug';
import { buildAbility } from '@/lib/permissions/ability';
import { z } from 'zod';

// Schema for bulk create
const bulkCreateSchema = z.object({
  seasonId: z.string().uuid(),
  dates: z.array(z.string().datetime()).min(1).max(100),
  startTime: z.string().regex(/^\d{2}:\d{2}$/), // HH:MM
  endTime: z.string().regex(/^\d{2}:\d{2}$/),
  namePattern: z.string().max(100).optional(), // e.g., "Morning Practice"
  templateId: z.string().uuid().optional(),
});

// Schema for bulk delete
const bulkDeleteSchema = z.object({
  practiceIds: z.array(z.string().uuid()).min(1).max(100),
});

// POST: Bulk create practices
export async function POST(request: NextRequest) {
  try {
    const { teamId, teamSlug, userId } = await requireTeamBySlug(request);
    const ability = await buildAbility(userId, teamSlug);

    if (!ability.can('create', 'Practice')) {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    const body = await request.json();
    const validated = bulkCreateSchema.parse(body);

    // Verify season belongs to team
    const season = await prisma.season.findFirst({
      where: { id: validated.seasonId, teamId },
    });

    if (!season) {
      return NextResponse.json({ error: 'Season not found' }, { status: 404 });
    }

    // Fetch template if provided
    let templateBlocks: any[] = [];
    if (validated.templateId) {
      const template = await prisma.practiceTemplate.findFirst({
        where: { id: validated.templateId, teamId },
        include: {
          blocks: { orderBy: { position: 'asc' } },
        },
      });

      if (template) {
        templateBlocks = template.blocks;
      }
    }

    // Create all practices in a transaction
    const practices = await prisma.$transaction(
      validated.dates.map((dateStr, index) => {
        const date = new Date(dateStr);
        const [startHour, startMin] = validated.startTime.split(':').map(Number);
        const [endHour, endMin] = validated.endTime.split(':').map(Number);

        const startTime = new Date(date);
        startTime.setHours(startHour, startMin, 0, 0);

        const endTime = new Date(date);
        endTime.setHours(endHour, endMin, 0, 0);

        // Generate practice name
        const name = validated.namePattern
          ? validated.namePattern
          : `Practice - ${date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' })}`;

        return prisma.practice.create({
          data: {
            teamId,
            seasonId: validated.seasonId,
            name,
            date,
            startTime,
            endTime,
            status: 'DRAFT',
            // Create blocks from template if provided
            blocks: templateBlocks.length > 0
              ? {
                  create: templateBlocks.map((block, pos) => ({
                    position: pos,
                    type: block.type,
                    title: block.notes, // Use template notes as title
                    durationMinutes: block.durationMinutes,
                    category: block.category,
                    notes: block.notes,
                  })),
                }
              : undefined,
          },
        });
      })
    );

    return NextResponse.json(
      {
        success: true,
        count: practices.length,
        practiceIds: practices.map(p => p.id),
      },
      { status: 201 }
    );
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: error.errors[0].message }, { status: 400 });
    }
    console.error('Error creating practices:', error);
    return NextResponse.json({ error: 'Failed to create practices' }, { status: 500 });
  }
}

// DELETE: Bulk delete practices
export async function DELETE(request: NextRequest) {
  try {
    const { teamId, teamSlug, userId } = await requireTeamBySlug(request);
    const ability = await buildAbility(userId, teamSlug);

    if (!ability.can('delete', 'Practice')) {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    const body = await request.json();
    const validated = bulkDeleteSchema.parse(body);

    // Delete only practices that belong to this team
    const result = await prisma.practice.deleteMany({
      where: {
        id: { in: validated.practiceIds },
        teamId,
      },
    });

    return NextResponse.json({
      success: true,
      deleted: result.count,
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: error.errors[0].message }, { status: 400 });
    }
    console.error('Error deleting practices:', error);
    return NextResponse.json({ error: 'Failed to delete practices' }, { status: 500 });
  }
}
```

Key features:
- POST creates multiple practices with optional template
- DELETE removes multiple practices by ID
- Max 100 practices per request
- Transaction ensures all-or-nothing creation
- Template blocks copied to each practice
  </action>
  <verify>Test with curl: Create multiple practices, then delete them</verify>
  <done>Bulk practice API endpoint created with create and delete operations</done>
</task>

<task type="auto">
  <name>Task 2: Create BulkPracticeCreator component</name>
  <files>src/components/practices/bulk-practice-creator.tsx</files>
  <action>
Create the bulk practice creator UI component:

```typescript
'use client';

import { useState, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import { DayPicker, DateRange } from 'react-day-picker';
import { eachDayOfInterval, getDay, format, addDays } from 'date-fns';
import { Calendar, Clock, FileText, Loader2 } from 'lucide-react';
import { toast } from 'sonner';
import { cn } from '@/lib/utils';
import 'react-day-picker/style.css';

interface PracticeTemplate {
  id: string;
  name: string;
  defaultStartTime: string;
  defaultEndTime: string;
}

interface Season {
  id: string;
  name: string;
}

interface BulkPracticeCreatorProps {
  /** Team slug for navigation */
  teamSlug: string;
  /** Available seasons */
  seasons: Season[];
  /** Available practice templates */
  templates: PracticeTemplate[];
}

type DayOfWeek = 0 | 1 | 2 | 3 | 4 | 5 | 6;

const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

/**
 * Bulk practice creator with date range picker and day selection.
 *
 * CONTEXT.md decisions:
 * - Date range picker (start/end dates)
 * - Day + time picker (Mon, Wed, Fri at 6:00 AM)
 * - Optional template: can apply practice template or create empty practices
 */
export function BulkPracticeCreator({
  teamSlug,
  seasons,
  templates,
}: BulkPracticeCreatorProps) {
  const router = useRouter();
  const [range, setRange] = useState<DateRange | undefined>();
  const [selectedDays, setSelectedDays] = useState<DayOfWeek[]>([1, 3, 5]); // Mon, Wed, Fri default
  const [startTime, setStartTime] = useState('06:00');
  const [endTime, setEndTime] = useState('08:00');
  const [seasonId, setSeasonId] = useState(seasons[0]?.id || '');
  const [templateId, setTemplateId] = useState<string>('');
  const [namePattern, setNamePattern] = useState('');
  const [isCreating, setIsCreating] = useState(false);

  // Calculate matching dates
  const practiceDates = useMemo(() => {
    if (!range?.from || !range?.to) return [];

    const allDates = eachDayOfInterval({ start: range.from, end: range.to });
    return allDates.filter(date => selectedDays.includes(getDay(date) as DayOfWeek));
  }, [range, selectedDays]);

  // Toggle day selection
  const toggleDay = (day: DayOfWeek) => {
    setSelectedDays(prev =>
      prev.includes(day)
        ? prev.filter(d => d !== day)
        : [...prev, day].sort()
    );
  };

  // Apply template defaults
  const handleTemplateChange = (id: string) => {
    setTemplateId(id);
    if (id) {
      const template = templates.find(t => t.id === id);
      if (template) {
        setStartTime(template.defaultStartTime);
        setEndTime(template.defaultEndTime);
      }
    }
  };

  // Create practices
  const handleCreate = async () => {
    if (!seasonId) {
      toast.error('Please select a season');
      return;
    }

    if (practiceDates.length === 0) {
      toast.error('No practices to create', {
        description: 'Select a date range and at least one day of the week',
      });
      return;
    }

    if (practiceDates.length > 100) {
      toast.error('Too many practices', {
        description: 'Maximum 100 practices can be created at once',
      });
      return;
    }

    setIsCreating(true);

    try {
      const response = await fetch('/api/practices/bulk', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          seasonId,
          dates: practiceDates.map(d => d.toISOString()),
          startTime,
          endTime,
          namePattern: namePattern || undefined,
          templateId: templateId || undefined,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to create practices');
      }

      toast.success(`Created ${data.count} practices`);
      router.push(`/${teamSlug}/practices`);
      router.refresh();
    } catch (error) {
      toast.error('Failed to create practices', {
        description: error instanceof Error ? error.message : 'Unknown error',
      });
    } finally {
      setIsCreating(false);
    }
  };

  return (
    <div className="space-y-6">
      {/* Season selector */}
      <div>
        <label className="block text-sm font-medium text-zinc-300 mb-2">
          Season
        </label>
        <select
          value={seasonId}
          onChange={(e) => setSeasonId(e.target.value)}
          className="w-full px-3 py-2 bg-zinc-800 border border-zinc-700 rounded-lg text-zinc-200 focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 outline-none"
        >
          {seasons.map(season => (
            <option key={season.id} value={season.id}>
              {season.name}
            </option>
          ))}
        </select>
      </div>

      {/* Date range picker */}
      <div>
        <label className="block text-sm font-medium text-zinc-300 mb-2">
          <Calendar className="inline h-4 w-4 mr-1" />
          Date Range
        </label>
        <div className="bg-zinc-800 rounded-lg p-4 border border-zinc-700">
          <DayPicker
            mode="range"
            selected={range}
            onSelect={setRange}
            disabled={{ before: new Date() }}
            className="rdp-custom"
          />
        </div>
        {range?.from && range?.to && (
          <p className="text-sm text-zinc-400 mt-2">
            {format(range.from, 'MMM d, yyyy')} - {format(range.to, 'MMM d, yyyy')}
          </p>
        )}
      </div>

      {/* Day of week selector */}
      <div>
        <label className="block text-sm font-medium text-zinc-300 mb-2">
          Days of Week
        </label>
        <div className="flex flex-wrap gap-2">
          {dayNames.map((name, index) => (
            <button
              key={name}
              type="button"
              onClick={() => toggleDay(index as DayOfWeek)}
              className={cn(
                'px-3 py-2 rounded-lg text-sm font-medium transition-colors',
                selectedDays.includes(index as DayOfWeek)
                  ? 'bg-emerald-600 text-white'
                  : 'bg-zinc-800 text-zinc-400 border border-zinc-700 hover:bg-zinc-700'
              )}
            >
              {name}
            </button>
          ))}
        </div>
      </div>

      {/* Time inputs */}
      <div className="grid grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium text-zinc-300 mb-2">
            <Clock className="inline h-4 w-4 mr-1" />
            Start Time
          </label>
          <input
            type="time"
            value={startTime}
            onChange={(e) => setStartTime(e.target.value)}
            className="w-full px-3 py-2 bg-zinc-800 border border-zinc-700 rounded-lg text-zinc-200 focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 outline-none [color-scheme:dark]"
          />
        </div>
        <div>
          <label className="block text-sm font-medium text-zinc-300 mb-2">
            End Time
          </label>
          <input
            type="time"
            value={endTime}
            onChange={(e) => setEndTime(e.target.value)}
            className="w-full px-3 py-2 bg-zinc-800 border border-zinc-700 rounded-lg text-zinc-200 focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 outline-none [color-scheme:dark]"
          />
        </div>
      </div>

      {/* Template selector */}
      <div>
        <label className="block text-sm font-medium text-zinc-300 mb-2">
          <FileText className="inline h-4 w-4 mr-1" />
          Practice Template (optional)
        </label>
        <select
          value={templateId}
          onChange={(e) => handleTemplateChange(e.target.value)}
          className="w-full px-3 py-2 bg-zinc-800 border border-zinc-700 rounded-lg text-zinc-200 focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 outline-none"
        >
          <option value="">No template - create empty practices</option>
          {templates.map(template => (
            <option key={template.id} value={template.id}>
              {template.name}
            </option>
          ))}
        </select>
      </div>

      {/* Practice name pattern */}
      <div>
        <label className="block text-sm font-medium text-zinc-300 mb-2">
          Practice Name (optional)
        </label>
        <input
          type="text"
          value={namePattern}
          onChange={(e) => setNamePattern(e.target.value)}
          placeholder="e.g., Morning Practice"
          className="w-full px-3 py-2 bg-zinc-800 border border-zinc-700 rounded-lg text-zinc-200 placeholder-zinc-500 focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 outline-none"
        />
        <p className="text-xs text-zinc-500 mt-1">
          Leave empty to auto-generate names with dates
        </p>
      </div>

      {/* Preview and create */}
      <div className="pt-4 border-t border-zinc-800">
        <div className="flex items-center justify-between mb-4">
          <span className="text-sm text-zinc-400">
            {practiceDates.length} practice{practiceDates.length !== 1 ? 's' : ''} will be created
          </span>
          {practiceDates.length > 0 && (
            <span className="text-sm text-zinc-500">
              First: {format(practiceDates[0], 'MMM d')}
              {practiceDates.length > 1 && ` - Last: ${format(practiceDates[practiceDates.length - 1], 'MMM d')}`}
            </span>
          )}
        </div>

        <button
          type="button"
          onClick={handleCreate}
          disabled={isCreating || practiceDates.length === 0}
          className="w-full py-3 bg-emerald-600 hover:bg-emerald-500 disabled:opacity-50 disabled:cursor-not-allowed rounded-lg text-sm font-medium text-white transition-colors flex items-center justify-center gap-2"
        >
          {isCreating ? (
            <>
              <Loader2 className="h-4 w-4 animate-spin" />
              Creating...
            </>
          ) : (
            <>Create {practiceDates.length} Practice{practiceDates.length !== 1 ? 's' : ''}</>
          )}
        </button>
      </div>

      {/* Custom styles for DayPicker dark theme */}
      <style jsx global>{`
        .rdp-custom {
          --rdp-accent-color: #10b981;
          --rdp-background-color: #27272a;
        }
        .rdp-custom .rdp-day {
          color: #e4e4e7;
        }
        .rdp-custom .rdp-day:hover {
          background-color: #3f3f46;
        }
        .rdp-custom .rdp-day_selected {
          background-color: #10b981;
          color: white;
        }
        .rdp-custom .rdp-day_range_middle {
          background-color: #10b98133;
        }
        .rdp-custom .rdp-nav_button {
          color: #a1a1aa;
        }
        .rdp-custom .rdp-nav_button:hover {
          background-color: #3f3f46;
        }
        .rdp-custom .rdp-caption_label {
          color: #e4e4e7;
        }
        .rdp-custom .rdp-head_cell {
          color: #71717a;
        }
      `}</style>
    </div>
  );
}
```

Key features:
- Date range picker with react-day-picker
- Day of week toggles (default Mon/Wed/Fri)
- Time inputs for start/end
- Optional template selection with auto-fill times
- Preview of practice count
- Dark theme styling for DayPicker
  </action>
  <verify>Run `npx tsc --noEmit` to verify types</verify>
  <done>BulkPracticeCreator component created with date range, day selection, and template support</done>
</task>

<task type="auto">
  <name>Task 3: Create bulk create page and enhance practice list</name>
  <files>src/app/(dashboard)/[teamSlug]/practices/bulk-create/page.tsx, src/app/(dashboard)/[teamSlug]/practices/page.tsx</files>
  <action>
Create the bulk create page:

```typescript
// src/app/(dashboard)/[teamSlug]/practices/bulk-create/page.tsx
import { notFound } from 'next/navigation';
import Link from 'next/link';
import { ArrowLeft } from 'lucide-react';
import { prisma } from '@/lib/prisma';
import { requireTeamBySlug } from '@/lib/auth/require-team-by-slug';
import { buildAbility } from '@/lib/permissions/ability';
import { BulkPracticeCreator } from '@/components/practices/bulk-practice-creator';

interface PageProps {
  params: Promise<{ teamSlug: string }>;
}

export default async function BulkCreatePracticesPage({ params }: PageProps) {
  const { teamSlug } = await params;
  const { teamId, userId } = await requireTeamBySlug();
  const ability = await buildAbility(userId, teamSlug);

  // Only coaches can bulk create
  if (!ability.can('create', 'Practice')) {
    notFound();
  }

  // Fetch seasons and templates
  const [seasons, templates] = await Promise.all([
    prisma.season.findMany({
      where: { teamId, status: 'ACTIVE' },
      select: { id: true, name: true },
      orderBy: { name: 'asc' },
    }),
    prisma.practiceTemplate.findMany({
      where: { teamId },
      select: {
        id: true,
        name: true,
        defaultStartTime: true,
        defaultEndTime: true,
      },
      orderBy: { name: 'asc' },
    }),
  ]);

  return (
    <div className="max-w-2xl mx-auto">
      <div className="mb-6">
        <Link
          href={`/${teamSlug}/practices`}
          className="flex items-center gap-2 text-sm text-zinc-400 hover:text-zinc-200 transition-colors"
        >
          <ArrowLeft className="h-4 w-4" />
          Back to Practices
        </Link>
      </div>

      <div className="bg-zinc-900 rounded-xl border border-zinc-800 p-6">
        <h1 className="text-2xl font-bold text-white mb-6">
          Create Multiple Practices
        </h1>
        <BulkPracticeCreator
          teamSlug={teamSlug}
          seasons={seasons}
          templates={templates}
        />
      </div>
    </div>
  );
}
```

Update practice list page to add bulk create link and multi-select delete. Enhance the existing page to include:

1. "Create Multiple" button linking to bulk-create page
2. Checkbox selection on practice cards
3. Bulk delete button when items selected

```typescript
// Add to src/app/(dashboard)/[teamSlug]/practices/page.tsx
// (This is a partial update - enhance existing page)

// In the header actions area, add:
<Link
  href={`/${teamSlug}/practices/bulk-create`}
  className="px-4 py-2 bg-zinc-800 hover:bg-zinc-700 border border-zinc-700 rounded-lg text-sm font-medium text-zinc-300 transition-colors"
>
  Create Multiple
</Link>

// Add client component for practice list with multi-select:
// src/components/practices/practice-list-client.tsx
'use client';

import { useState } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import { Trash2, CheckSquare, Square } from 'lucide-react';
import { toast } from 'sonner';
import { cn } from '@/lib/utils';
import { PracticeCard } from '@/components/calendar/practice-card';

interface Practice {
  id: string;
  name: string;
  date: string;
  startTime: string;
  endTime: string;
  status: 'DRAFT' | 'PUBLISHED';
}

interface PracticeListClientProps {
  practices: Practice[];
  teamSlug: string;
  isCoach: boolean;
}

export function PracticeListClient({
  practices,
  teamSlug,
  isCoach,
}: PracticeListClientProps) {
  const router = useRouter();
  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());
  const [isDeleting, setIsDeleting] = useState(false);
  const [selectionMode, setSelectionMode] = useState(false);

  const toggleSelection = (id: string) => {
    setSelectedIds(prev => {
      const next = new Set(prev);
      if (next.has(id)) {
        next.delete(id);
      } else {
        next.add(id);
      }
      return next;
    });
  };

  const toggleAll = () => {
    if (selectedIds.size === practices.length) {
      setSelectedIds(new Set());
    } else {
      setSelectedIds(new Set(practices.map(p => p.id)));
    }
  };

  const handleBulkDelete = async () => {
    if (selectedIds.size === 0) return;

    if (!confirm(`Delete ${selectedIds.size} practice(s)? This cannot be undone.`)) {
      return;
    }

    setIsDeleting(true);
    try {
      const response = await fetch('/api/practices/bulk', {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ practiceIds: Array.from(selectedIds) }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to delete');
      }

      toast.success(`Deleted ${data.deleted} practice(s)`);
      setSelectedIds(new Set());
      setSelectionMode(false);
      router.refresh();
    } catch (error) {
      toast.error('Failed to delete practices');
    } finally {
      setIsDeleting(false);
    }
  };

  return (
    <div className="space-y-4">
      {/* Selection controls (coaches only) */}
      {isCoach && (
        <div className="flex items-center justify-between">
          <button
            type="button"
            onClick={() => {
              setSelectionMode(!selectionMode);
              setSelectedIds(new Set());
            }}
            className="text-sm text-zinc-400 hover:text-zinc-200 transition-colors"
          >
            {selectionMode ? 'Cancel selection' : 'Select multiple'}
          </button>

          {selectionMode && (
            <div className="flex items-center gap-2">
              <button
                type="button"
                onClick={toggleAll}
                className="text-sm text-zinc-400 hover:text-zinc-200 transition-colors"
              >
                {selectedIds.size === practices.length ? 'Deselect all' : 'Select all'}
              </button>

              {selectedIds.size > 0 && (
                <button
                  type="button"
                  onClick={handleBulkDelete}
                  disabled={isDeleting}
                  className="flex items-center gap-2 px-3 py-1.5 bg-red-600 hover:bg-red-500 disabled:opacity-50 rounded-lg text-sm font-medium text-white transition-colors"
                >
                  <Trash2 className="h-4 w-4" />
                  Delete {selectedIds.size}
                </button>
              )}
            </div>
          )}
        </div>
      )}

      {/* Practice list */}
      <div className="space-y-2">
        {practices.map(practice => (
          <div key={practice.id} className="flex items-center gap-3">
            {selectionMode && (
              <button
                type="button"
                onClick={() => toggleSelection(practice.id)}
                className="p-1"
              >
                {selectedIds.has(practice.id) ? (
                  <CheckSquare className="h-5 w-5 text-emerald-400" />
                ) : (
                  <Square className="h-5 w-5 text-zinc-500" />
                )}
              </button>
            )}

            <Link
              href={`/${teamSlug}/practices/${practice.id}`}
              className={cn(
                'flex-1',
                selectionMode && 'pointer-events-none'
              )}
            >
              <PracticeCard practice={practice} />
            </Link>
          </div>
        ))}
      </div>
    </div>
  );
}
```
  </action>
  <verify>Navigate to bulk create page and create multiple practices, then test multi-select delete</verify>
  <done>Bulk create page and enhanced practice list with multi-select delete created</done>
</task>

</tasks>

<verification>
- [ ] `npx tsc --noEmit` passes
- [ ] Bulk create API creates multiple practices
- [ ] Bulk delete API removes selected practices
- [ ] BulkPracticeCreator shows date range picker
- [ ] Day of week selection works
- [ ] Template selection auto-fills times
- [ ] Practice count preview is accurate
- [ ] Bulk create page accessible from practice list
- [ ] Multi-select mode works on practice list
- [ ] Bulk delete removes selected practices
</verification>

<success_criteria>
- Date range picker with start/end dates per CONTEXT.md
- Day + time picker (Mon, Wed, Fri at 6:00 AM) per CONTEXT.md
- Optional template application per CONTEXT.md
- Bulk delete with checkbox selection per CONTEXT.md
- Max 100 practices per bulk operation
</success_criteria>

<output>
After completion, create `.planning/phases/22-practice-flow-redesign/22-08-SUMMARY.md`
</output>
