---
phase: 22-practice-flow-redesign
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/hooks/use-autosave.ts
  - src/components/shared/inline-text-field.tsx
  - src/components/shared/inline-textarea.tsx
autonomous: true
must_haves:
  truths:
    - "Inline fields save automatically on blur"
    - "Save errors show toast with retry button"
    - "Successful saves are silent (no toast)"
    - "UI updates optimistically before save completes"
  artifacts:
    - path: "src/lib/hooks/use-autosave.ts"
      provides: "Reusable autosave hook with optimistic updates"
      exports: ["useAutosave"]
    - path: "src/components/shared/inline-text-field.tsx"
      provides: "Inline editable text input"
      exports: ["InlineTextField"]
    - path: "src/components/shared/inline-textarea.tsx"
      provides: "Inline editable textarea"
      exports: ["InlineTextarea"]
  key_links:
    - from: "src/components/shared/inline-text-field.tsx"
      to: "src/lib/hooks/use-autosave.ts"
      via: "useAutosave hook"
      pattern: "useAutosave"
    - from: "src/components/shared/inline-text-field.tsx"
      to: "sonner"
      via: "toast.error for failures"
      pattern: "toast\\.error"
---

<objective>
Create reusable inline editing components with autosave functionality for the practice flow redesign. These components enable the "always editable" pattern where fields save on blur with silent success and error-only toasts.

Purpose: PRC-01 requires inline editing without separate form screens. These shared components provide the foundation for inline practice details, block titles, and notes throughout the phase.

Output: useAutosave hook and InlineTextField/InlineTextarea components ready for use in practice pages.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/intel/summary.md

# Phase context
@.planning/phases/22-practice-flow-redesign/22-CONTEXT.md
@.planning/phases/22-practice-flow-redesign/22-RESEARCH.md

# Existing toast helpers
@src/lib/toast-helpers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useAutosave hook with optimistic updates</name>
  <files>src/lib/hooks/use-autosave.ts</files>
  <action>
Create a reusable autosave hook using React 19's useOptimistic for instant UI feedback:

```typescript
'use client';

import { useOptimistic, useTransition } from 'react';
import { toast } from 'sonner';

interface UseAutosaveOptions<T> {
  /** Initial value */
  initialValue: T;
  /** Save function - should throw on error */
  onSave: (value: T) => Promise<void>;
  /** Optional: Custom comparison function */
  isEqual?: (a: T, b: T) => boolean;
}

interface UseAutosaveReturn<T> {
  /** Current value (optimistic during save) */
  value: T;
  /** Whether a save is in progress */
  isPending: boolean;
  /** Trigger save with new value */
  save: (newValue: T) => void;
  /** Reset to a new initial value (e.g., after external update) */
  reset: (newValue: T) => void;
}

/**
 * Hook for autosave with optimistic updates.
 *
 * Features:
 * - Optimistic UI updates (instant feedback)
 * - Automatic rollback on save failure
 * - Error toast with retry button
 * - Silent success (no toast)
 * - Skips save if value unchanged
 *
 * @example
 * const { value, isPending, save } = useAutosave({
 *   initialValue: practice.name,
 *   onSave: async (name) => {
 *     await fetch(`/api/practices/${id}`, {
 *       method: 'PATCH',
 *       body: JSON.stringify({ name })
 *     });
 *   }
 * });
 */
export function useAutosave<T>({
  initialValue,
  onSave,
  isEqual = (a, b) => a === b,
}: UseAutosaveOptions<T>): UseAutosaveReturn<T> {
  const [isPending, startTransition] = useTransition();
  const [optimisticValue, setOptimisticValue] = useOptimistic(initialValue);

  const save = (newValue: T) => {
    // Skip if value unchanged
    if (isEqual(newValue, initialValue)) {
      return;
    }

    // Optimistic update
    setOptimisticValue(newValue);

    startTransition(async () => {
      try {
        await onSave(newValue);
        // Silent success - no toast
      } catch (error) {
        // Rollback to initial value
        setOptimisticValue(initialValue);

        // Show error toast with retry
        const message = error instanceof Error ? error.message : 'Failed to save';
        toast.error('Save failed', {
          description: message,
          action: {
            label: 'Retry',
            onClick: () => save(newValue),
          },
          duration: Infinity, // Don't auto-dismiss errors
        });
      }
    });
  };

  const reset = (newValue: T) => {
    setOptimisticValue(newValue);
  };

  return {
    value: optimisticValue,
    isPending,
    save,
    reset,
  };
}
```

Key implementation notes:
- useOptimistic provides instant UI update before async completes
- useTransition tracks pending state without blocking UI
- Rollback happens automatically on error via setOptimisticValue(initialValue)
- Error toast has Infinity duration so user must dismiss or retry
- No success toast per CONTEXT.md "No success feedback (silent save)"
  </action>
  <verify>Run `npx tsc --noEmit` to verify types</verify>
  <done>useAutosave hook created with optimistic updates, error toasts with retry, and silent success</done>
</task>

<task type="auto">
  <name>Task 2: Create InlineTextField component</name>
  <files>src/components/shared/inline-text-field.tsx</files>
  <action>
Create an inline text input that saves on blur:

```typescript
'use client';

import { useRef, useEffect, useState } from 'react';
import { cn } from '@/lib/utils';

interface InlineTextFieldProps {
  /** Current value */
  value: string;
  /** Called on blur with new value (should handle save) */
  onSave: (value: string) => void;
  /** Placeholder when empty */
  placeholder?: string;
  /** Whether save is in progress */
  isPending?: boolean;
  /** Additional class names */
  className?: string;
  /** Input type */
  type?: 'text' | 'time' | 'date';
  /** Whether field is disabled */
  disabled?: boolean;
  /** Minimum length for validation */
  minLength?: number;
  /** Maximum length for validation */
  maxLength?: number;
  /** ARIA label for accessibility */
  'aria-label'?: string;
}

/**
 * Inline editable text field with autosave on blur.
 *
 * Styling:
 * - Transparent border by default (looks like plain text)
 * - Shows border on hover
 * - Focus state with emerald ring
 * - Reduced opacity when saving
 *
 * @example
 * <InlineTextField
 *   value={practice.name}
 *   onSave={(name) => updatePractice({ name })}
 *   placeholder="Practice name"
 *   aria-label="Practice name"
 * />
 */
export function InlineTextField({
  value,
  onSave,
  placeholder = 'Click to edit',
  isPending = false,
  className,
  type = 'text',
  disabled = false,
  minLength,
  maxLength,
  'aria-label': ariaLabel,
}: InlineTextFieldProps) {
  const inputRef = useRef<HTMLInputElement>(null);
  const [localValue, setLocalValue] = useState(value);
  const [error, setError] = useState<string | null>(null);

  // Sync local value when prop changes (e.g., after external update)
  useEffect(() => {
    setLocalValue(value);
  }, [value]);

  const handleBlur = () => {
    setError(null);

    // Trim whitespace
    const trimmed = localValue.trim();

    // Validate
    if (minLength && trimmed.length < minLength) {
      setError(`Minimum ${minLength} characters`);
      setLocalValue(value); // Reset to original
      return;
    }
    if (maxLength && trimmed.length > maxLength) {
      setError(`Maximum ${maxLength} characters`);
      setLocalValue(value); // Reset to original
      return;
    }

    // Only save if changed
    if (trimmed !== value) {
      onSave(trimmed);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      inputRef.current?.blur();
    }
    if (e.key === 'Escape') {
      setLocalValue(value); // Reset on escape
      inputRef.current?.blur();
    }
  };

  return (
    <div className="relative">
      <input
        ref={inputRef}
        type={type}
        value={localValue}
        onChange={(e) => setLocalValue(e.target.value)}
        onBlur={handleBlur}
        onKeyDown={handleKeyDown}
        placeholder={placeholder}
        disabled={disabled || isPending}
        minLength={minLength}
        maxLength={maxLength}
        aria-label={ariaLabel}
        aria-invalid={!!error}
        className={cn(
          // Base styles - looks like plain text
          'w-full bg-transparent border border-transparent rounded-md px-2 py-1',
          'text-zinc-100 placeholder-zinc-500',
          // Hover shows border
          'hover:border-zinc-700',
          // Focus styles
          'focus:border-emerald-500 focus:outline-none focus:ring-1 focus:ring-emerald-500',
          // Pending state
          isPending && 'opacity-50 cursor-wait',
          // Disabled state
          disabled && 'cursor-not-allowed opacity-40',
          // Error state
          error && 'border-red-500 focus:border-red-500 focus:ring-red-500',
          // Time/date inputs need color-scheme for dark mode
          (type === 'time' || type === 'date') && '[color-scheme:dark]',
          className
        )}
      />
      {error && (
        <p className="absolute -bottom-5 left-0 text-xs text-red-400">
          {error}
        </p>
      )}
    </div>
  );
}
```

Key features:
- Transparent border gives "plain text" appearance until interaction
- Hover reveals editable border
- Enter triggers blur (save), Escape cancels
- Validation with minLength/maxLength before save
- Error shown below field temporarily
- Supports time/date input types for practice scheduling
  </action>
  <verify>Run `npx tsc --noEmit` to verify types</verify>
  <done>InlineTextField component created with blur-to-save, validation, keyboard shortcuts, and accessible markup</done>
</task>

<task type="auto">
  <name>Task 3: Create InlineTextarea component</name>
  <files>src/components/shared/inline-textarea.tsx</files>
  <action>
Create an inline textarea for notes/descriptions:

```typescript
'use client';

import { useRef, useEffect, useState } from 'react';
import { cn } from '@/lib/utils';

interface InlineTextareaProps {
  /** Current value */
  value: string;
  /** Called on blur with new value */
  onSave: (value: string) => void;
  /** Placeholder when empty */
  placeholder?: string;
  /** Whether save is in progress */
  isPending?: boolean;
  /** Additional class names */
  className?: string;
  /** Whether field is disabled */
  disabled?: boolean;
  /** Number of rows */
  rows?: number;
  /** Maximum length */
  maxLength?: number;
  /** ARIA label */
  'aria-label'?: string;
  /** Auto-resize height based on content */
  autoResize?: boolean;
}

/**
 * Inline editable textarea with autosave on blur.
 *
 * @example
 * <InlineTextarea
 *   value={block.notes || ''}
 *   onSave={(notes) => updateBlock({ notes })}
 *   placeholder="Add notes..."
 *   rows={2}
 *   autoResize
 * />
 */
export function InlineTextarea({
  value,
  onSave,
  placeholder = 'Add notes...',
  isPending = false,
  className,
  disabled = false,
  rows = 2,
  maxLength = 1000,
  'aria-label': ariaLabel,
  autoResize = false,
}: InlineTextareaProps) {
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const [localValue, setLocalValue] = useState(value);
  const [error, setError] = useState<string | null>(null);

  // Sync local value when prop changes
  useEffect(() => {
    setLocalValue(value);
  }, [value]);

  // Auto-resize effect
  useEffect(() => {
    if (autoResize && textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      textareaRef.current.style.height = `${textareaRef.current.scrollHeight}px`;
    }
  }, [localValue, autoResize]);

  const handleBlur = () => {
    setError(null);
    const trimmed = localValue.trim();

    // Validate max length
    if (maxLength && trimmed.length > maxLength) {
      setError(`Maximum ${maxLength} characters`);
      setLocalValue(value);
      return;
    }

    // Only save if changed
    if (trimmed !== value) {
      onSave(trimmed);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    // Escape cancels
    if (e.key === 'Escape') {
      setLocalValue(value);
      textareaRef.current?.blur();
    }
    // Cmd/Ctrl+Enter triggers save
    if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
      textareaRef.current?.blur();
    }
  };

  return (
    <div className="relative">
      <textarea
        ref={textareaRef}
        value={localValue}
        onChange={(e) => setLocalValue(e.target.value)}
        onBlur={handleBlur}
        onKeyDown={handleKeyDown}
        placeholder={placeholder}
        disabled={disabled || isPending}
        rows={rows}
        maxLength={maxLength}
        aria-label={ariaLabel}
        aria-invalid={!!error}
        className={cn(
          // Base styles
          'w-full bg-transparent border border-transparent rounded-md px-2 py-1',
          'text-zinc-100 placeholder-zinc-500 resize-none',
          // Hover
          'hover:border-zinc-700',
          // Focus
          'focus:border-emerald-500 focus:outline-none focus:ring-1 focus:ring-emerald-500',
          // States
          isPending && 'opacity-50 cursor-wait',
          disabled && 'cursor-not-allowed opacity-40',
          error && 'border-red-500 focus:border-red-500 focus:ring-red-500',
          className
        )}
      />
      {error && (
        <p className="absolute -bottom-5 left-0 text-xs text-red-400">
          {error}
        </p>
      )}
      {maxLength && (
        <p className={cn(
          'absolute -bottom-5 right-0 text-xs',
          localValue.length > maxLength * 0.9 ? 'text-amber-400' : 'text-zinc-500'
        )}>
          {localValue.length}/{maxLength}
        </p>
      )}
    </div>
  );
}
```

Key features:
- Same transparent-to-editable pattern as InlineTextField
- Cmd/Ctrl+Enter saves (common pattern for textareas)
- Character count shown when approaching limit
- Auto-resize option for dynamic height
- No Enter-to-save (would break multiline input)
  </action>
  <verify>Run `npx tsc --noEmit` to verify types</verify>
  <done>InlineTextarea component created with character count, auto-resize, and keyboard shortcuts</done>
</task>

</tasks>

<verification>
- [ ] `npx tsc --noEmit` passes
- [ ] useAutosave hook handles success silently
- [ ] useAutosave shows error toast with retry on failure
- [ ] InlineTextField saves on blur and Enter
- [ ] InlineTextField cancels on Escape
- [ ] InlineTextarea saves on blur and Cmd/Ctrl+Enter
- [ ] Both components show transparent border until hover
</verification>

<success_criteria>
- useAutosave hook provides optimistic updates with rollback
- InlineTextField component ready for practice name, times, dates
- InlineTextarea component ready for notes fields
- All components follow CONTEXT.md pattern: silent success, error toasts only
- Keyboard shortcuts work (Enter/Escape for text, Cmd+Enter for textarea)
</success_criteria>

<output>
After completion, create `.planning/phases/22-practice-flow-redesign/22-02-SUMMARY.md`
</output>
