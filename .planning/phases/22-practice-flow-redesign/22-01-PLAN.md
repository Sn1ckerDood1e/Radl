---
phase: 22-practice-flow-redesign
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/validations/practice.ts
  - src/lib/validations/workout.ts
  - src/generated/prisma/*
autonomous: true
must_haves:
  truths:
    - "MEETING block type exists in database schema"
    - "Workout model stores PM5-style interval data"
    - "WorkoutTemplate allows coaches to save reusable workouts"
    - "Blocks can have multiple boats (water blocks)"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "BlockType enum with MEETING, Workout model, WorkoutTemplate model"
      contains: "model Workout"
    - path: "src/lib/validations/workout.ts"
      provides: "Workout validation schemas"
      exports: ["workoutSchema", "createWorkoutSchema", "workoutIntervalSchema"]
    - path: "src/lib/validations/practice.ts"
      provides: "Extended block validation with title field"
      contains: "title"
  key_links:
    - from: "prisma/schema.prisma"
      to: "src/lib/validations/workout.ts"
      via: "Workout model shapes validation schema"
      pattern: "model Workout"
---

<objective>
Extend the data foundation for practice flow redesign: add MEETING block type, create Workout and WorkoutTemplate models for PM5-style workout definitions, and enable multiple boats per water block.

Purpose: The practice flow redesign requires new block types and structured workout storage. This plan establishes the schema foundation that all subsequent UI work depends on.

Output: Updated Prisma schema with new models, migration applied, Zod validation schemas for workouts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/intel/summary.md

# Phase context
@.planning/phases/22-practice-flow-redesign/22-CONTEXT.md
@.planning/phases/22-practice-flow-redesign/22-RESEARCH.md

# Existing schema and validations
@prisma/schema.prisma
@src/lib/validations/practice.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Prisma schema with MEETING block type and Workout models</name>
  <files>prisma/schema.prisma</files>
  <action>
Add MEETING to BlockType enum:
```prisma
enum BlockType {
  WATER
  LAND
  ERG
  MEETING
}
```

Add WorkoutType enum for PM5 workout types:
```prisma
enum WorkoutType {
  SINGLE_TIME
  SINGLE_DISTANCE
  INTERVALS
  VARIABLE_INTERVALS
}
```

Add Workout model for storing workout definitions attached to blocks:
```prisma
model Workout {
  id              String        @id @default(uuid())
  blockId         String        @unique  // One workout per block
  type            WorkoutType
  notes           String?
  visibleToAthletes Boolean     @default(true)  // Coach controls visibility
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  block           PracticeBlock @relation(fields: [blockId], references: [id], onDelete: Cascade)
  intervals       WorkoutInterval[]

  @@index([blockId])
}
```

Add WorkoutInterval model for PM5-style intervals:
```prisma
model WorkoutInterval {
  id              String    @id @default(uuid())
  workoutId       String
  position        Int       // Order within workout (0-49, PM5 limit is 50)
  durationType    String    // 'time' or 'distance'
  duration        Int       // Seconds for time, meters for distance
  targetSplit     String?   // "2:05.0" format for erg
  targetStrokeRate Int?     // SPM for water workouts (16-40)
  restDuration    Int       @default(0)  // Rest seconds after interval
  restType        String    @default("time")  // 'time' or 'undefined'

  workout         Workout   @relation(fields: [workoutId], references: [id], onDelete: Cascade)

  @@unique([workoutId, position])
  @@index([workoutId])
}
```

Add WorkoutTemplate model for reusable workout definitions:
```prisma
model WorkoutTemplate {
  id              String        @id @default(uuid())
  teamId          String
  name            String
  type            WorkoutType
  notes           String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  team            Team          @relation(fields: [teamId], references: [id], onDelete: Cascade)
  intervals       WorkoutTemplateInterval[]

  @@index([teamId])
  @@index([teamId, type])
}

model WorkoutTemplateInterval {
  id              String           @id @default(uuid())
  templateId      String
  position        Int
  durationType    String
  duration        Int
  targetSplit     String?
  targetStrokeRate Int?
  restDuration    Int              @default(0)
  restType        String           @default("time")

  template        WorkoutTemplate  @relation(fields: [templateId], references: [id], onDelete: Cascade)

  @@unique([templateId, position])
  @@index([templateId])
}
```

Add relation to Team:
```prisma
// In Team model
workoutTemplates  WorkoutTemplate[]
```

Update PracticeBlock to add title field and workout relation:
```prisma
model PracticeBlock {
  id              String    @id @default(uuid())
  practiceId      String
  position        Int
  type            BlockType
  title           String?   // NEW: Block title (e.g., "Warm-up Row", "5k Erg Test")
  durationMinutes Int?
  category        String?
  notes           String?

  practice        Practice         @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  lineup          Lineup?
  landAssignments LandAssignment[]
  workout         Workout?         // NEW: Optional workout for ERG/WATER blocks

  @@index([practiceId, position])
}
```

Update Lineup to support multiple boats per water block (make blockId non-unique, add boatName for reference):
```prisma
model Lineup {
  id        String   @id @default(uuid())
  blockId   String   // Remove @unique to allow multiple lineups per block
  boatId    String?
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  block     PracticeBlock        @relation(fields: [blockId], references: [id], onDelete: Cascade)
  boat      Equipment?           @relation(fields: [boatId], references: [id])
  seats     SeatAssignment[]
  usageLogs EquipmentUsageLog[]

  @@index([blockId])
}
```
  </action>
  <verify>Run `npx prisma validate` to confirm schema is valid</verify>
  <done>Schema includes MEETING block type, Workout/WorkoutInterval models, WorkoutTemplate models, title field on blocks, and Lineup allows multiple boats per block</done>
</task>

<task type="auto">
  <name>Task 2: Generate Prisma client and apply migration</name>
  <files>src/generated/prisma/*</files>
  <action>
Run Prisma migration to apply schema changes:
```bash
npx prisma migrate dev --name add_workout_models_meeting_type
```

This will:
1. Add MEETING to BlockType enum
2. Add WorkoutType enum
3. Create Workout, WorkoutInterval tables
4. Create WorkoutTemplate, WorkoutTemplateInterval tables
5. Add title column to PracticeBlock
6. Allow multiple Lineups per block (remove unique constraint)
7. Regenerate Prisma client

If migration fails due to unique constraint removal on Lineup.blockId, use a two-step migration:
1. First migration: Add new models and columns
2. Second migration: Drop unique constraint on Lineup.blockId (data-safe since existing blocks have at most one lineup)
  </action>
  <verify>Run `npx prisma studio` and confirm new tables (Workout, WorkoutInterval, WorkoutTemplate, WorkoutTemplateInterval) appear</verify>
  <done>Migration applied successfully, Prisma client regenerated with new types</done>
</task>

<task type="auto">
  <name>Task 3: Create workout validation schemas</name>
  <files>src/lib/validations/workout.ts</files>
  <action>
Create new workout validation file with Zod schemas matching PM5 constraints:

```typescript
import { z } from 'zod';

// Enums matching Prisma schema
export const workoutTypeSchema = z.enum([
  'SINGLE_TIME',
  'SINGLE_DISTANCE',
  'INTERVALS',
  'VARIABLE_INTERVALS'
]);

// Single interval schema with PM5 constraints
export const workoutIntervalSchema = z.object({
  durationType: z.enum(['time', 'distance']),
  duration: z.number().int().positive(),
  targetSplit: z.string().regex(/^\d:\d{2}\.\d$/).optional(), // "2:05.0" format
  targetStrokeRate: z.number().int().min(16).max(40).optional(),
  restDuration: z.number().int().min(0).default(0),
  restType: z.enum(['time', 'undefined']).default('time'),
});

// Create workout schema (max 50 intervals per PM5 limit)
export const createWorkoutSchema = z.object({
  type: workoutTypeSchema,
  notes: z.string().max(500).optional(),
  visibleToAthletes: z.boolean().default(true),
  intervals: z.array(workoutIntervalSchema)
    .min(1, 'At least one interval required')
    .max(50, 'Maximum 50 intervals (PM5 limit)'),
}).refine(data => {
  // Auto-detect variable intervals: different durations require VARIABLE_INTERVALS type
  if (data.intervals.length > 1 && data.type !== 'VARIABLE_INTERVALS') {
    const firstDuration = data.intervals[0].duration;
    const hasVariableDurations = data.intervals.some(i => i.duration !== firstDuration);
    if (hasVariableDurations) return false;
  }
  return true;
}, {
  message: 'Intervals with different durations require VARIABLE_INTERVALS type',
  path: ['type']
});

// Update workout schema (partial)
export const updateWorkoutSchema = createWorkoutSchema.partial();

// Workout template schemas
export const createWorkoutTemplateSchema = z.object({
  name: z.string().min(1, 'Name required').max(100),
  type: workoutTypeSchema,
  notes: z.string().max(500).optional(),
  intervals: z.array(workoutIntervalSchema)
    .min(1)
    .max(50),
});

export const updateWorkoutTemplateSchema = createWorkoutTemplateSchema.partial();

// Type exports
export type WorkoutType = z.infer<typeof workoutTypeSchema>;
export type WorkoutInterval = z.infer<typeof workoutIntervalSchema>;
export type CreateWorkoutInput = z.infer<typeof createWorkoutSchema>;
export type UpdateWorkoutInput = z.infer<typeof updateWorkoutSchema>;
export type CreateWorkoutTemplateInput = z.infer<typeof createWorkoutTemplateSchema>;
export type UpdateWorkoutTemplateInput = z.infer<typeof updateWorkoutTemplateSchema>;
```
  </action>
  <verify>Run `npx tsc --noEmit` to confirm types compile without errors</verify>
  <done>Workout validation schemas created with PM5 constraints (50 interval max, split format, stroke rate range)</done>
</task>

</tasks>

<verification>
- [ ] `npx prisma validate` passes
- [ ] Migration applied without errors
- [ ] `npx prisma studio` shows new tables
- [ ] `npx tsc --noEmit` passes
- [ ] BlockType enum includes MEETING
- [ ] Workout model has relation to PracticeBlock
- [ ] WorkoutInterval has position unique constraint per workout
</verification>

<success_criteria>
- MEETING block type available in database
- Workout and WorkoutInterval models store PM5-style data
- WorkoutTemplate allows saving reusable workouts
- PracticeBlock has title field
- Lineup allows multiple boats per block (blockId no longer unique)
- All validations enforce PM5 constraints
</success_criteria>

<output>
After completion, create `.planning/phases/22-practice-flow-redesign/22-01-SUMMARY.md`
</output>
