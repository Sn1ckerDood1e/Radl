---
phase: 22-practice-flow-redesign
plan: 07
type: execute
wave: 4
depends_on: ["22-02", "22-03", "22-04", "22-05", "22-06"]
files_modified:
  - src/app/(dashboard)/[teamSlug]/practices/[id]/page.tsx
  - src/app/(dashboard)/[teamSlug]/practices/[id]/inline-practice-page.tsx
  - src/components/practices/water-block-content.tsx
  - src/components/practices/erg-block-content.tsx
autonomous: true
must_haves:
  truths:
    - "Practice details are always editable inline (no edit mode)"
    - "Block content expands to show lineup builder or workout builder"
    - "Save on blur with silent success, error toasts"
    - "Water blocks show multi-boat lineup builder"
    - "Erg blocks show workout builder"
  artifacts:
    - path: "src/app/(dashboard)/[teamSlug]/practices/[id]/inline-practice-page.tsx"
      provides: "Inline practice editing page"
      exports: ["InlinePracticePage"]
    - path: "src/components/practices/water-block-content.tsx"
      provides: "Water block expanded content"
      exports: ["WaterBlockContent"]
    - path: "src/components/practices/erg-block-content.tsx"
      provides: "Erg block expanded content"
      exports: ["ErgBlockContent"]
  key_links:
    - from: "src/app/(dashboard)/[teamSlug]/practices/[id]/inline-practice-page.tsx"
      to: "src/components/practices/sortable-block-list.tsx"
      via: "SortableBlockList"
      pattern: "SortableBlockList"
    - from: "src/components/practices/water-block-content.tsx"
      to: "src/components/lineups/multi-boat-lineup-builder.tsx"
      via: "MultiBoatLineupBuilder"
      pattern: "MultiBoatLineupBuilder"
    - from: "src/components/practices/erg-block-content.tsx"
      to: "src/components/practices/workout-builder.tsx"
      via: "WorkoutBuilder"
      pattern: "WorkoutBuilder"
---

<objective>
Integrate all components into the practice detail page: inline practice header editing, sortable block list with expanded content for water (lineup builder) and erg (workout builder) blocks.

Purpose: This plan wires together all the components from previous plans into the final inline practice editing experience per PRC-01 requirements.

Output: Complete inline practice editing page with all block types and their content editors.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/intel/summary.md

# Phase context
@.planning/phases/22-practice-flow-redesign/22-CONTEXT.md
@.planning/phases/22-practice-flow-redesign/22-RESEARCH.md

# Existing practice page
@src/app/(dashboard)/[teamSlug]/practices/[id]/page.tsx
@src/app/(dashboard)/[teamSlug]/practices/[id]/practice-detail-client.tsx

# Components from this phase
@src/components/shared/inline-text-field.tsx
@src/components/shared/inline-textarea.tsx
@src/lib/hooks/use-autosave.ts
@src/components/practices/sortable-block-list.tsx
@src/components/practices/workout-builder.tsx
@src/components/lineups/multi-boat-lineup-builder.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WaterBlockContent and ErgBlockContent components</name>
  <files>src/components/practices/water-block-content.tsx, src/components/practices/erg-block-content.tsx</files>
  <action>
Create WaterBlockContent component that wraps MultiBoatLineupBuilder:

```typescript
// src/components/practices/water-block-content.tsx
'use client';

import { MultiBoatLineupBuilder } from '@/components/lineups/multi-boat-lineup-builder';
import type { BoatClass } from '@/generated/prisma';

interface Athlete {
  id: string;
  displayName: string | null;
  sidePreference?: 'PORT' | 'STARBOARD' | 'BOTH' | null;
}

interface Boat {
  id: string;
  name: string;
  boatClass: BoatClass | null;
  available: boolean;
}

interface Lineup {
  id: string;
  boatId: string | null;
  seats: Array<{
    position: number;
    label: string;
    side: 'PORT' | 'STARBOARD' | 'NONE';
    athleteId: string | null;
  }>;
}

interface WaterBlockContentProps {
  /** Block ID */
  blockId: string;
  /** Practice ID for API calls */
  practiceId: string;
  /** All team athletes */
  athletes: Athlete[];
  /** Available boats */
  boats: Boat[];
  /** Existing lineups for this block */
  lineups: Lineup[];
  /** Refresh handler after save */
  onRefresh: () => void;
}

/**
 * Water block expanded content - multi-boat lineup builder.
 */
export function WaterBlockContent({
  blockId,
  practiceId,
  athletes,
  boats,
  lineups,
  onRefresh,
}: WaterBlockContentProps) {
  const handleSave = async (updatedLineups: Lineup[]) => {
    // Save each lineup via API
    // For simplicity, we'll use a single bulk endpoint
    const response = await fetch(
      `/api/practices/${practiceId}/blocks/${blockId}/lineups`,
      {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ lineups: updatedLineups }),
      }
    );

    if (!response.ok) {
      const data = await response.json();
      throw new Error(data.error || 'Failed to save lineups');
    }

    onRefresh();
  };

  return (
    <MultiBoatLineupBuilder
      blockId={blockId}
      athletes={athletes}
      boats={boats}
      initialLineups={lineups}
      onSave={handleSave}
    />
  );
}
```

Create ErgBlockContent component that wraps WorkoutBuilder:

```typescript
// src/components/practices/erg-block-content.tsx
'use client';

import { WorkoutBuilder } from '@/components/practices/workout-builder';
import type { CreateWorkoutInput, WorkoutType } from '@/lib/validations/workout';

interface Workout {
  id: string;
  type: WorkoutType;
  notes: string | null;
  visibleToAthletes: boolean;
  intervals: Array<{
    id: string;
    position: number;
    durationType: string;
    duration: number;
    targetSplit: string | null;
    targetStrokeRate: number | null;
    restDuration: number;
    restType: string;
  }>;
}

interface ErgBlockContentProps {
  /** Block ID */
  blockId: string;
  /** Practice ID for API calls */
  practiceId: string;
  /** Block type (ERG or WATER for workout context) */
  blockType: 'ERG' | 'WATER';
  /** Existing workout (null if none) */
  workout: Workout | null;
  /** Refresh handler after save */
  onRefresh: () => void;
}

/**
 * Erg block expanded content - workout builder.
 * Also used for water blocks with workout definitions.
 */
export function ErgBlockContent({
  blockId,
  practiceId,
  blockType,
  workout,
  onRefresh,
}: ErgBlockContentProps) {
  const handleSave = async (data: CreateWorkoutInput) => {
    const response = await fetch(
      `/api/practices/${practiceId}/blocks/${blockId}/workout`,
      {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      }
    );

    if (!response.ok) {
      const result = await response.json();
      throw new Error(result.error || 'Failed to save workout');
    }

    onRefresh();
  };

  const handleDelete = async () => {
    const response = await fetch(
      `/api/practices/${practiceId}/blocks/${blockId}/workout`,
      { method: 'DELETE' }
    );

    if (!response.ok) {
      throw new Error('Failed to delete workout');
    }

    onRefresh();
  };

  const handleSaveAsTemplate = async (data: CreateWorkoutInput, name: string) => {
    const response = await fetch('/api/workout-templates', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ...data, name }),
    });

    if (!response.ok) {
      const result = await response.json();
      throw new Error(result.error || 'Failed to save template');
    }
  };

  return (
    <WorkoutBuilder
      workout={workout}
      blockType={blockType}
      onSave={handleSave}
      onDelete={workout ? handleDelete : undefined}
      onSaveAsTemplate={handleSaveAsTemplate}
    />
  );
}
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify types</verify>
  <done>WaterBlockContent and ErgBlockContent wrapper components created</done>
</task>

<task type="auto">
  <name>Task 2: Create InlinePracticePage component</name>
  <files>src/app/(dashboard)/[teamSlug]/practices/[id]/inline-practice-page.tsx</files>
  <action>
Create the main inline practice editing page:

```typescript
'use client';

import { useState, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import { ArrowLeft, Trash2, Eye, EyeOff } from 'lucide-react';
import { toast } from 'sonner';
import { cn } from '@/lib/utils';
import { InlineTextField } from '@/components/shared/inline-text-field';
import { InlineTextarea } from '@/components/shared/inline-textarea';
import { useAutosave } from '@/lib/hooks/use-autosave';
import { SortableBlockList } from '@/components/practices/sortable-block-list';
import { WaterBlockContent } from '@/components/practices/water-block-content';
import { ErgBlockContent } from '@/components/practices/erg-block-content';
import type { BlockType, PracticeStatus } from '@/lib/validations/practice';
import type { BoatClass, SeatSide, WorkoutType } from '@/generated/prisma';

interface Athlete {
  id: string;
  displayName: string | null;
  sidePreference?: 'PORT' | 'STARBOARD' | 'BOTH' | null;
}

interface Boat {
  id: string;
  name: string;
  boatClass: BoatClass | null;
  available: boolean;
}

interface Lineup {
  id: string;
  boatId: string | null;
  seats: Array<{
    position: number;
    label: string;
    side: 'PORT' | 'STARBOARD' | 'NONE';
    athleteId: string | null;
  }>;
}

interface Workout {
  id: string;
  type: WorkoutType;
  notes: string | null;
  visibleToAthletes: boolean;
  intervals: Array<{
    id: string;
    position: number;
    durationType: string;
    duration: number;
    targetSplit: string | null;
    targetStrokeRate: number | null;
    restDuration: number;
    restType: string;
  }>;
}

interface Block {
  id: string;
  type: BlockType;
  title: string | null;
  notes: string | null;
  durationMinutes: number | null;
  category: string | null;
  lineups?: Lineup[];
  workout?: Workout | null;
}

interface Practice {
  id: string;
  name: string;
  date: string;
  startTime: string;
  endTime: string;
  notes: string | null;
  status: PracticeStatus;
  blocks: Block[];
  season: { id: string; name: string } | null;
}

interface InlinePracticePageProps {
  practice: Practice;
  teamSlug: string;
  isCoach: boolean;
  athletes: Athlete[];
  boats: Boat[];
}

function formatDate(dateStr: string): string {
  return new Date(dateStr).toLocaleDateString('en-US', {
    weekday: 'short',
    month: 'short',
    day: 'numeric',
  });
}

function formatDateForInput(dateStr: string): string {
  return new Date(dateStr).toISOString().split('T')[0];
}

function formatTimeForInput(dateStr: string): string {
  return new Date(dateStr).toTimeString().slice(0, 5);
}

/**
 * Inline practice editing page.
 *
 * Features:
 * - Always editable header (name, date, times, notes)
 * - Sortable block list with expand/collapse
 * - Block content editors (lineup, workout)
 * - Publish/unpublish toggle
 * - Delete with confirmation
 */
export function InlinePracticePage({
  practice,
  teamSlug,
  isCoach,
  athletes,
  boats,
}: InlinePracticePageProps) {
  const router = useRouter();
  const [blocks, setBlocks] = useState(practice.blocks);
  const [isPublishing, setIsPublishing] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);

  // Refresh page data
  const refresh = useCallback(() => {
    router.refresh();
  }, [router]);

  // Save practice field
  const savePracticeField = async (field: string, value: string | null) => {
    const response = await fetch(`/api/practices/${practice.id}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ [field]: value }),
    });

    if (!response.ok) {
      const data = await response.json();
      throw new Error(data.error || 'Failed to save');
    }
  };

  // Save block field
  const saveBlockField = async (blockId: string, updates: Partial<Block>) => {
    const response = await fetch(
      `/api/practices/${practice.id}/blocks/${blockId}`,
      {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates),
      }
    );

    if (!response.ok) {
      const data = await response.json();
      throw new Error(data.error || 'Failed to save');
    }
  };

  // Delete block
  const handleDeleteBlock = async (blockId: string) => {
    const response = await fetch(
      `/api/practices/${practice.id}/blocks/${blockId}`,
      { method: 'DELETE' }
    );

    if (!response.ok) {
      toast.error('Failed to delete block');
      return;
    }

    setBlocks(prev => prev.filter(b => b.id !== blockId));
    toast.success('Block deleted');
  };

  // Add block
  const handleAddBlock = async (type: BlockType) => {
    const response = await fetch(`/api/practices/${practice.id}/blocks`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ type }),
    });

    if (!response.ok) {
      toast.error('Failed to add block');
      return;
    }

    const data = await response.json();
    setBlocks(prev => [...prev, data.block]);
  };

  // Reorder blocks
  const handleReorderBlocks = async (blockIds: string[]) => {
    // Optimistic update
    setBlocks(prev => {
      const ordered: Block[] = [];
      for (const id of blockIds) {
        const block = prev.find(b => b.id === id);
        if (block) ordered.push(block);
      }
      return ordered;
    });

    const response = await fetch(
      `/api/practices/${practice.id}/blocks/reorder`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          positions: blockIds.map((id, index) => ({ blockId: id, position: index })),
        }),
      }
    );

    if (!response.ok) {
      toast.error('Failed to reorder blocks');
      refresh();
    }
  };

  // Toggle publish
  const handleTogglePublish = async () => {
    setIsPublishing(true);
    try {
      const newStatus = practice.status === 'PUBLISHED' ? 'DRAFT' : 'PUBLISHED';
      await savePracticeField('status', newStatus);
      refresh();
      toast.success(newStatus === 'PUBLISHED' ? 'Practice published' : 'Practice unpublished');
    } catch (error) {
      toast.error('Failed to update status');
    } finally {
      setIsPublishing(false);
    }
  };

  // Delete practice
  const handleDelete = async () => {
    setIsDeleting(true);
    try {
      const response = await fetch(`/api/practices/${practice.id}`, {
        method: 'DELETE',
      });

      if (!response.ok) throw new Error('Failed to delete');

      router.push(`/${teamSlug}/practices`);
      router.refresh();
    } catch (error) {
      toast.error('Failed to delete practice');
      setIsDeleting(false);
    }
  };

  // Render block content based on type
  const renderBlockContent = (block: Block) => {
    if (block.type === 'WATER') {
      return (
        <WaterBlockContent
          blockId={block.id}
          practiceId={practice.id}
          athletes={athletes}
          boats={boats}
          lineups={block.lineups || []}
          onRefresh={refresh}
        />
      );
    }

    if (block.type === 'ERG') {
      return (
        <ErgBlockContent
          blockId={block.id}
          practiceId={practice.id}
          blockType="ERG"
          workout={block.workout || null}
          onRefresh={refresh}
        />
      );
    }

    // LAND and MEETING blocks: simple notes-only for now
    return null;
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <Link
          href={`/${teamSlug}/practices`}
          className="flex items-center gap-2 text-sm text-zinc-400 hover:text-zinc-200 transition-colors"
        >
          <ArrowLeft className="h-4 w-4" />
          Back to Practices
        </Link>

        {isCoach && (
          <div className="flex items-center gap-2">
            {/* Publish toggle */}
            <button
              type="button"
              onClick={handleTogglePublish}
              disabled={isPublishing}
              className={cn(
                'flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors',
                practice.status === 'PUBLISHED'
                  ? 'bg-emerald-500/20 text-emerald-400 border border-emerald-500/30'
                  : 'bg-zinc-800 text-zinc-400 border border-zinc-700 hover:bg-zinc-700'
              )}
            >
              {practice.status === 'PUBLISHED' ? (
                <>
                  <Eye className="h-4 w-4" />
                  Published
                </>
              ) : (
                <>
                  <EyeOff className="h-4 w-4" />
                  Draft
                </>
              )}
            </button>

            {/* Delete */}
            <button
              type="button"
              onClick={() => setShowDeleteConfirm(true)}
              className="p-2 text-zinc-400 hover:text-red-400 transition-colors"
            >
              <Trash2 className="h-4 w-4" />
            </button>
          </div>
        )}
      </div>

      {/* Delete confirmation */}
      {showDeleteConfirm && (
        <div className="p-4 bg-red-500/10 border border-red-500/30 rounded-lg">
          <p className="text-sm text-red-400 mb-3">
            Delete this practice? This cannot be undone.
          </p>
          <div className="flex gap-2">
            <button
              onClick={handleDelete}
              disabled={isDeleting}
              className="px-3 py-1.5 rounded text-sm font-medium text-white bg-red-600 hover:bg-red-500 disabled:opacity-50"
            >
              {isDeleting ? 'Deleting...' : 'Delete'}
            </button>
            <button
              onClick={() => setShowDeleteConfirm(false)}
              className="px-3 py-1.5 rounded text-sm font-medium text-zinc-300 bg-zinc-800 hover:bg-zinc-700"
            >
              Cancel
            </button>
          </div>
        </div>
      )}

      {/* Practice header - always editable */}
      <div className="bg-zinc-900 rounded-xl border border-zinc-800 p-6 space-y-4">
        {/* Name */}
        <div>
          {isCoach ? (
            <InlineTextField
              value={practice.name}
              onSave={(name) => savePracticeField('name', name)}
              placeholder="Practice name..."
              className="text-2xl font-bold"
              minLength={1}
              maxLength={100}
              aria-label="Practice name"
            />
          ) : (
            <h1 className="text-2xl font-bold text-white">{practice.name}</h1>
          )}
          {practice.season && (
            <p className="text-sm text-zinc-500 mt-1">{practice.season.name}</p>
          )}
        </div>

        {/* Date and times */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <div>
            <label className="block text-xs text-zinc-500 mb-1">Date</label>
            {isCoach ? (
              <InlineTextField
                value={formatDateForInput(practice.date)}
                onSave={(date) => savePracticeField('date', new Date(date).toISOString())}
                type="date"
                aria-label="Practice date"
              />
            ) : (
              <p className="text-zinc-200">{formatDate(practice.date)}</p>
            )}
          </div>
          <div>
            <label className="block text-xs text-zinc-500 mb-1">Start Time</label>
            {isCoach ? (
              <InlineTextField
                value={formatTimeForInput(practice.startTime)}
                onSave={(time) => {
                  const date = new Date(practice.date);
                  const [h, m] = time.split(':');
                  date.setHours(parseInt(h), parseInt(m));
                  return savePracticeField('startTime', date.toISOString());
                }}
                type="time"
                aria-label="Start time"
              />
            ) : (
              <p className="text-zinc-200">{formatTimeForInput(practice.startTime)}</p>
            )}
          </div>
          <div>
            <label className="block text-xs text-zinc-500 mb-1">End Time</label>
            {isCoach ? (
              <InlineTextField
                value={formatTimeForInput(practice.endTime)}
                onSave={(time) => {
                  const date = new Date(practice.date);
                  const [h, m] = time.split(':');
                  date.setHours(parseInt(h), parseInt(m));
                  return savePracticeField('endTime', date.toISOString());
                }}
                type="time"
                aria-label="End time"
              />
            ) : (
              <p className="text-zinc-200">{formatTimeForInput(practice.endTime)}</p>
            )}
          </div>
        </div>

        {/* Notes */}
        <div>
          <label className="block text-xs text-zinc-500 mb-1">Notes</label>
          {isCoach ? (
            <InlineTextarea
              value={practice.notes || ''}
              onSave={(notes) => savePracticeField('notes', notes || null)}
              placeholder="Add practice notes..."
              rows={2}
              autoResize
              aria-label="Practice notes"
            />
          ) : practice.notes ? (
            <p className="text-zinc-300 whitespace-pre-wrap">{practice.notes}</p>
          ) : (
            <p className="text-zinc-500 italic">No notes</p>
          )}
        </div>
      </div>

      {/* Blocks */}
      <div className="bg-zinc-900 rounded-xl border border-zinc-800 p-6">
        <h2 className="text-lg font-medium text-zinc-200 mb-4">Practice Blocks</h2>
        <SortableBlockList
          blocks={blocks}
          onReorder={handleReorderBlocks}
          onSaveBlock={saveBlockField}
          onDeleteBlock={handleDeleteBlock}
          onAddBlock={handleAddBlock}
          isCoach={isCoach}
          renderBlockContent={renderBlockContent}
        />
      </div>
    </div>
  );
}
```
  </action>
  <verify>Run `npx tsc --noEmit` to verify types</verify>
  <done>InlinePracticePage component created with full inline editing capability</done>
</task>

<task type="auto">
  <name>Task 3: Update practice detail page to use InlinePracticePage</name>
  <files>src/app/(dashboard)/[teamSlug]/practices/[id]/page.tsx</files>
  <action>
Update the practice detail page to use the new inline editing component and fetch expanded data:

```typescript
import { notFound } from 'next/navigation';
import { prisma } from '@/lib/prisma';
import { requireTeamBySlug } from '@/lib/auth/require-team-by-slug';
import { buildAbility } from '@/lib/permissions/ability';
import { InlinePracticePage } from './inline-practice-page';
import { getSeatsForBoatClass } from '@/lib/lineup/position-labels';

interface PageProps {
  params: Promise<{ teamSlug: string; id: string }>;
}

export default async function PracticeDetailPage({ params }: PageProps) {
  const { teamSlug, id } = await params;
  const { teamId, userId } = await requireTeamBySlug();
  const ability = await buildAbility(userId, teamSlug);
  const isCoach = ability.can('update', 'Practice');

  // Fetch practice with blocks, lineups, workouts
  const practice = await prisma.practice.findFirst({
    where: { id, teamId },
    include: {
      season: { select: { id: true, name: true } },
      blocks: {
        orderBy: { position: 'asc' },
        include: {
          // For WATER blocks: fetch all lineups (multiple boats)
          lineup: {
            include: {
              boat: true,
              seats: {
                orderBy: { position: 'asc' },
                include: {
                  athlete: {
                    select: { id: true, displayName: true, sidePreference: true },
                  },
                },
              },
            },
          },
          // For ERG blocks: fetch workout
          workout: {
            include: {
              intervals: { orderBy: { position: 'asc' } },
            },
          },
          // For LAND/ERG blocks: fetch assignments
          landAssignments: {
            include: {
              athlete: {
                select: { id: true, displayName: true },
              },
            },
          },
        },
      },
    },
  });

  if (!practice) {
    notFound();
  }

  // Fetch athletes and boats for lineup building
  const [athletes, boats] = await Promise.all([
    prisma.athleteProfile.findMany({
      where: {
        teamMember: { teamId },
      },
      select: {
        id: true,
        displayName: true,
        sidePreference: true,
      },
      orderBy: { displayName: 'asc' },
    }),
    prisma.equipment.findMany({
      where: {
        teamId,
        type: 'SHELL',
        status: 'ACTIVE',
      },
      select: {
        id: true,
        name: true,
        boatClass: true,
        manualUnavailable: true,
      },
      orderBy: { name: 'asc' },
    }),
  ]);

  // Transform practice for client component
  const transformedPractice = {
    id: practice.id,
    name: practice.name,
    date: practice.date.toISOString(),
    startTime: practice.startTime.toISOString(),
    endTime: practice.endTime.toISOString(),
    notes: practice.notes,
    status: practice.status as 'DRAFT' | 'PUBLISHED',
    season: practice.season,
    blocks: practice.blocks.map(block => {
      // Transform lineups for water blocks
      // Note: Current schema has single lineup per block, but we're preparing for multi
      // Once schema migration is complete, this will be an array
      const lineups = block.lineup ? [{
        id: block.lineup.id,
        boatId: block.lineup.boatId,
        seats: block.lineup.seats.map(seat => ({
          position: seat.position,
          label: `Seat ${seat.position}`, // Will be enhanced with proper labels
          side: seat.side as 'PORT' | 'STARBOARD' | 'NONE',
          athleteId: seat.athleteId,
        })),
      }] : [];

      return {
        id: block.id,
        type: block.type as 'WATER' | 'ERG' | 'LAND' | 'MEETING',
        title: block.title,
        notes: block.notes,
        durationMinutes: block.durationMinutes,
        category: block.category,
        lineups,
        workout: block.workout ? {
          id: block.workout.id,
          type: block.workout.type as any,
          notes: block.workout.notes,
          visibleToAthletes: block.workout.visibleToAthletes,
          intervals: block.workout.intervals.map(interval => ({
            id: interval.id,
            position: interval.position,
            durationType: interval.durationType,
            duration: interval.duration,
            targetSplit: interval.targetSplit,
            targetStrokeRate: interval.targetStrokeRate,
            restDuration: interval.restDuration,
            restType: interval.restType,
          })),
        } : null,
      };
    }),
  };

  // Transform boats
  const transformedBoats = boats.map(boat => ({
    id: boat.id,
    name: boat.name,
    boatClass: boat.boatClass,
    available: !boat.manualUnavailable,
  }));

  return (
    <InlinePracticePage
      practice={transformedPractice}
      teamSlug={teamSlug}
      isCoach={isCoach}
      athletes={athletes}
      boats={transformedBoats}
    />
  );
}
```

This replaces the previous practice-detail-client.tsx usage with the new InlinePracticePage.
  </action>
  <verify>Start dev server and navigate to a practice detail page, verify inline editing works</verify>
  <done>Practice detail page updated to use InlinePracticePage with inline editing</done>
</task>

</tasks>

<verification>
- [ ] `npx tsc --noEmit` passes
- [ ] Practice name is inline editable
- [ ] Date, start time, end time are inline editable
- [ ] Notes are inline editable
- [ ] Blocks show in sortable list
- [ ] Water blocks expand to show lineup builder
- [ ] Erg blocks expand to show workout builder
- [ ] Publish/unpublish toggle works
- [ ] Delete with confirmation works
- [ ] Non-coach view shows read-only content
</verification>

<success_criteria>
- Practice details always editable inline (no edit mode) per PRC-01
- Block content expands to show appropriate editor
- Water blocks show multi-boat lineup builder per PRC-05
- Erg blocks show workout builder per PRC-07
- Save on blur with silent success, error toasts per CONTEXT.md
</success_criteria>

<output>
After completion, create `.planning/phases/22-practice-flow-redesign/22-07-SUMMARY.md`
</output>
