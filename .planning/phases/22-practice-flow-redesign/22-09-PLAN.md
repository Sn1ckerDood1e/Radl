---
phase: 22-practice-flow-redesign
plan: 09
type: execute
wave: 5
depends_on: ["22-07", "22-08"]
files_modified:
  - src/app/api/practices/[id]/blocks/[blockId]/lineups/route.ts
  - src/lib/validations/practice.ts
autonomous: false
must_haves:
  truths:
    - "All PRC requirements verified working"
    - "Inline editing saves on blur throughout"
    - "Lineup builder supports multiple boats"
    - "Workout builder follows PM5 pattern"
    - "Bulk operations work for create and delete"
  artifacts:
    - path: "src/app/api/practices/[id]/blocks/[blockId]/lineups/route.ts"
      provides: "Multi-lineup bulk save endpoint"
      exports: ["PUT"]
  key_links:
    - from: "src/components/lineups/multi-boat-lineup-builder.tsx"
      to: "/api/practices/[id]/blocks/[blockId]/lineups"
      via: "PUT for bulk lineup save"
      pattern: "lineups"
---

<objective>
Final integration and verification: create the multi-lineup bulk save endpoint, verify all components work together, and confirm all PRC requirements are met.

Purpose: This plan completes the phase by wiring up the remaining API endpoint and performing a visual verification of the complete practice flow redesign.

Output: Complete working practice flow with all features from CONTEXT.md implemented.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/intel/summary.md

# Phase context
@.planning/phases/22-practice-flow-redesign/22-CONTEXT.md
@.planning/phases/22-practice-flow-redesign/22-RESEARCH.md

# Requirements
@.planning/REQUIREMENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multi-lineup bulk save endpoint</name>
  <files>src/app/api/practices/[id]/blocks/[blockId]/lineups/route.ts</files>
  <action>
Create the bulk lineup save endpoint for multi-boat water blocks:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireTeamBySlug } from '@/lib/auth/require-team-by-slug';
import { buildAbility } from '@/lib/permissions/ability';
import { z } from 'zod';

const seatSchema = z.object({
  position: z.number().int().min(1),
  side: z.enum(['PORT', 'STARBOARD', 'NONE']),
  athleteId: z.string().uuid().nullable(),
});

const lineupSchema = z.object({
  id: z.string(), // Can be UUID or "new-{timestamp}" for new lineups
  boatId: z.string().uuid().nullable(),
  seats: z.array(seatSchema),
});

const bulkLineupsSchema = z.object({
  lineups: z.array(lineupSchema).max(10), // Max 10 boats per block
});

// PUT: Bulk save lineups for a block
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; blockId: string }> }
) {
  try {
    const { id: practiceId, blockId } = await params;
    const { teamSlug, userId } = await requireTeamBySlug(request);
    const ability = await buildAbility(userId, teamSlug);

    if (!ability.can('update', 'Practice')) {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // Verify block belongs to practice and is WATER type
    const block = await prisma.practiceBlock.findUnique({
      where: { id: blockId },
      select: { practiceId: true, type: true },
    });

    if (!block || block.practiceId !== practiceId) {
      return NextResponse.json({ error: 'Block not found' }, { status: 404 });
    }

    if (block.type !== 'WATER') {
      return NextResponse.json(
        { error: 'Lineups only supported for WATER blocks' },
        { status: 400 }
      );
    }

    const body = await request.json();
    const validated = bulkLineupsSchema.parse(body);

    // Process lineups in transaction
    await prisma.$transaction(async (tx) => {
      // Get existing lineups for this block
      const existingLineups = await tx.lineup.findMany({
        where: { blockId },
        select: { id: true },
      });
      const existingIds = new Set(existingLineups.map(l => l.id));

      // Determine which lineups to create, update, or delete
      const submittedIds = new Set<string>();
      const isNewId = (id: string) => id.startsWith('new-');

      for (const lineup of validated.lineups) {
        if (isNewId(lineup.id)) {
          // Create new lineup
          await tx.lineup.create({
            data: {
              blockId,
              boatId: lineup.boatId,
              seats: {
                create: lineup.seats
                  .filter(s => s.athleteId)
                  .map(s => ({
                    position: s.position,
                    side: s.side,
                    athleteId: s.athleteId!,
                  })),
              },
            },
          });
        } else {
          // Update existing lineup
          submittedIds.add(lineup.id);

          // Update lineup itself
          await tx.lineup.update({
            where: { id: lineup.id },
            data: { boatId: lineup.boatId },
          });

          // Delete all existing seats
          await tx.seatAssignment.deleteMany({
            where: { lineupId: lineup.id },
          });

          // Create new seats
          await tx.seatAssignment.createMany({
            data: lineup.seats
              .filter(s => s.athleteId)
              .map(s => ({
                lineupId: lineup.id,
                position: s.position,
                side: s.side,
                athleteId: s.athleteId!,
              })),
          });
        }
      }

      // Delete lineups that weren't submitted (removed by user)
      const lineupsToDelete = [...existingIds].filter(id => !submittedIds.has(id));
      if (lineupsToDelete.length > 0) {
        await tx.lineup.deleteMany({
          where: { id: { in: lineupsToDelete } },
        });
      }
    });

    // Fetch updated lineups
    const lineups = await prisma.lineup.findMany({
      where: { blockId },
      include: {
        boat: true,
        seats: {
          orderBy: { position: 'asc' },
          include: {
            athlete: {
              select: { id: true, displayName: true, sidePreference: true },
            },
          },
        },
      },
    });

    return NextResponse.json({ lineups });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: error.errors[0].message }, { status: 400 });
    }
    console.error('Error saving lineups:', error);
    return NextResponse.json({ error: 'Failed to save lineups' }, { status: 500 });
  }
}

// GET: Fetch lineups for a block
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string; blockId: string }> }
) {
  try {
    const { blockId } = await params;

    const lineups = await prisma.lineup.findMany({
      where: { blockId },
      include: {
        boat: true,
        seats: {
          orderBy: { position: 'asc' },
          include: {
            athlete: {
              select: { id: true, displayName: true, sidePreference: true },
            },
          },
        },
      },
    });

    return NextResponse.json({ lineups });
  } catch (error) {
    console.error('Error fetching lineups:', error);
    return NextResponse.json({ error: 'Failed to fetch lineups' }, { status: 500 });
  }
}
```

Key features:
- Bulk save all lineups for a block in one request
- Creates new lineups (id starts with "new-")
- Updates existing lineups
- Deletes removed lineups
- Transaction ensures consistency
- Max 10 boats per block
  </action>
  <verify>Test with curl: Save multiple lineups to a block, verify they persist</verify>
  <done>Multi-lineup bulk save endpoint created with create/update/delete support</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete practice flow redesign implementation:
- Inline editing for practice details (name, date, times, notes)
- Block-based structure with WATER, ERG, LAND, MEETING types
- Sortable block list with drag-drop and arrow buttons
- PM5-style workout builder with intervals
- Multi-boat lineup builder with drag-drop
- Bulk practice creation with date range
- Bulk practice delete with multi-select
  </what-built>
  <how-to-verify>
1. Start dev server: `npm run dev`
2. Navigate to a practice detail page (e.g., `/{teamSlug}/practices/{practiceId}`)

**Inline Editing (PRC-01):**
- [ ] Click practice name - it becomes editable inline
- [ ] Edit name, click away (blur) - saves silently
- [ ] Edit date/time - saves on blur
- [ ] Edit notes - saves on blur
- [ ] Try to save invalid data - see error toast with retry

**Block Structure (PRC-02, PRC-03, PRC-08):**
- [ ] See block type buttons: +Water, +Erg, +Land, +Meeting
- [ ] Add a block - appears in list with type badge
- [ ] Drag block to reorder - order updates
- [ ] Use up/down arrows - order updates
- [ ] Delete a block - removed from list

**Water Block - Lineup (PRC-04, PRC-05, PRC-06):**
- [ ] Expand water block - see lineup builder
- [ ] Add a boat - see empty seat grid
- [ ] Drag athlete from roster to seat - assigned
- [ ] Assigned athlete removed from available list
- [ ] Drag athlete to occupied seat - swap occurs
- [ ] Add second boat - multiple boats in block
- [ ] Drag athlete between boats - moves directly
- [ ] Save lineups - persists on refresh

**Erg Block - Workout (PRC-04, PRC-07):**
- [ ] Expand erg block - see workout builder
- [ ] Select workout type (intervals)
- [ ] Add interval - row appears
- [ ] Set duration, target split, rest
- [ ] Add more intervals (see count: X/50)
- [ ] Save workout - persists on refresh
- [ ] Toggle athlete visibility - changes icon

**Bulk Operations:**
- [ ] Navigate to bulk create page
- [ ] Select date range and days (Mon/Wed/Fri)
- [ ] See practice count preview
- [ ] Create multiple practices - all appear in list
- [ ] On practice list, enter selection mode
- [ ] Select multiple practices with checkboxes
- [ ] Bulk delete - removes selected practices
  </how-to-verify>
  <resume-signal>Type "approved" if all requirements verified, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
- [ ] Multi-lineup endpoint handles create/update/delete
- [ ] All PRC requirements verified by human
- [ ] No TypeScript errors
- [ ] No console errors during testing
</verification>

<success_criteria>
All 8 PRC requirements implemented:
- PRC-01: Inline editing - edit on-page, not separate form screens
- PRC-02: Block-based structure - practice divided into time blocks
- PRC-03: Block types - Water, Erg, Land, Meeting with type-specific forms
- PRC-04: Type-specific fields - water has boats/lineups, erg has workouts
- PRC-05: Drag-drop lineups - see available athletes, drag into seats
- PRC-06: Athlete availability - indicator of assigned vs available
- PRC-07: Workout display - structured intervals within blocks
- PRC-08: Block reordering - drag blocks to change order
</success_criteria>

<output>
After completion, create `.planning/phases/22-practice-flow-redesign/22-09-SUMMARY.md`
</output>
