---
phase: 03-lineup-management
plan: 07
type: execute
wave: 3
depends_on: [03-02]
files_modified:
  - src/app/api/lineup-templates/route.ts
  - src/app/api/lineup-templates/[id]/route.ts
  - src/app/api/lineup-templates/[id]/apply/route.ts
  - src/components/lineups/lineup-template-picker.tsx
  - src/components/lineups/save-as-template-button.tsx
autonomous: true

must_haves:
  truths:
    - "Coach can save a lineup as a reusable template"
    - "Coach can apply a template to quickly fill a lineup"
    - "Templates store default athletes and boat class"
    - "Applying template copies data (no ongoing link)"
  artifacts:
    - path: "src/app/api/lineup-templates/route.ts"
      provides: "GET, POST for lineup templates"
      exports: ["GET", "POST"]
    - path: "src/app/api/lineup-templates/[id]/route.ts"
      provides: "GET, PATCH, DELETE for template management"
      exports: ["GET", "PATCH", "DELETE"]
    - path: "src/app/api/lineup-templates/[id]/apply/route.ts"
      provides: "POST to apply template to a block"
      exports: ["POST"]
    - path: "src/components/lineups/lineup-template-picker.tsx"
      provides: "Dropdown to select and apply a template"
      exports: ["LineupTemplatePicker"]
    - path: "src/components/lineups/save-as-template-button.tsx"
      provides: "Button to save current lineup as template"
      exports: ["SaveAsTemplateButton"]
  key_links:
    - from: "src/app/api/lineup-templates/[id]/apply/route.ts"
      to: "prisma.lineup"
      via: "copy-on-apply pattern"
      pattern: "prisma\\.lineup\\.create"
    - from: "src/components/lineups/lineup-template-picker.tsx"
      to: "/api/lineup-templates/[id]/apply"
      via: "fetch POST"
      pattern: "fetch.*apply"
---

<objective>
Implement lineup template system for reusable configurations (LINE-03 requirement).

Purpose: Coaches frequently use the same lineup combinations. Templates let them save and quickly apply these configurations.
Output: Template CRUD API and UI components for save/apply workflow.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-lineup-management/03-CONTEXT.md
@.planning/phases/03-lineup-management/03-01-SUMMARY.md (LineupTemplate model)
@.planning/phases/03-lineup-management/03-02-SUMMARY.md (lineup API patterns)

# Existing patterns
@src/app/api/practice-templates/route.ts
@src/app/api/practice-templates/[id]/route.ts
@src/components/templates/apply-template-section.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lineup template CRUD API</name>
  <files>src/app/api/lineup-templates/route.ts, src/app/api/lineup-templates/[id]/route.ts</files>
  <action>
Create src/app/api/lineup-templates/route.ts:

1. GET handler - List templates for team:
   - Auth: require team member
   - Query params: boatClass (optional filter)
   - Return templates with seat count, sorted by name
   - Include: seats (without athlete details for list view)

2. POST handler - Create template from scratch or from lineup:
   - Auth: require COACH role
   - Validate body with createLineupTemplateSchema
   - Body includes:
     - name: string
     - boatClass: BoatClass
     - defaultBoatId: string (optional)
     - seats: Array<{ position, side, athleteId? }>
   - Create LineupTemplate with nested TemplateSeat records
   - Return 201 with created template

Create src/app/api/lineup-templates/[id]/route.ts:

1. GET handler:
   - Auth: require team member
   - Fetch template with seats and athlete info
   - Return full template details

2. PATCH handler:
   - Auth: require COACH role
   - Update template name, defaultBoatId, or seats
   - If seats provided: replace all (delete + create)
   - Use transaction for atomic update

3. DELETE handler:
   - Auth: require COACH role
   - Delete template (cascades to seats)
   - Return 204

Follow patterns from src/app/api/practice-templates/ for consistency.
  </action>
  <verify>
- POST creates template with seats
- GET returns template with athlete info
- PATCH updates correctly
- DELETE removes template
- Team scoping works
  </verify>
  <done>Lineup template CRUD API working</done>
</task>

<task type="auto">
  <name>Task 2: Create template apply endpoint</name>
  <files>src/app/api/lineup-templates/[id]/apply/route.ts</files>
  <action>
Create src/app/api/lineup-templates/[id]/apply/route.ts:

POST handler to apply template to a block:

1. Auth: require COACH role
2. Validate body:
   - blockId: z.string().uuid()
3. Fetch template with seats
4. Verify block exists, belongs to team, is WATER type
5. Verify block doesn't have a lineup (or delete existing)
6. Create new Lineup from template:
   - Copy boatId from template.defaultBoatId (if set and still available)
   - Copy seats from template (athleteId from TemplateSeat)
   - No foreign key back to template (copy-on-apply pattern)
7. Return 200 with created lineup

Edge cases:
- If template athlete is no longer eligible: skip that seat (leave empty)
- If default boat is no longer available: don't set boatId
- Log warnings for skipped data but don't fail

Response includes:
- Created lineup
- Warnings array (e.g., "Athlete X skipped - not eligible")
  </action>
  <verify>
- Apply creates lineup with seats
- Missing athletes are handled gracefully
- Unavailable boat is handled gracefully
- Warnings returned in response
  </verify>
  <done>Template apply endpoint working with graceful degradation</done>
</task>

<task type="auto">
  <name>Task 3: Create template picker and save button components</name>
  <files>src/components/lineups/lineup-template-picker.tsx, src/components/lineups/save-as-template-button.tsx</files>
  <action>
Create src/components/lineups/lineup-template-picker.tsx:

```typescript
'use client';

import { useState, useEffect } from 'react';
import { BoatClass } from '@/generated/prisma';
import { ChevronDown } from 'lucide-react';

interface LineupTemplate {
  id: string;
  name: string;
  boatClass: BoatClass;
  seatCount: number;
}

interface LineupTemplatePickerProps {
  boatClass: BoatClass;
  blockId: string;
  onApply: (templateId: string) => Promise<{ warnings?: string[] }>;
  disabled?: boolean;
}

export function LineupTemplatePicker({
  boatClass,
  blockId,
  onApply,
  disabled,
}: LineupTemplatePickerProps) {
  const [templates, setTemplates] = useState<LineupTemplate[]>([]);
  const [isOpen, setIsOpen] = useState(false);
  const [isApplying, setIsApplying] = useState(false);
  const [warnings, setWarnings] = useState<string[]>([]);

  // Fetch templates matching boat class
  useEffect(() => {
    fetch(`/api/lineup-templates?boatClass=${boatClass}`)
      .then(res => res.json())
      .then(data => setTemplates(data.templates || []))
      .catch(console.error);
  }, [boatClass]);

  async function handleApply(templateId: string) {
    setIsApplying(true);
    setWarnings([]);
    try {
      const result = await onApply(templateId);
      if (result.warnings?.length) {
        setWarnings(result.warnings);
      }
    } finally {
      setIsApplying(false);
      setIsOpen(false);
    }
  }

  if (templates.length === 0) {
    return null; // No templates available
  }

  return (
    <div className="relative">
      <button
        type="button"
        onClick={() => setIsOpen(!isOpen)}
        disabled={disabled || isApplying}
        className="flex items-center gap-2 px-3 py-1.5 text-sm text-zinc-400 hover:text-zinc-300 border border-zinc-700 rounded-lg transition-colors disabled:opacity-50"
      >
        <span>Apply Template</span>
        <ChevronDown className="h-4 w-4" />
      </button>

      {isOpen && (
        <div className="absolute z-10 mt-1 w-64 bg-zinc-900 border border-zinc-700 rounded-lg shadow-lg">
          {templates.map(template => (
            <button
              key={template.id}
              type="button"
              onClick={() => handleApply(template.id)}
              className="w-full px-3 py-2 text-left text-sm hover:bg-zinc-800 first:rounded-t-lg last:rounded-b-lg transition-colors"
            >
              <div className="text-zinc-200">{template.name}</div>
              <div className="text-zinc-500 text-xs">{template.seatCount} seats</div>
            </button>
          ))}
        </div>
      )}

      {warnings.length > 0 && (
        <div className="mt-2 p-2 bg-amber-500/10 border border-amber-500/30 rounded text-amber-400 text-xs">
          {warnings.map((w, i) => <div key={i}>{w}</div>)}
        </div>
      )}
    </div>
  );
}
```

Create src/components/lineups/save-as-template-button.tsx:

```typescript
'use client';

import { useState } from 'react';
import { Save } from 'lucide-react';
import { BoatClass } from '@/generated/prisma';

interface Seat {
  position: number;
  side: 'PORT' | 'STARBOARD' | 'NONE';
  athleteId: string | null;
}

interface SaveAsTemplateButtonProps {
  boatClass: BoatClass;
  boatId: string | null;
  seats: Seat[];
  onSaved?: () => void;
}

export function SaveAsTemplateButton({
  boatClass,
  boatId,
  seats,
  onSaved,
}: SaveAsTemplateButtonProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [name, setName] = useState('');
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function handleSave() {
    if (!name.trim()) {
      setError('Name is required');
      return;
    }

    setIsSaving(true);
    setError(null);

    try {
      const response = await fetch('/api/lineup-templates', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: name.trim(),
          boatClass,
          defaultBoatId: boatId,
          seats: seats.map(s => ({
            position: s.position,
            side: s.side,
            athleteId: s.athleteId,
          })),
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to save template');
      }

      setIsOpen(false);
      setName('');
      onSaved?.();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to save');
    } finally {
      setIsSaving(false);
    }
  }

  return (
    <>
      <button
        type="button"
        onClick={() => setIsOpen(true)}
        className="flex items-center gap-2 px-3 py-1.5 text-sm text-zinc-400 hover:text-zinc-300 border border-zinc-700 rounded-lg transition-colors"
      >
        <Save className="h-4 w-4" />
        <span>Save as Template</span>
      </button>

      {isOpen && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
          <div className="bg-zinc-900 border border-zinc-700 rounded-lg p-6 w-full max-w-md">
            <h3 className="text-lg font-medium text-zinc-200 mb-4">
              Save Lineup as Template
            </h3>

            <div className="space-y-4">
              <div>
                <label className="block text-sm text-zinc-400 mb-1">
                  Template Name
                </label>
                <input
                  type="text"
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  placeholder="e.g., Varsity 1V Standard"
                  className="w-full px-3 py-2 bg-zinc-800 border border-zinc-700 rounded-lg text-sm"
                  autoFocus
                />
              </div>

              <p className="text-sm text-zinc-500">
                {seats.filter(s => s.athleteId).length} athletes will be saved as defaults.
                {boatId && ' Default boat will be saved.'}
              </p>

              {error && (
                <p className="text-red-400 text-sm">{error}</p>
              )}
            </div>

            <div className="flex justify-end gap-3 mt-6">
              <button
                type="button"
                onClick={() => setIsOpen(false)}
                className="px-4 py-2 text-sm text-zinc-400 hover:text-zinc-300 transition-colors"
              >
                Cancel
              </button>
              <button
                type="button"
                onClick={handleSave}
                disabled={isSaving}
                className="px-4 py-2 text-sm bg-emerald-600 hover:bg-emerald-500 disabled:bg-zinc-700 text-white rounded-lg transition-colors"
              >
                {isSaving ? 'Saving...' : 'Save Template'}
              </button>
            </div>
          </div>
        </div>
      )}
    </>
  );
}
```

Both components follow existing template UI patterns from Phase 2.
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>Template picker and save button components created</done>
</task>

</tasks>

<verification>
All checks must pass:
1. `npx tsc --noEmit` - TypeScript compiles
2. POST /api/lineup-templates creates template
3. GET /api/lineup-templates lists by boat class
4. POST /api/lineup-templates/[id]/apply creates lineup from template
5. Apply handles missing athletes gracefully
6. LineupTemplatePicker shows templates and applies on selection
7. SaveAsTemplateButton creates template from current lineup
</verification>

<success_criteria>
- Coach can save a lineup as a template via button
- Coach can apply a template to fill a lineup
- Templates filter by boat class
- Missing athletes handled gracefully with warnings
- Unavailable boats handled gracefully
- Copy-on-apply pattern (no ongoing link)
- LINE-03 requirement complete
</success_criteria>

<output>
After completion, create `.planning/phases/03-lineup-management/03-07-SUMMARY.md`
</output>
