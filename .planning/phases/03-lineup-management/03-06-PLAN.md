---
phase: 03-lineup-management
plan: 06
type: execute
wave: 3
depends_on: [03-02, 03-04]
files_modified:
  - src/components/lineups/land-lineup-builder.tsx
  - src/components/lineups/lineup-editor.tsx
autonomous: true

must_haves:
  truths:
    - "Coach can assign multiple athletes to land/erg blocks"
    - "Assignment shows count of assigned athletes"
    - "Athletes can be assigned to multiple blocks in same practice"
    - "No seat positions for land/erg - just group assignment"
  artifacts:
    - path: "src/components/lineups/land-lineup-builder.tsx"
      provides: "Simple multi-select athlete assignment for land/erg blocks"
      exports: ["LandLineupBuilder"]
    - path: "src/components/lineups/lineup-editor.tsx"
      provides: "Updated to route to land builder for LAND/ERG blocks"
      exports: ["LineupEditor"]
  key_links:
    - from: "src/components/lineups/land-lineup-builder.tsx"
      to: "multi-select checkboxes"
      via: "checkbox input handling"
      pattern: "onChange.*checked"
    - from: "src/components/lineups/lineup-editor.tsx"
      to: "src/components/lineups/land-lineup-builder.tsx"
      via: "conditional rendering"
      pattern: "LandLineupBuilder"
---

<objective>
Build the land/erg block assignment UI with simple group-based athlete selection (LINE-04 requirement).

Purpose: Land and erg blocks don't need seat positions - coaches just assign which athletes participate. This is a simpler UI than water lineup building.
Output: Working land/erg assignment interface that persists via the assignments API.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-lineup-management/03-CONTEXT.md
@.planning/phases/03-lineup-management/03-02-SUMMARY.md (assignments API)
@.planning/phases/03-lineup-management/03-04-SUMMARY.md (dnd components)

# Existing patterns
@src/components/lineups/water-lineup-builder.tsx (will exist after 03-05)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create land/erg lineup builder component</name>
  <files>src/components/lineups/land-lineup-builder.tsx</files>
  <action>
Create src/components/lineups/land-lineup-builder.tsx:

This uses multi-select checkboxes instead of drag-drop (simpler for group assignment).

```typescript
'use client';

import { useState, useMemo } from 'react';
import { Check } from 'lucide-react';

interface Athlete {
  id: string;
  displayName: string | null;
  sidePreference?: 'PORT' | 'STARBOARD' | 'BOTH' | null;
}

interface LandLineupBuilderProps {
  blockId: string;
  blockType: 'LAND' | 'ERG';
  athletes: Athlete[];
  initialAssignedIds?: string[];
  onSave: (athleteIds: string[]) => Promise<void>;
  equipmentCount?: number; // For ERG blocks, show available ergs
}

export function LandLineupBuilder({
  blockId,
  blockType,
  athletes,
  initialAssignedIds = [],
  onSave,
  equipmentCount,
}: LandLineupBuilderProps) {
  const [selectedIds, setSelectedIds] = useState<Set<string>>(
    new Set(initialAssignedIds)
  );
  const [searchQuery, setSearchQuery] = useState('');
  const [isSaving, setIsSaving] = useState(false);

  // Filter athletes by search
  const filteredAthletes = useMemo(() => {
    if (!searchQuery) return athletes;
    const query = searchQuery.toLowerCase();
    return athletes.filter(a =>
      a.displayName?.toLowerCase().includes(query)
    );
  }, [athletes, searchQuery]);

  function toggleAthlete(athleteId: string) {
    setSelectedIds(prev => {
      const next = new Set(prev);
      if (next.has(athleteId)) {
        next.delete(athleteId);
      } else {
        next.add(athleteId);
      }
      return next;
    });
  }

  function selectAll() {
    setSelectedIds(new Set(filteredAthletes.map(a => a.id)));
  }

  function clearAll() {
    setSelectedIds(new Set());
  }

  async function handleSave() {
    setIsSaving(true);
    try {
      await onSave(Array.from(selectedIds));
    } finally {
      setIsSaving(false);
    }
  }

  const selectedCount = selectedIds.size;
  const showEquipmentWarning = blockType === 'ERG' &&
    equipmentCount !== undefined &&
    selectedCount > equipmentCount;

  return (
    <div className="space-y-4">
      {/* Header with count */}
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-medium text-zinc-200">
          {blockType === 'ERG' ? 'Erg Assignment' : 'Land Training Assignment'}
        </h3>
        <div className="text-sm text-zinc-400">
          {selectedCount} athlete{selectedCount !== 1 ? 's' : ''} assigned
          {equipmentCount !== undefined && blockType === 'ERG' && (
            <span className="ml-2 text-zinc-500">
              ({equipmentCount} ergs available)
            </span>
          )}
        </div>
      </div>

      {/* Equipment warning for ERG */}
      {showEquipmentWarning && (
        <div className="p-3 bg-amber-500/10 border border-amber-500/30 rounded-lg text-amber-400 text-sm">
          More athletes assigned ({selectedCount}) than ergs available ({equipmentCount}).
          Athletes may need to rotate or share equipment.
        </div>
      )}

      {/* Search and bulk actions */}
      <div className="flex gap-2">
        <input
          type="text"
          placeholder="Search athletes..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="flex-1 px-3 py-2 bg-zinc-800 border border-zinc-700 rounded-lg text-sm"
        />
        <button
          type="button"
          onClick={selectAll}
          className="px-3 py-2 text-sm text-zinc-400 hover:text-zinc-300 transition-colors"
        >
          Select all
        </button>
        <button
          type="button"
          onClick={clearAll}
          className="px-3 py-2 text-sm text-zinc-400 hover:text-zinc-300 transition-colors"
        >
          Clear
        </button>
      </div>

      {/* Athlete list with checkboxes */}
      <div className="border border-zinc-700 rounded-lg divide-y divide-zinc-700 max-h-[400px] overflow-y-auto">
        {filteredAthletes.map(athlete => {
          const isSelected = selectedIds.has(athlete.id);

          return (
            <label
              key={athlete.id}
              className={`
                flex items-center gap-3 px-3 py-2.5 cursor-pointer
                hover:bg-zinc-800/50 transition-colors
                ${isSelected ? 'bg-emerald-500/10' : ''}
              `}
            >
              {/* Custom checkbox */}
              <div
                className={`
                  w-5 h-5 rounded border-2 flex items-center justify-center
                  transition-colors
                  ${isSelected
                    ? 'bg-emerald-500 border-emerald-500'
                    : 'border-zinc-600 hover:border-zinc-500'
                  }
                `}
              >
                {isSelected && <Check className="h-3.5 w-3.5 text-white" />}
              </div>

              <input
                type="checkbox"
                checked={isSelected}
                onChange={() => toggleAthlete(athlete.id)}
                className="sr-only" // Hidden, using custom checkbox
              />

              {/* Athlete name */}
              <span className={`
                flex-1 text-sm
                ${isSelected ? 'text-zinc-200' : 'text-zinc-400'}
              `}>
                {athlete.displayName || 'Unnamed Athlete'}
              </span>

              {/* Side preference indicator (optional context) */}
              {athlete.sidePreference && athlete.sidePreference !== 'BOTH' && (
                <span className={`
                  text-xs px-1.5 py-0.5 rounded
                  ${athlete.sidePreference === 'PORT'
                    ? 'bg-blue-500/20 text-blue-400'
                    : 'bg-green-500/20 text-green-400'
                  }
                `}>
                  {athlete.sidePreference === 'PORT' ? 'P' : 'S'}
                </span>
              )}
            </label>
          );
        })}

        {filteredAthletes.length === 0 && (
          <div className="px-3 py-8 text-center text-zinc-500 text-sm">
            {searchQuery ? 'No athletes match search' : 'No athletes available'}
          </div>
        )}
      </div>

      {/* Save button */}
      <button
        type="button"
        onClick={handleSave}
        disabled={isSaving}
        className="w-full py-2 bg-emerald-600 hover:bg-emerald-500 disabled:bg-zinc-700 disabled:cursor-not-allowed rounded-lg text-white font-medium transition-colors"
      >
        {isSaving ? 'Saving...' : 'Save Assignments'}
      </button>
    </div>
  );
}
```

Key behaviors:
1. Multi-select with checkboxes (not drag-drop)
2. Search filtering
3. Select all / Clear all bulk actions
4. For ERG blocks: show erg count, warn if over capacity
5. No seat positions - just athlete IDs
6. Save button calls parent's onSave
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>Land/erg lineup builder with multi-select checkboxes created</done>
</task>

<task type="auto">
  <name>Task 2: Update lineup editor to route to land builder</name>
  <files>src/components/lineups/lineup-editor.tsx</files>
  <action>
Update src/components/lineups/lineup-editor.tsx to include the land builder:

```typescript
'use client';

import { BlockType, BoatClass } from '@/generated/prisma';
import { WaterLineupBuilder } from './water-lineup-builder';
import { LandLineupBuilder } from './land-lineup-builder';
import { getSeatsForBoatClass } from '@/lib/lineup/position-labels';

interface Athlete {
  id: string;
  displayName: string | null;
  sidePreference?: 'PORT' | 'STARBOARD' | 'BOTH' | null;
}

interface Boat {
  id: string;
  name: string;
  boatClass: BoatClass | null;
  available: boolean;
}

interface Seat {
  position: number;
  label: string;
  side: 'PORT' | 'STARBOARD' | 'NONE';
  athleteId: string | null;
}

interface LineupEditorProps {
  block: {
    id: string;
    type: BlockType;
    // For water blocks
    lineup?: {
      id: string;
      boatId: string | null;
      seats: Array<{
        athleteId: string;
        position: number;
        side: 'PORT' | 'STARBOARD' | 'NONE';
      }>;
    } | null;
    // For land/erg blocks
    landAssignments?: Array<{
      athleteId: string;
    }>;
  };
  athletes: Athlete[];
  boats: Boat[];
  boatClass: BoatClass; // Default boat class for water blocks
  ergCount?: number; // Available ergs for ERG blocks
  onSaveWaterLineup: (data: { seats: Seat[]; boatId: string | null }) => Promise<void>;
  onSaveLandAssignments: (athleteIds: string[]) => Promise<void>;
  existingLineups?: Array<{ boatId: string; practiceId: string; practiceName: string }>;
}

export function LineupEditor({
  block,
  athletes,
  boats,
  boatClass,
  ergCount,
  onSaveWaterLineup,
  onSaveLandAssignments,
  existingLineups = [],
}: LineupEditorProps) {
  if (block.type === 'WATER') {
    // Convert lineup data to seats format if exists
    const seatTemplate = getSeatsForBoatClass(boatClass);
    const initialSeats = block.lineup?.seats
      ? seatTemplate.map(t => {
          const existing = block.lineup?.seats.find(s => s.position === t.position);
          return {
            position: t.position,
            label: t.label,
            side: t.side as 'PORT' | 'STARBOARD' | 'NONE',
            athleteId: existing?.athleteId || null,
          };
        })
      : undefined;

    return (
      <WaterLineupBuilder
        blockId={block.id}
        boatClass={boatClass}
        athletes={athletes}
        boats={boats}
        initialSeats={initialSeats}
        initialBoatId={block.lineup?.boatId}
        onSave={onSaveWaterLineup}
        existingLineups={existingLineups}
      />
    );
  }

  // LAND or ERG block
  const initialAssignedIds = block.landAssignments?.map(a => a.athleteId) || [];

  return (
    <LandLineupBuilder
      blockId={block.id}
      blockType={block.type as 'LAND' | 'ERG'}
      athletes={athletes}
      initialAssignedIds={initialAssignedIds}
      onSave={onSaveLandAssignments}
      equipmentCount={block.type === 'ERG' ? ergCount : undefined}
    />
  );
}
```

Changes:
1. Import LandLineupBuilder
2. Handle landAssignments prop for LAND/ERG blocks
3. Pass ergCount for ERG blocks (erg equipment count)
4. Route to LandLineupBuilder for LAND and ERG types
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>Lineup editor routes to correct builder based on block type</done>
</task>

</tasks>

<verification>
All checks must pass:
1. `npx tsc --noEmit` - TypeScript compiles
2. LandLineupBuilder renders with checkboxes
3. Selecting athletes updates state correctly
4. Select all / Clear all work
5. Search filtering works
6. ERG block shows erg count and warning if over capacity
7. Save button calls onSave with athlete IDs
8. LineupEditor routes to LandLineupBuilder for LAND/ERG blocks
</verification>

<success_criteria>
- Coach can assign multiple athletes to land/erg blocks via checkboxes
- Search filtering works
- Select all / clear all bulk actions work
- ERG blocks show available erg count
- Warning shown if more athletes than ergs
- Save persists assignments via API
- LINE-04 requirement complete
</success_criteria>

<output>
After completion, create `.planning/phases/03-lineup-management/03-06-SUMMARY.md`
</output>
