---
phase: 03-lineup-management
plan: 09
type: execute
wave: 2
depends_on: []
files_modified:
  - src/components/forms/create-team-form.tsx
  - src/components/forms/invite-member-form.tsx
  - src/components/forms/csv-import-form.tsx
  - src/components/equipment/equipment-form.tsx
  - src/components/practices/practice-form.tsx
autonomous: true

must_haves:
  truths:
    - "Large form components split into focused sub-components"
    - "Form logic extracted into custom hooks where appropriate"
    - "Validation schemas co-located with forms"
    - "No component exceeds 300 lines"
  artifacts:
    - path: "src/components/forms/create-team-form.tsx"
      provides: "Refactored team creation form"
      min_lines: 0
      max_lines: 150
    - path: "src/components/equipment/equipment-form.tsx"
      provides: "Refactored equipment form with extracted sub-components"
      max_lines: 200
  key_links:
    - from: "src/components/forms/create-team-form.tsx"
      to: "src/lib/validations/team.ts"
      via: "schema import"
      pattern: "import.*validations"
---

<objective>
Refactor oversized form components to improve maintainability (DEBT-02 requirement).

Purpose: Several form components have grown large and complex. Breaking them into focused pieces improves readability and testability.
Output: Cleaner, more maintainable form components with extracted logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Forms to refactor
@src/components/forms/create-team-form.tsx
@src/components/forms/invite-member-form.tsx
@src/components/forms/csv-import-form.tsx
@src/components/equipment/equipment-form.tsx
@src/components/practices/practice-form.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit and analyze form components</name>
  <files>None (analysis only)</files>
  <action>
Analyze current form components to identify refactoring opportunities:

1. Check line counts:
   - `wc -l src/components/forms/*.tsx`
   - `wc -l src/components/equipment/equipment-form.tsx`
   - `wc -l src/components/practices/practice-form.tsx`

2. For each form, identify:
   - Total lines
   - Inline validation logic (should be in schema)
   - Repeated patterns (can be extracted)
   - Complex state logic (can be custom hook)
   - Sub-sections (can be child components)

3. Prioritize by size and complexity:
   - Forms > 250 lines need refactoring
   - Forms > 150 lines may benefit from extraction
   - Forms < 100 lines are likely fine

4. Document findings:
   - Which forms need attention
   - What to extract from each
   - Estimated impact

Do NOT change any files in this task - only analyze and plan.

Expected findings based on Phase 2 work:
- practice-form.tsx likely largest (includes block editor integration)
- equipment-form.tsx has shell-specific fields (conditional rendering)
- create-team-form.tsx has color picker logic
- csv-import-form.tsx has file parsing
  </action>
  <verify>Line count output recorded for reference</verify>
  <done>Form audit complete with prioritized refactoring plan</done>
</task>

<task type="auto">
  <name>Task 2: Refactor identified forms</name>
  <files>Varies based on audit</files>
  <action>
Based on audit findings, apply these refactoring patterns:

**Pattern 1: Extract validation schema to co-located file**

If form has inline validation, extract to `src/lib/validations/[domain].ts`:

```typescript
// Before: inline in form
const schema = z.object({ ... });

// After: separate file
// src/lib/validations/team.ts
export const createTeamSchema = z.object({ ... });
export type CreateTeamInput = z.infer<typeof createTeamSchema>;
```

**Pattern 2: Extract form sections as child components**

If form has distinct sections (e.g., equipment form has shell-specific fields):

```typescript
// Before: all in one file
{type === 'SHELL' && (
  <div>
    <label>Boat Class</label>
    ...50 lines of shell fields...
  </div>
)}

// After: extracted component
// src/components/equipment/shell-fields.tsx
export function ShellFields({ control }: { control: Control<FormData> }) {
  return (...);
}

// In main form:
{type === 'SHELL' && <ShellFields control={control} />}
```

**Pattern 3: Extract async logic to custom hook**

If form has complex submission logic:

```typescript
// Before: inline in component
async function onSubmit(data: FormData) {
  setIsSubmitting(true);
  try {
    const res = await fetch(...);
    if (!res.ok) throw new Error(...);
    ...error handling...
    router.push(...);
  } catch (e) {
    ...
  } finally {
    setIsSubmitting(false);
  }
}

// After: custom hook
// src/hooks/use-form-submit.ts
export function useFormSubmit<T>(endpoint: string, options: SubmitOptions) {
  // Encapsulates loading state, error handling, success redirect
}
```

**Pattern 4: Extract repeated input patterns**

If multiple forms use same input structure:

```typescript
// src/components/ui/form-field.tsx
export function FormField({
  label,
  error,
  children,
}: {
  label: string;
  error?: string;
  children: React.ReactNode;
}) {
  return (
    <div>
      <label className="...">{label}</label>
      {children}
      {error && <p className="text-red-400 text-sm">{error}</p>}
    </div>
  );
}
```

Apply patterns based on audit. Target: no form exceeds 300 lines, most under 200 lines.

For each form refactored:
1. Verify existing tests pass (if any)
2. Manually test form still works
3. Commit each refactored form separately
  </action>
  <verify>
- `wc -l` shows reduced line counts
- Forms still function correctly (manual test)
- `npx tsc --noEmit` passes
  </verify>
  <done>Forms refactored to meet size guidelines</done>
</task>

<task type="auto">
  <name>Task 3: Add JSDoc comments and improve readability</name>
  <files>Refactored form files</files>
  <action>
After refactoring structure, improve documentation:

1. Add JSDoc to exported components:
   ```typescript
   /**
    * Form for creating a new team.
    * Handles team name, slug, colors, and initial setup.
    *
    * @param onSuccess - Called after successful team creation with the team slug
    */
   export function CreateTeamForm({ onSuccess }: Props) { ... }
   ```

2. Add comments for non-obvious logic:
   ```typescript
   // Slug is auto-generated from name but can be edited
   // We only auto-update if user hasn't manually changed it
   const [slugTouched, setSlugTouched] = useState(false);
   ```

3. Group related state and effects with comment headers:
   ```typescript
   // --- Form State ---
   const [name, setName] = useState('');
   const [slug, setSlug] = useState('');

   // --- Derived State ---
   const isValid = name.length >= 3 && slug.length >= 3;

   // --- Effects ---
   useEffect(() => { ... }, []);
   ```

4. Ensure consistent naming:
   - `onSubmit` for form submission handlers
   - `onChange` for input change handlers
   - `is[Action]ing` for loading states (isSubmitting, isLoading)
   - `handle[Action]` for event handlers

This improves readability without changing functionality.
  </action>
  <verify>
- Components have JSDoc on exports
- Complex logic has comments
- Naming is consistent
- `npx tsc --noEmit` passes
  </verify>
  <done>Form components documented and readable</done>
</task>

</tasks>

<verification>
All checks must pass:
1. `npx tsc --noEmit` - TypeScript compiles
2. No form exceeds 300 lines
3. Each refactored form still functions correctly
4. Validation schemas co-located in lib/validations
5. Complex forms have extracted sub-components
</verification>

<success_criteria>
- DEBT-02 requirement complete
- Forms are more maintainable (smaller, focused)
- No functionality regressions
- Code is better documented
- Patterns can be reused for future forms
</success_criteria>

<output>
After completion, create `.planning/phases/03-lineup-management/03-09-SUMMARY.md`
</output>
