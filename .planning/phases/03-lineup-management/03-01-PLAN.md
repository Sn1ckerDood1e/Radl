---
phase: 03-lineup-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/validations/lineup.ts
  - src/lib/lineup/position-labels.ts
autonomous: true

must_haves:
  truths:
    - "Lineup model exists with blockId and optional boatId"
    - "SeatAssignment model links athletes to positions within lineups"
    - "LineupTemplate model exists for reusable configurations"
    - "EquipmentUsageLog model tracks when boats are assigned to practices"
    - "Standard rowing positions are defined with proper terminology"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Lineup, SeatAssignment, LineupTemplate, TemplateSeat, EquipmentUsageLog models"
      contains: "model Lineup"
    - path: "src/lib/validations/lineup.ts"
      provides: "Zod schemas for lineup validation"
      exports: ["createLineupSchema", "updateLineupSchema", "seatAssignmentSchema"]
    - path: "src/lib/lineup/position-labels.ts"
      provides: "Rowing position constants and helper functions"
      exports: ["ROWING_POSITIONS", "getSeatsForBoatClass"]
  key_links:
    - from: "prisma/schema.prisma"
      to: "PracticeBlock model"
      via: "Lineup.blockId relation"
      pattern: "blockId.*String"
    - from: "prisma/schema.prisma"
      to: "Equipment model"
      via: "Lineup.boatId optional relation"
      pattern: "boatId.*String\\?"
---

<objective>
Create the data foundation for lineup management: Prisma models for Lineup, SeatAssignment, templates, and equipment usage logging, plus validation schemas and rowing position constants.

Purpose: All lineup features require these data models and domain constants. This enables building the lineup editor UI and template system.
Output: Database schema ready for migration, validation schemas ready for API use, rowing terminology constants ready for UI.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-lineup-management/03-CONTEXT.md
@.planning/phases/03-lineup-management/03-RESEARCH.md

# Existing patterns
@prisma/schema.prisma
@src/lib/validations/practice.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Lineup and SeatAssignment models to Prisma schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Add the following to prisma/schema.prisma:

1. SeatSide enum (for sweep boats):
   - PORT
   - STARBOARD
   - NONE (for scull boats and coxswain)

2. Lineup model:
   - id: String @id @default(uuid())
   - blockId: String @unique (one lineup per block, relation to PracticeBlock, onDelete: Cascade)
   - boatId: String? (optional relation to Equipment, nullable until boat assigned)
   - notes: String? (lineup-specific notes)
   - createdAt: DateTime @default(now())
   - updatedAt: DateTime @updatedAt
   - Relation: seats SeatAssignment[]
   - Relation: block PracticeBlock (fields: [blockId], references: [id])
   - Relation: boat Equipment? (fields: [boatId], references: [id])
   - Index: [blockId]

3. SeatAssignment model:
   - id: String @id @default(uuid())
   - lineupId: String (relation to Lineup, onDelete: Cascade)
   - athleteId: String (relation to AthleteProfile)
   - position: Int (1-based: 1=Bow, 2-7=Middle, 8=Stroke, 9=Cox for 8+)
   - side: SeatSide (PORT/STARBOARD/NONE)
   - Relation: lineup Lineup (fields: [lineupId], references: [id])
   - Relation: athlete AthleteProfile (fields: [athleteId], references: [id])
   - Index: [lineupId, position] (unique - one athlete per position)
   - Index: [lineupId, athleteId] (unique - athlete can't be in multiple seats in same lineup)

4. LineupTemplate model:
   - id: String @id @default(uuid())
   - teamId: String
   - name: String (e.g., "Varsity 1V Standard")
   - boatClass: BoatClass (the target boat size)
   - defaultBoatId: String? (optional default boat)
   - createdAt: DateTime @default(now())
   - updatedAt: DateTime @updatedAt
   - Relation: team Team
   - Relation: seats TemplateSeat[]
   - Relation: defaultBoat Equipment?
   - Index: [teamId], [teamId, boatClass]

5. TemplateSeat model:
   - id: String @id @default(uuid())
   - templateId: String (relation to LineupTemplate, onDelete: Cascade)
   - athleteId: String? (default athlete for this seat, optional)
   - position: Int
   - side: SeatSide
   - Relation: template LineupTemplate
   - Relation: athlete AthleteProfile?
   - Index: [templateId, position] (unique)

6. EquipmentUsageLog model (EQUIP-01 requirement):
   - id: String @id @default(uuid())
   - equipmentId: String (relation to Equipment)
   - teamId: String (denormalized for queries)
   - practiceId: String (relation to Practice)
   - lineupId: String? (optional, for tracking which lineup used it)
   - usageDate: DateTime (the practice date)
   - createdAt: DateTime @default(now())
   - Relation: equipment Equipment
   - Relation: practice Practice
   - Relation: lineup Lineup?
   - Index: [equipmentId], [teamId], [practiceId]

7. LandAssignment model (for land/erg blocks - group-based):
   - id: String @id @default(uuid())
   - blockId: String (relation to PracticeBlock, onDelete: Cascade)
   - athleteId: String (relation to AthleteProfile)
   - Relation: block PracticeBlock
   - Relation: athlete AthleteProfile
   - Index: [blockId], [blockId, athleteId] (unique - athlete assigned once per block)

8. Update PracticeBlock model:
   - Add: lineup Lineup? (optional relation)
   - Add: landAssignments LandAssignment[] (for land/erg blocks)

9. Update Equipment model:
   - Add: usageLogs EquipmentUsageLog[]
   - Add: lineups Lineup[] (boats used in lineups)

10. Update AthleteProfile model:
    - Add: seatAssignments SeatAssignment[]
    - Add: templateSeats TemplateSeat[]
    - Add: landAssignments LandAssignment[]

11. Update Team model:
    - Add: lineupTemplates LineupTemplate[]

12. Update Practice model:
    - Add: usageLogs EquipmentUsageLog[]

Follow existing schema patterns: uuid IDs, teamId denormalization where needed, standard timestamps.
  </action>
  <verify>Run `npx prisma validate` - should pass with no errors</verify>
  <done>Prisma schema contains all lineup-related models with proper relations and indexes</done>
</task>

<task type="auto">
  <name>Task 2: Create Zod validation schemas and rowing position constants</name>
  <files>src/lib/validations/lineup.ts, src/lib/lineup/position-labels.ts</files>
  <action>
Create src/lib/lineup/position-labels.ts:

1. Define ROWING_POSITIONS constant object mapping BoatClass to seat configurations:
   - Each seat has: position (1-based), label (string), side (PORT/STARBOARD/NONE)
   - SINGLE_1X: [{ position: 1, label: 'Sculler', side: 'NONE' }]
   - DOUBLE_2X: [Bow, Stroke] (both NONE - scull)
   - PAIR_2_MINUS: [Bow (PORT), Stroke (STARBOARD)] - sweep
   - COXED_PAIR_2_PLUS: [Bow, Stroke, Cox]
   - FOUR_4_MINUS: [Bow, 2, 3, Stroke] - alternating port/starboard
   - COXED_FOUR_4_PLUS: [Bow, 2, 3, Stroke, Cox]
   - QUAD_4X: [Bow, 2, 3, Stroke] - all NONE (scull)
   - EIGHT_8_PLUS: [Bow, 2, 3, 4, 5, 6, 7, Stroke, Cox] - alternating port/starboard
   - OTHER: empty array (custom handling)

2. Export getSeatsForBoatClass(boatClass: BoatClass): returns array of seat objects with null athleteId

3. Export getCapacityForBoatClass(boatClass: BoatClass): returns number of seats

4. Export isScullBoat(boatClass: BoatClass): returns boolean (true for 1x, 2x, 4x)

5. Export POSITION_LABELS = { 1: 'Bow', 8: 'Stroke', 9: 'Cox' } for display

Create src/lib/validations/lineup.ts:

1. seatSideSchema: z.enum(['PORT', 'STARBOARD', 'NONE'])

2. seatAssignmentSchema:
   - athleteId: z.string().uuid()
   - position: z.number().int().min(1).max(9)
   - side: seatSideSchema

3. createLineupSchema:
   - blockId: z.string().uuid()
   - boatId: z.string().uuid().optional()
   - notes: z.string().max(500).optional()
   - seats: z.array(seatAssignmentSchema)
   - Add refinement: no duplicate athleteIds in seats array
   - Add refinement: no duplicate positions in seats array

4. updateLineupSchema:
   - boatId: z.string().uuid().nullable().optional() (can unset boat)
   - notes: z.string().max(500).nullable().optional()
   - seats: z.array(seatAssignmentSchema).optional()

5. createLineupTemplateSchema:
   - name: z.string().min(1).max(100)
   - boatClass: z.enum(['SINGLE_1X', ...all BoatClass values])
   - defaultBoatId: z.string().uuid().optional()
   - seats: z.array(templateSeatSchema)

6. templateSeatSchema:
   - athleteId: z.string().uuid().optional() (default athlete)
   - position: z.number().int().min(1).max(9)
   - side: seatSideSchema

7. createLandAssignmentSchema:
   - blockId: z.string().uuid()
   - athleteIds: z.array(z.string().uuid()).min(1)

8. Export types: CreateLineupInput, UpdateLineupInput, SeatAssignment, CreateLineupTemplateInput

Follow existing validation patterns from practice.ts: proper error messages, refinements for complex rules.
  </action>
  <verify>Run `npx tsc --noEmit` - should compile with no type errors</verify>
  <done>Validation schemas and position constants exist with proper exports</done>
</task>

<task type="auto">
  <name>Task 3: Generate Prisma client and verify schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Run database migration to apply schema changes:

1. Run `npx prisma db push` to apply schema changes to database
2. Run `npx prisma generate` to regenerate client types
3. Verify the generated types include all new models: Lineup, SeatAssignment, LineupTemplate, TemplateSeat, EquipmentUsageLog, LandAssignment

Note: Using db push (not migrate) for development. Migrations will be created before production deployment.

If db push fails due to existing data conflicts, report any issues.
  </action>
  <verify>
Run `npx prisma validate` passes
Run `npx tsc --noEmit` passes (client types available)
Import test: Can import { Lineup, SeatAssignment } from '@/generated/prisma'
  </verify>
  <done>Prisma client regenerated with new model types available for import</done>
</task>

</tasks>

<verification>
All checks must pass:
1. `npx prisma validate` - schema is valid
2. `npx prisma db push` - schema applied to database
3. `npx tsc --noEmit` - TypeScript compiles with new types
4. Lineup, SeatAssignment, LineupTemplate, TemplateSeat, EquipmentUsageLog models exist
5. ROWING_POSITIONS constant includes all standard boat classes
6. Validation schemas properly reject invalid inputs (duplicate athletes, invalid positions)
</verification>

<success_criteria>
- Prisma schema contains all Phase 3 data models
- Zod validation schemas ready for API routes
- Rowing position constants match standard terminology (Bow, 2-7, Stroke, Cox)
- Database schema applied and Prisma client regenerated
- All existing functionality still works (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/03-lineup-management/03-01-SUMMARY.md`
</output>
