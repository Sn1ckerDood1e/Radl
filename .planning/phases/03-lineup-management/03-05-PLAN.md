---
phase: 03-lineup-management
plan: 05
type: execute
wave: 3
depends_on: [03-02, 03-04]
files_modified:
  - src/components/lineups/water-lineup-builder.tsx
  - src/components/lineups/boat-selector.tsx
  - src/components/lineups/lineup-editor.tsx
autonomous: true

must_haves:
  truths:
    - "Coach can drag athletes from roster into seat positions"
    - "Dropping athlete auto-removes from previous seat if already assigned"
    - "Coach can select a compatible boat for the lineup"
    - "Only boats matching lineup size are shown"
    - "Unavailable boats are hidden from selection"
  artifacts:
    - path: "src/components/lineups/water-lineup-builder.tsx"
      provides: "Main drag-drop lineup building interface"
      exports: ["WaterLineupBuilder"]
    - path: "src/components/lineups/boat-selector.tsx"
      provides: "Filtered boat dropdown with compatibility checking"
      exports: ["BoatSelector"]
    - path: "src/components/lineups/lineup-editor.tsx"
      provides: "Top-level editor that routes to water vs land mode"
      exports: ["LineupEditor"]
  key_links:
    - from: "src/components/lineups/water-lineup-builder.tsx"
      to: "@dnd-kit/core"
      via: "DndContext provider"
      pattern: "DndContext"
    - from: "src/components/lineups/water-lineup-builder.tsx"
      to: "src/components/lineups/athlete-roster-panel.tsx"
      via: "component composition"
      pattern: "AthleteRosterPanel"
    - from: "src/components/lineups/boat-selector.tsx"
      to: "getCompatibleBoats filter"
      via: "filtering logic"
      pattern: "filter.*boatClass"
---

<objective>
Build the water lineup editor with drag-and-drop seat assignment and boat compatibility filtering (LINE-01, LINE-02 requirements).

Purpose: This is the core lineup building experience for water blocks. Coaches drag athletes into boat seats and select compatible equipment.
Output: Working water lineup builder that persists via the lineup API.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-lineup-management/03-CONTEXT.md
@.planning/phases/03-lineup-management/03-RESEARCH.md
@.planning/phases/03-lineup-management/03-02-SUMMARY.md (lineup API)
@.planning/phases/03-lineup-management/03-04-SUMMARY.md (dnd components)

# Existing patterns
@src/components/practices/block-editor.tsx
@src/lib/lineup/position-labels.ts (will exist after 03-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create boat selector with compatibility filtering</name>
  <files>src/components/lineups/boat-selector.tsx</files>
  <action>
Create src/components/lineups/boat-selector.tsx:

```typescript
'use client';

import { useState, useEffect } from 'react';
import { BoatClass } from '@/generated/prisma';
import { getCapacityForBoatClass } from '@/lib/lineup/position-labels';

interface Boat {
  id: string;
  name: string;
  boatClass: BoatClass | null;
  available: boolean; // Derived from manualUnavailable and damage reports
}

interface BoatSelectorProps {
  boats: Boat[];
  selectedBoatId: string | null;
  requiredCapacity: number; // Number of seats in lineup (excluding cox)
  onSelect: (boatId: string | null) => void;
  practiceStartTime?: Date; // For double-booking check
  practiceEndTime?: Date;
  existingLineups?: Array<{ boatId: string; practiceId: string; practiceName: string }>; // For warning
}

export function BoatSelector({
  boats,
  selectedBoatId,
  requiredCapacity,
  onSelect,
  practiceStartTime,
  practiceEndTime,
  existingLineups = [],
}: BoatSelectorProps) {
  // Filter boats:
  // 1. Must be SHELL type (already filtered by parent passing only shells)
  // 2. Must be available (not damaged, not manually unavailable)
  // 3. Must match required capacity (boat class capacity = requiredCapacity)

  const compatibleBoats = boats.filter(boat => {
    if (!boat.available) return false;
    if (!boat.boatClass) return false;
    const capacity = getCapacityForBoatClass(boat.boatClass);
    return capacity === requiredCapacity;
  });

  // Check for double-booking warning (non-blocking)
  const selectedBoat = boats.find(b => b.id === selectedBoatId);
  const doubleBookingWarning = selectedBoatId
    ? existingLineups.find(l => l.boatId === selectedBoatId)
    : null;

  return (
    <div className="space-y-2">
      <label className="block text-sm font-medium text-zinc-300">
        Select Boat
      </label>

      <select
        value={selectedBoatId || ''}
        onChange={(e) => onSelect(e.target.value || null)}
        className="w-full px-3 py-2 bg-zinc-800 border border-zinc-700 rounded-lg text-sm"
      >
        <option value="">No boat selected</option>
        {compatibleBoats.map(boat => (
          <option key={boat.id} value={boat.id}>
            {boat.name} ({boat.boatClass})
          </option>
        ))}
      </select>

      {compatibleBoats.length === 0 && (
        <p className="text-amber-400 text-sm">
          No compatible {requiredCapacity}-seat boats available
        </p>
      )}

      {doubleBookingWarning && (
        <div className="p-3 bg-amber-500/10 border border-amber-500/30 rounded-lg text-amber-400 text-sm">
          This boat is already assigned to "{doubleBookingWarning.practiceName}" at this time.
          You can still use it if this is intentional (split squad).
        </div>
      )}

      {selectedBoat && (
        <p className="text-zinc-500 text-xs">
          {selectedBoat.name} - {selectedBoat.boatClass}
        </p>
      )}
    </div>
  );
}
```

The parent component will:
1. Fetch available boats (shells only, with availability status)
2. Pass existing lineups with overlapping times for warning
3. Handle boat selection change
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>Boat selector component with filtering and warning created</done>
</task>

<task type="auto">
  <name>Task 2: Create water lineup builder with drag-drop</name>
  <files>src/components/lineups/water-lineup-builder.tsx</files>
  <action>
Create src/components/lineups/water-lineup-builder.tsx:

```typescript
'use client';

import { useState, useMemo } from 'react';
import {
  DndContext,
  DragOverlay,
  closestCorners,
  PointerSensor,
  KeyboardSensor,
  useSensors,
  useSensor,
  DragStartEvent,
  DragEndEvent,
} from '@dnd-kit/core';
import { sortableKeyboardCoordinates } from '@dnd-kit/sortable';
import { BoatClass } from '@/generated/prisma';
import { getSeatsForBoatClass, ROWING_POSITIONS } from '@/lib/lineup/position-labels';
import { AthleteRosterPanel } from './athlete-roster-panel';
import { SeatSlot } from './seat-slot';
import { AthleteCard } from './athlete-card';
import { BoatSelector } from './boat-selector';

interface Athlete {
  id: string;
  displayName: string | null;
  sidePreference?: 'PORT' | 'STARBOARD' | 'BOTH' | null;
}

interface Seat {
  position: number;
  label: string;
  side: 'PORT' | 'STARBOARD' | 'NONE';
  athleteId: string | null;
}

interface Boat {
  id: string;
  name: string;
  boatClass: BoatClass | null;
  available: boolean;
}

interface WaterLineupBuilderProps {
  blockId: string;
  boatClass: BoatClass; // The target boat class for this lineup
  athletes: Athlete[];
  boats: Boat[];
  initialSeats?: Seat[];
  initialBoatId?: string | null;
  onSave: (data: { seats: Seat[]; boatId: string | null }) => Promise<void>;
  existingLineups?: Array<{ boatId: string; practiceId: string; practiceName: string }>;
}

export function WaterLineupBuilder({
  blockId,
  boatClass,
  athletes,
  boats,
  initialSeats,
  initialBoatId = null,
  onSave,
  existingLineups = [],
}: WaterLineupBuilderProps) {
  // Initialize seats from boat class if no initial seats
  const defaultSeats = useMemo(() => {
    const template = getSeatsForBoatClass(boatClass);
    return template.map(t => ({ ...t, athleteId: null }));
  }, [boatClass]);

  const [seats, setSeats] = useState<Seat[]>(initialSeats || defaultSeats);
  const [selectedBoatId, setSelectedBoatId] = useState<string | null>(initialBoatId);
  const [activeId, setActiveId] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [showAssigned, setShowAssigned] = useState(false);
  const [isSaving, setIsSaving] = useState(false);

  // Set of assigned athlete IDs (for roster panel filtering)
  const assignedAthleteIds = useMemo(
    () => new Set(seats.filter(s => s.athleteId).map(s => s.athleteId!)),
    [seats]
  );

  // Sensors for drag
  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  function handleDragStart(event: DragStartEvent) {
    setActiveId(event.active.id as string);
  }

  function handleDragEnd(event: DragEndEvent) {
    const { active, over } = event;
    setActiveId(null);

    if (!over) return;

    const athleteId = active.id as string;
    const overId = over.id as string;

    // Check if dropping on a seat slot
    if (overId.startsWith('seat-')) {
      const seatPosition = parseInt(overId.replace('seat-', ''));

      setSeats(prev => {
        // Remove athlete from any existing seat
        const updated = prev.map(s =>
          s.athleteId === athleteId ? { ...s, athleteId: null } : s
        );

        // Assign to new seat
        return updated.map(s =>
          s.position === seatPosition ? { ...s, athleteId } : s
        );
      });
    }
  }

  function handleRemoveFromSeat(position: number) {
    setSeats(prev =>
      prev.map(s =>
        s.position === position ? { ...s, athleteId: null } : s
      )
    );
  }

  async function handleSave() {
    setIsSaving(true);
    try {
      await onSave({ seats, boatId: selectedBoatId });
    } finally {
      setIsSaving(false);
    }
  }

  // Get capacity for boat selector
  const capacity = seats.filter(s => s.label !== 'Cox').length;

  // Find active athlete for overlay
  const activeAthlete = activeId ? athletes.find(a => a.id === activeId) : null;

  return (
    <DndContext
      sensors={sensors}
      collisionDetection={closestCorners}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
    >
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Roster panel - left side */}
        <div className="lg:col-span-1 bg-zinc-900 border border-zinc-800 rounded-lg h-[500px]">
          <AthleteRosterPanel
            athletes={athletes}
            assignedAthleteIds={assignedAthleteIds}
            showAssigned={showAssigned}
            searchQuery={searchQuery}
            onSearchChange={setSearchQuery}
          />
        </div>

        {/* Seat layout - center */}
        <div className="lg:col-span-1 space-y-4">
          <h3 className="text-lg font-medium text-zinc-200">
            {boatClass.replace(/_/g, ' ')} Lineup
          </h3>

          <div className="space-y-2">
            {seats.map(seat => {
              const athlete = seat.athleteId
                ? athletes.find(a => a.id === seat.athleteId)
                : null;

              return (
                <SeatSlot
                  key={seat.position}
                  seatId={`seat-${seat.position}`}
                  position={seat.position}
                  label={seat.label}
                  side={seat.side}
                  athlete={athlete}
                  onRemove={() => handleRemoveFromSeat(seat.position)}
                />
              );
            })}
          </div>

          {/* Lineup stats */}
          <div className="text-sm text-zinc-500">
            {assignedAthleteIds.size} / {seats.length} seats filled
            {assignedAthleteIds.size < seats.length && (
              <span className="text-amber-400 ml-2">
                (partial lineup)
              </span>
            )}
          </div>
        </div>

        {/* Boat selector - right side */}
        <div className="lg:col-span-1 space-y-4">
          <BoatSelector
            boats={boats}
            selectedBoatId={selectedBoatId}
            requiredCapacity={capacity}
            onSelect={setSelectedBoatId}
            existingLineups={existingLineups}
          />

          {/* Save button */}
          <button
            type="button"
            onClick={handleSave}
            disabled={isSaving}
            className="w-full py-2 bg-emerald-600 hover:bg-emerald-500 disabled:bg-zinc-700 disabled:cursor-not-allowed rounded-lg text-white font-medium transition-colors"
          >
            {isSaving ? 'Saving...' : 'Save Lineup'}
          </button>
        </div>
      </div>

      {/* Drag overlay */}
      <DragOverlay>
        {activeAthlete ? (
          <AthleteCard athlete={activeAthlete} isDragging />
        ) : null}
      </DragOverlay>
    </DndContext>
  );
}
```

Key behaviors:
1. Drag from roster to seat slot
2. Auto-remove from previous seat when dropped
3. Filter roster by search and assigned status
4. Show partial lineup warning
5. Boat selector filters by capacity
6. Save button calls parent's onSave
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>Water lineup builder with full drag-drop functionality created</done>
</task>

<task type="auto">
  <name>Task 3: Create lineup editor wrapper component</name>
  <files>src/components/lineups/lineup-editor.tsx</files>
  <action>
Create src/components/lineups/lineup-editor.tsx:

This component routes to water vs land/erg mode based on block type.

```typescript
'use client';

import { BlockType, BoatClass } from '@/generated/prisma';
import { WaterLineupBuilder } from './water-lineup-builder';
// LandLineupBuilder will be created in plan 03-06

interface Athlete {
  id: string;
  displayName: string | null;
  sidePreference?: 'PORT' | 'STARBOARD' | 'BOTH' | null;
}

interface Boat {
  id: string;
  name: string;
  boatClass: BoatClass | null;
  available: boolean;
}

interface Seat {
  position: number;
  label: string;
  side: 'PORT' | 'STARBOARD' | 'NONE';
  athleteId: string | null;
}

interface LineupEditorProps {
  block: {
    id: string;
    type: BlockType;
    lineup?: {
      id: string;
      boatId: string | null;
      seats: Array<{
        athleteId: string;
        position: number;
        side: 'PORT' | 'STARBOARD' | 'NONE';
      }>;
    } | null;
  };
  athletes: Athlete[];
  boats: Boat[];
  boatClass: BoatClass; // Default boat class for water blocks
  onSaveWaterLineup: (data: { seats: Seat[]; boatId: string | null }) => Promise<void>;
  onSaveLandAssignments?: (athleteIds: string[]) => Promise<void>;
  existingLineups?: Array<{ boatId: string; practiceId: string; practiceName: string }>;
}

export function LineupEditor({
  block,
  athletes,
  boats,
  boatClass,
  onSaveWaterLineup,
  onSaveLandAssignments,
  existingLineups = [],
}: LineupEditorProps) {
  if (block.type === 'WATER') {
    // Convert lineup data to seats format if exists
    const initialSeats = block.lineup?.seats.map(s => ({
      position: s.position,
      label: getPositionLabel(s.position, boatClass),
      side: s.side,
      athleteId: s.athleteId,
    }));

    return (
      <WaterLineupBuilder
        blockId={block.id}
        boatClass={boatClass}
        athletes={athletes}
        boats={boats}
        initialSeats={initialSeats}
        initialBoatId={block.lineup?.boatId}
        onSave={onSaveWaterLineup}
        existingLineups={existingLineups}
      />
    );
  }

  // LAND or ERG block - placeholder until 03-06
  return (
    <div className="p-6 bg-zinc-900 border border-zinc-800 rounded-lg text-center">
      <p className="text-zinc-400">
        Land/Erg assignment UI coming in next plan
      </p>
      <p className="text-zinc-500 text-sm mt-2">
        Block type: {block.type}
      </p>
    </div>
  );
}

// Helper to get position label from number
function getPositionLabel(position: number, boatClass: BoatClass): string {
  const labels: Record<number, string> = {
    1: 'Bow',
    8: 'Stroke',
    9: 'Cox',
  };
  return labels[position] || position.toString();
}
```

This wrapper:
1. Detects block type and routes to correct builder
2. Transforms lineup data for water builder
3. Shows placeholder for land/erg until 03-06
4. Passes through all necessary props
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>Lineup editor wrapper routing to correct builder based on block type</done>
</task>

</tasks>

<verification>
All checks must pass:
1. `npx tsc --noEmit` - TypeScript compiles
2. WaterLineupBuilder renders with seat slots
3. Drag from roster to seat assigns athlete
4. Dropping on occupied seat swaps athletes
5. Removing athlete from seat works
6. BoatSelector filters by capacity
7. Double-booking warning displays
8. Save button calls onSave with lineup data
</verification>

<success_criteria>
- Coach can drag athletes from roster into seat positions
- Athlete auto-removed from previous seat when dropped
- Boat selector only shows compatible boats (matching capacity, available)
- Unavailable boats hidden from selection
- Double-booking warning shown (non-blocking)
- Partial lineup warning shown
- Save persists lineup via API (parent handles)
- LINE-01 and LINE-02 requirements addressed
</success_criteria>

<output>
After completion, create `.planning/phases/03-lineup-management/03-05-SUMMARY.md`
</output>
