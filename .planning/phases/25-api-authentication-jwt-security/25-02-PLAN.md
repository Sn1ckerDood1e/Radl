---
phase: 25-api-authentication-jwt-security
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/phases/25-api-authentication-jwt-security/25-02-AUDIT-REPORT.md
autonomous: true

must_haves:
  truths:
    - "JWT signatures are verified on every authenticated request"
    - "Expired JWT tokens are rejected with 401"
    - "JWT claims match expected structure (sub, email, team_id, user_role)"
    - "Tampered tokens are rejected"
  artifacts:
    - path: ".planning/phases/25-api-authentication-jwt-security/25-02-AUDIT-REPORT.md"
      provides: "JWT security testing results"
      contains: "AUTH-02, AUTH-03, AUTH-04 compliance"
  key_links:
    - from: "src/lib/auth/claims.ts"
      to: "supabase.auth.getUser()"
      via: "JWT verification happens server-side"
      pattern: "getUser.*before.*getSession"
---

<objective>
Test JWT signature verification, expiration enforcement, and claims validation (AUTH-02, AUTH-03, AUTH-04).

Purpose: Ensure JWTs cannot be forged, expired tokens are rejected, and claims are properly validated. This validates the cryptographic security of the authentication system.

Output: JWT security test report with pass/fail status for each requirement.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# JWT handling code
@src/middleware.ts
@src/lib/auth/claims.ts
@src/lib/auth/authorize.ts
@src/lib/auth/get-auth-context.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit JWT verification code patterns</name>
  <files>.planning/phases/25-api-authentication-jwt-security/25-02-AUDIT-REPORT.md</files>
  <action>
    Static analysis of JWT handling code:

    1. AUTH-02 - Signature Verification:
       - Verify middleware uses supabase.auth.getUser() NOT getSession()
       - getUser() verifies JWT with Supabase server (signature check)
       - getSession() only reads local cookie (no signature verification)
       - Pattern: MUST see getUser() called BEFORE any getSession()

    2. Audit getClaimsForApiRoute() in src/lib/auth/claims.ts:
       - Line 67-68: Should call getUser() FIRST
       - Line 75: Should call getSession() AFTER getUser() succeeds
       - This is the SECURE pattern - verify it's followed

    3. Audit getAuthContext() in src/lib/auth/get-auth-context.ts:
       - Calls getClaimsForApiRoute() which does proper verification
       - GOOD if it delegates to claims.ts

    4. Check for any code that calls getSession() without getUser():
       - grep for "getSession" and verify each call is preceded by getUser()
       - Any standalone getSession() is a vulnerability

    5. AUTH-03 - Expiration Enforcement:
       - Supabase handles this automatically in getUser()
       - Verify no manual JWT decoding that skips expiration check
       - jwtDecode() is used AFTER getUser() verification (claims extraction only)

    6. AUTH-04 - Claims Validation:
       - Check CustomJwtPayload interface matches expected structure
       - Verify sub, email, team_id, user_role are defined
       - Check for any runtime claims validation (Zod or manual)

    7. Document findings in audit report with:
       - Code location for each security pattern
       - Pass/Fail for AUTH-02, AUTH-03, AUTH-04
       - Any vulnerabilities found
  </action>
  <verify>
    - grep "getSession" in src/lib/auth shows all calls are after getUser()
    - middleware.ts line 67-72 shows getUser() call with comment about security
    - jwtDecode is only called after getUser() verification
  </verify>
  <done>
    JWT verification code audit complete.
    AUTH-02 (signature verification) status documented.
    AUTH-03 (expiration) status documented.
    AUTH-04 (claims validation) status documented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create JWT security test scenarios</name>
  <files>.planning/phases/25-api-authentication-jwt-security/25-02-AUDIT-REPORT.md</files>
  <action>
    Document test scenarios that WOULD verify JWT security (manual testing guide):

    1. Expired Token Test (AUTH-03):
       ```
       Test: Send request with expired JWT
       Expected: 401 Unauthorized
       How to test:
       - Wait for token to expire (or modify exp claim)
       - Make API request
       - Should redirect to /login or return 401
       ```

    2. Tampered Token Test (AUTH-02):
       ```
       Test: Modify JWT payload and resend
       Expected: 401 Unauthorized
       How to test:
       - Take valid JWT from cookies
       - Decode, modify payload (e.g., change team_id)
       - Re-encode (signature will be invalid)
       - Make API request
       - Should fail verification
       ```

    3. Missing Token Test:
       ```
       Test: Request protected route with no auth cookie
       Expected: Redirect to /login (pages) or 401 (API)
       How to test:
       - Clear cookies
       - Request /api/practices
       - Should get 401
       ```

    4. Invalid Claims Test (AUTH-04):
       ```
       Test: JWT with unexpected claims structure
       Expected: Graceful handling (no crash, proper error)
       How to test:
       - Requires crafting custom JWT
       - Or: Code review for defensive claims handling
       ```

    Note: Full JWT manipulation testing requires jwt_tool or similar.
    For this audit, static analysis + manual testing guide is sufficient.

    5. Add testing commands to audit report:
       - curl commands for protected routes without auth
       - Expected responses
       - Browser-based testing steps
  </action>
  <verify>
    Audit report includes:
    - Test scenarios for AUTH-02, AUTH-03, AUTH-04
    - Expected behaviors documented
    - Manual testing steps provided
  </verify>
  <done>
    JWT security test guide complete.
    Test scenarios documented for all three requirements.
    Manual testing steps provided for verification.
  </done>
</task>

<task type="auto">
  <name>Task 3: Test unauthenticated API access</name>
  <files>.planning/phases/25-api-authentication-jwt-security/25-02-AUDIT-REPORT.md</files>
  <action>
    Run actual tests against local dev server to verify auth enforcement:

    1. Start dev server if not running: npm run dev

    2. Test protected route without auth:
       ```bash
       curl -v http://localhost:3000/api/practices
       # Expected: 401 or redirect to /login
       ```

    3. Test protected route with invalid Bearer token:
       ```bash
       curl -v -H "Authorization: Bearer invalid_token" http://localhost:3000/api/practices
       # Expected: 401
       ```

    4. Test public route without auth:
       ```bash
       curl -v http://localhost:3000/api/auth/callback
       # Expected: Should not require auth (redirect to login on error is OK)
       ```

    5. Test damage report endpoint (public by design):
       ```bash
       # This should work without auth (with valid equipment ID)
       curl -v -X POST http://localhost:3000/api/equipment/test-id/damage-reports \
         -H "Content-Type: application/json" \
         -d '{"location": "test", "description": "test", "severity": "LOW", "reporterName": "Test"}'
       # Expected: 404 (equipment not found) is OK - means route is accessible
       ```

    6. Document actual responses in audit report

    7. If any protected route allows unauthenticated access: FLAG AS CRITICAL
  </action>
  <verify>
    - curl commands executed
    - All protected routes return 401 or redirect when unauthenticated
    - Public routes are accessible
    - Results documented in audit report
  </verify>
  <done>
    Live API testing complete.
    All protected routes reject unauthenticated requests.
    AUTH-02, AUTH-03, AUTH-04: PASS or issues documented
  </done>
</task>

</tasks>

<verification>
JWT Security Verification Checklist:
- [ ] middleware.ts uses getUser() for JWT verification
- [ ] getClaimsForApiRoute() calls getUser() before getSession()
- [ ] No code calls getSession() without prior getUser()
- [ ] jwtDecode() only used for claims extraction after verification
- [ ] Protected routes return 401 when unauthenticated
- [ ] CustomJwtPayload interface matches expected structure
</verification>

<success_criteria>
- AUTH-02: JWT signatures are verified via getUser() on every request
- AUTH-03: Expired tokens are rejected (handled by Supabase getUser())
- AUTH-04: Claims follow expected structure (CustomJwtPayload interface)
- Audit report documents all findings with evidence
</success_criteria>

<output>
After completion, create `.planning/phases/25-api-authentication-jwt-security/25-02-SUMMARY.md`
</output>
