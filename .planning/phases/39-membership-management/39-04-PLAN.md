---
phase: 39-membership-management
plan: 04
type: execute
wave: 3
depends_on: ["39-01", "39-03"]
files_modified:
  - src/hooks/use-membership-csv-parser.ts
  - src/app/api/admin/clubs/[clubId]/members/bulk/route.ts
  - src/app/(admin)/admin/clubs/[clubId]/members/bulk/page.tsx
  - src/components/admin/memberships/bulk-membership-form.tsx
  - src/lib/audit/actions.ts
  - src/components/admin/memberships/club-members-section.tsx
autonomous: true

must_haves:
  truths:
    - "Super admin can upload CSV to add multiple users to a club"
    - "CSV rows with unknown emails are skipped with error message"
    - "CSV rows with valid emails create or update memberships"
    - "Results summary shows added, updated, skipped counts"
    - "Bulk operation is audit logged"
  artifacts:
    - path: "src/hooks/use-membership-csv-parser.ts"
      provides: "CSV parser hook for membership import"
      exports: ["useMembershipCSVParser"]
    - path: "src/app/api/admin/clubs/[clubId]/members/bulk/route.ts"
      provides: "Bulk membership import endpoint"
      exports: ["POST"]
    - path: "src/components/admin/memberships/bulk-membership-form.tsx"
      provides: "Bulk upload form component"
      exports: ["BulkMembershipForm"]
  key_links:
    - from: "src/components/admin/memberships/bulk-membership-form.tsx"
      to: "/api/admin/clubs/[clubId]/members/bulk"
      via: "fetch POST"
      pattern: "api/admin/clubs.*members/bulk"
    - from: "src/hooks/use-membership-csv-parser.ts"
      to: "papaparse"
      via: "import"
      pattern: "Papa\\.parse"
---

<objective>
Implement bulk membership import via CSV upload.

Purpose: Allow super admins to add multiple users to a club in one operation using a CSV file (MEMB-05).

Output: CSV parser hook, bulk API endpoint, upload form with preview and results.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/39-membership-management/39-CONTEXT.md
@.planning/phases/39-membership-management/39-RESEARCH.md
@src/hooks/use-admin-csv-parser.ts (pattern to follow)
@src/app/api/admin/users/bulk/route.ts (pattern for bulk API)
@src/components/admin/users/bulk-upload-form.tsx (pattern for UI)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create membership CSV parser hook</name>
  <files>src/hooks/use-membership-csv-parser.ts</files>
  <action>
Adapt `use-admin-csv-parser.ts` pattern for membership import:

CSV format: `email,role` (or `email,roles` for multi-role)
- email: required, valid email format
- role/roles: optional, comma-separated for multi-role (default: ATHLETE)

```typescript
import { useState, useCallback } from 'react';
import Papa from 'papaparse';

export interface ParsedMembershipRow {
  email: string;
  roles: string[];
}

export interface MembershipRowError {
  row: number;
  field: string;
  message: string;
}

export interface MembershipParseResult {
  validRows: ParsedMembershipRow[];
  errors: MembershipRowError[];
  duplicates: { email: string; rows: number[] }[];
}

const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
const VALID_ROLES = ['FACILITY_ADMIN', 'CLUB_ADMIN', 'COACH', 'ATHLETE', 'PARENT'];

export function useMembershipCSVParser() {
  const [parseResult, setParseResult] = useState<MembershipParseResult | null>(null);
  const [parseError, setParseError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const parseFile = useCallback((file: File | null) => {
    setParseError(null);
    setParseResult(null);

    if (!file) return;

    if (!file.name.toLowerCase().endsWith('.csv')) {
      setParseError('Please upload a CSV file');
      return;
    }

    setIsLoading(true);

    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      transformHeader: (header) => header.trim().toLowerCase(),
      complete: (results) => {
        setIsLoading(false);

        const data = results.data as Record<string, string>[];
        const validRows: ParsedMembershipRow[] = [];
        const errors: MembershipRowError[] = [];
        const emailOccurrences = new Map<string, number[]>();

        for (let i = 0; i < data.length; i++) {
          const row = data[i];
          const rowNum = i + 2; // Account for header (1-indexed)

          // Get email (required)
          const email = row.email?.trim().toLowerCase();
          if (!email) {
            errors.push({ row: rowNum, field: 'email', message: 'Email is required' });
            continue;
          }

          if (!EMAIL_REGEX.test(email)) {
            errors.push({ row: rowNum, field: 'email', message: 'Invalid email format' });
            continue;
          }

          // Track for duplicates
          const existing = emailOccurrences.get(email) || [];
          existing.push(rowNum);
          emailOccurrences.set(email, existing);

          // Get roles (optional, default to ATHLETE)
          const roleString = (row.role || row.roles || 'ATHLETE').trim().toUpperCase();
          const roles = roleString.split(',').map((r) => r.trim()).filter(Boolean);

          // Validate roles
          const invalidRoles = roles.filter((r) => !VALID_ROLES.includes(r));
          if (invalidRoles.length > 0) {
            errors.push({
              row: rowNum,
              field: 'role',
              message: `Invalid role(s): ${invalidRoles.join(', ')}. Valid: ${VALID_ROLES.join(', ')}`,
            });
            continue;
          }

          if (roles.length === 0) {
            roles.push('ATHLETE');
          }

          validRows.push({ email, roles });
        }

        // Detect duplicates
        const duplicates: { email: string; rows: number[] }[] = [];
        for (const [email, rows] of emailOccurrences) {
          if (rows.length > 1) {
            duplicates.push({ email, rows });
            for (let i = 1; i < rows.length; i++) {
              errors.push({
                row: rows[i],
                field: 'email',
                message: `Duplicate email (first on row ${rows[0]})`,
              });
            }
          }
        }

        // Deduplicate valid rows (keep first occurrence)
        const duplicateEmails = new Set(duplicates.map((d) => d.email));
        const deduplicatedRows: ParsedMembershipRow[] = [];
        const seenEmails = new Set<string>();

        for (const row of validRows) {
          if (duplicateEmails.has(row.email)) {
            if (!seenEmails.has(row.email)) {
              deduplicatedRows.push(row);
              seenEmails.add(row.email);
            }
          } else {
            deduplicatedRows.push(row);
          }
        }

        if (deduplicatedRows.length === 0 && errors.length === 0) {
          setParseError('No valid rows found. Expected columns: email, role (or roles)');
          return;
        }

        setParseResult({
          validRows: deduplicatedRows,
          errors,
          duplicates,
        });
      },
      error: (error) => {
        setIsLoading(false);
        setParseError(`Failed to parse CSV: ${error.message}`);
      },
    });
  }, []);

  const clearData = useCallback(() => {
    setParseResult(null);
    setParseError(null);
    setIsLoading(false);
  }, []);

  return { parseResult, parseError, isLoading, parseFile, clearData };
}
```
  </action>
  <verify>TypeScript compiles, hook handles CSV parsing with role validation</verify>
  <done>useMembershipCSVParser hook parses email,role CSV with validation and duplicate detection</done>
</task>

<task type="auto">
  <name>Task 2: Create bulk membership API endpoint and audit action</name>
  <files>src/app/api/admin/clubs/[clubId]/members/bulk/route.ts, src/lib/audit/actions.ts</files>
  <action>
**Add audit action to actions.ts:**

Add `ADMIN_MEMBERSHIPS_BULK_ADDED: 'ADMIN_MEMBERSHIPS_BULK_ADDED'` to AUDITABLE_ACTIONS object and corresponding description.

**POST /api/admin/clubs/[clubId]/members/bulk:**

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { prisma } from '@/lib/prisma';
import { getSuperAdminContext } from '@/lib/auth/admin-authorize';
import { getSupabaseAdmin } from '@/lib/supabase/admin';
import { createAdminAuditLogger } from '@/lib/audit/logger';
import { unauthorizedResponse, notFoundResponse, serverErrorResponse } from '@/lib/errors';

const MAX_BATCH_SIZE = 100;

const roleEnum = z.enum(['FACILITY_ADMIN', 'CLUB_ADMIN', 'COACH', 'ATHLETE', 'PARENT']);

const bulkMemberSchema = z.object({
  email: z.string().email(),
  roles: z.array(roleEnum).min(1).default(['ATHLETE']),
});

const bulkAddSchema = z.object({
  members: z.array(bulkMemberSchema).min(1).max(MAX_BATCH_SIZE),
});

interface MemberResult {
  email: string;
  status: 'added' | 'updated' | 'skipped' | 'failed';
  membershipId?: string;
  reason?: string;
}

interface RouteParams {
  params: Promise<{ clubId: string }>;
}

export async function POST(request: NextRequest, { params }: RouteParams) {
  try {
    const adminContext = await getSuperAdminContext();
    if (!adminContext) return unauthorizedResponse();

    const { clubId } = await params;

    // Verify club exists
    const club = await prisma.team.findUnique({
      where: { id: clubId },
      select: { id: true, name: true },
    });
    if (!club) return notFoundResponse('Club');

    // Parse request
    let body: unknown;
    try {
      body = await request.json();
    } catch {
      return NextResponse.json({ error: 'Invalid JSON body' }, { status: 400 });
    }

    const parseResult = bulkAddSchema.safeParse(body);
    if (!parseResult.success) {
      return NextResponse.json(
        { error: parseResult.error.issues[0]?.message || 'Invalid request' },
        { status: 400 }
      );
    }

    const { members } = parseResult.data;

    // Get Supabase admin to look up users by email
    const supabase = getSupabaseAdmin();
    if (!supabase) {
      return NextResponse.json({ error: 'Admin operations not available' }, { status: 500 });
    }

    // Fetch all users to build email -> userId map
    const { data: allUsers, error: listError } = await supabase.auth.admin.listUsers();
    if (listError) {
      return serverErrorResponse(listError, 'admin/clubs/[clubId]/members/bulk:listUsers');
    }

    const emailToUser = new Map<string, { id: string; email: string }>();
    for (const user of allUsers.users) {
      if (user.email) {
        emailToUser.set(user.email.toLowerCase(), { id: user.id, email: user.email });
      }
    }

    // Get existing memberships for this club
    const existingMemberships = await prisma.clubMembership.findMany({
      where: { clubId },
      select: { id: true, userId: true, roles: true, isActive: true },
    });
    const userIdToMembership = new Map(existingMemberships.map((m) => [m.userId, m]));

    // Process each row
    const results: MemberResult[] = [];
    let addedCount = 0;
    let updatedCount = 0;
    let skippedCount = 0;
    let failedCount = 0;

    for (const memberData of members) {
      const emailLower = memberData.email.toLowerCase();
      const user = emailToUser.get(emailLower);

      if (!user) {
        results.push({
          email: memberData.email,
          status: 'skipped',
          reason: 'User not found - must be registered first',
        });
        skippedCount++;
        continue;
      }

      const existingMembership = userIdToMembership.get(user.id);

      try {
        if (existingMembership) {
          if (existingMembership.isActive) {
            // Update roles if different
            const rolesChanged =
              existingMembership.roles.length !== memberData.roles.length ||
              !existingMembership.roles.every((r) => memberData.roles.includes(r as any));

            if (rolesChanged) {
              await prisma.clubMembership.update({
                where: { id: existingMembership.id },
                data: { roles: memberData.roles },
              });
              results.push({
                email: memberData.email,
                status: 'updated',
                membershipId: existingMembership.id,
                reason: 'Roles updated',
              });
              updatedCount++;
            } else {
              results.push({
                email: memberData.email,
                status: 'skipped',
                membershipId: existingMembership.id,
                reason: 'Already member with same roles',
              });
              skippedCount++;
            }
          } else {
            // Reactivate
            await prisma.clubMembership.update({
              where: { id: existingMembership.id },
              data: { isActive: true, roles: memberData.roles },
            });
            results.push({
              email: memberData.email,
              status: 'added',
              membershipId: existingMembership.id,
              reason: 'Reactivated',
            });
            addedCount++;
          }
        } else {
          // Create new membership
          const membership = await prisma.clubMembership.create({
            data: {
              clubId,
              userId: user.id,
              roles: memberData.roles,
              isActive: true,
            },
          });
          results.push({
            email: memberData.email,
            status: 'added',
            membershipId: membership.id,
          });
          addedCount++;

          // Update map for duplicate handling within batch
          userIdToMembership.set(user.id, { ...membership, isActive: true });
        }
      } catch (error) {
        console.error(`[bulk-members] Error processing ${memberData.email}:`, error);
        results.push({
          email: memberData.email,
          status: 'failed',
          reason: error instanceof Error ? error.message : 'Unknown error',
        });
        failedCount++;
      }
    }

    // Audit log
    const audit = createAdminAuditLogger(request, adminContext.userId);
    await audit.log({
      action: 'ADMIN_MEMBERSHIPS_BULK_ADDED',
      targetType: 'Club',
      targetId: clubId,
      afterState: {
        clubName: club.name,
        totalRequested: members.length,
        added: addedCount,
        updated: updatedCount,
        skipped: skippedCount,
        failed: failedCount,
        emails: members.map((m) => m.email),
      },
    });

    return NextResponse.json({
      success: failedCount === 0,
      results,
      summary: {
        total: members.length,
        added: addedCount,
        updated: updatedCount,
        skipped: skippedCount,
        failed: failedCount,
      },
    });
  } catch (error) {
    return serverErrorResponse(error, 'admin/clubs/[clubId]/members/bulk:POST');
  }
}
```
  </action>
  <verify>
- `curl -X POST /api/admin/clubs/[clubId]/members/bulk` with valid CSV data returns results
- Unknown emails are skipped with reason
- Existing members have roles updated if different
  </verify>
  <done>Bulk membership API creates/updates memberships, skips unknown users, returns detailed results</done>
</task>

<task type="auto">
  <name>Task 3: Create bulk upload page and form</name>
  <files>src/app/(admin)/admin/clubs/[clubId]/members/bulk/page.tsx, src/components/admin/memberships/bulk-membership-form.tsx, src/components/admin/memberships/club-members-section.tsx</files>
  <action>
**BulkMembershipForm** - Adapt from `bulk-upload-form.tsx`:

Props: `{ clubId, clubName }`

Features:
1. CSV format guide (email, role columns)
2. File upload with drag-and-drop
3. Preview table (email, roles)
4. Error display for invalid rows
5. Duplicate warning display
6. Submit button with loading state
7. Results summary (added/updated/skipped/failed)
8. Detailed results table

Follow exact pattern from `src/components/admin/users/bulk-upload-form.tsx` but:
- Use `useMembershipCSVParser` instead of `useAdminCSVParser`
- POST to `/api/admin/clubs/[clubId]/members/bulk`
- Show roles column in preview

**Bulk upload page:**

```typescript
// src/app/(admin)/admin/clubs/[clubId]/members/bulk/page.tsx
import { cookies } from 'next/headers';
import { notFound } from 'next/navigation';
import Link from 'next/link';
import { BulkMembershipForm } from '@/components/admin/memberships/bulk-membership-form';

interface Props {
  params: Promise<{ clubId: string }>;
}

export default async function BulkMembersPage({ params }: Props) {
  const { clubId } = await params;

  const cookieStore = await cookies();
  const cookieHeader = cookieStore.getAll().map((c) => `${c.name}=${c.value}`).join('; ');

  const res = await fetch(
    `${process.env.NEXT_PUBLIC_APP_URL}/api/admin/clubs/${clubId}`,
    { headers: { Cookie: cookieHeader }, cache: 'no-store' }
  );

  if (res.status === 404) notFound();
  if (!res.ok) throw new Error('Failed to fetch club');

  const { club } = await res.json();

  return (
    <div className="space-y-6">
      <div>
        <Link href={`/admin/clubs/${clubId}`} className="text-sm text-[var(--text-muted)] hover:underline">
          &larr; Back to {club.name}
        </Link>
        <h1 className="text-2xl font-bold mt-2 text-[var(--text-primary)]">
          Bulk Add Members
        </h1>
        <p className="text-[var(--text-muted)] mt-1">
          Upload a CSV file to add multiple users to {club.name}
        </p>
      </div>

      <BulkMembershipForm clubId={clubId} clubName={club.name} />
    </div>
  );
}
```

**Update ClubMembersSection:**

Add "Bulk Import" button next to "Add Member":

```tsx
<div className="flex items-center gap-2">
  <Link href={`/admin/clubs/${clubId}/members/bulk`}>
    <Button size="sm" variant="outline">
      <Upload className="h-4 w-4 mr-1" />
      Bulk Import
    </Button>
  </Link>
  <Button size="sm" onClick={() => setAddDialogOpen(true)}>
    <Plus className="h-4 w-4 mr-1" />
    Add Member
  </Button>
</div>
```

Import `Link` from 'next/link' and `Upload` from 'lucide-react'.
  </action>
  <verify>
- Navigate to /admin/clubs/[clubId]/members/bulk
- Upload CSV - see preview
- Submit - see results summary and detailed results
- Bulk Import button appears in club members section
  </verify>
  <done>Bulk membership import page with CSV upload, preview, and results display</done>
</task>

</tasks>

<verification>
1. Run `npm run build` - should complete without errors
2. Navigate to /admin/clubs/[clubId] - see "Bulk Import" button
3. Click "Bulk Import" - navigate to bulk page with format guide
4. Upload CSV with valid and invalid emails
5. Preview shows valid rows, errors shown separately
6. Submit - results show added/updated/skipped/failed counts
7. Navigate back to club - see new members in list
8. Upload CSV with existing members - shows "updated" or "skipped"
</verification>

<success_criteria>
- CSV with email,role format parses correctly
- Unknown emails skipped with "User not found" message
- Existing members get roles updated (if different) or skipped (if same)
- New members added with specified roles
- Results summary shows accurate counts
- Detailed results show status per email
- Audit log captures bulk operation
- Max 100 members per batch enforced
</success_criteria>

<output>
After completion, create `.planning/phases/39-membership-management/39-04-SUMMARY.md`
</output>
